/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./Entity.js":
/*!*******************!*\
  !*** ./Entity.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var kontra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! kontra */ "../node_modules/kontra/kontra.mjs");


class Entity {
  static entities = [];
  constructor(props) {
    Entity.entities.push((0,kontra__WEBPACK_IMPORTED_MODULE_0__.Sprite)(props))
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Entity);

/***/ }),

/***/ "../../node_modules/colyseus.js/dist/colyseus.js":
/*!*******************************************************!*\
  !*** ../../node_modules/colyseus.js/dist/colyseus.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// colyseus.js@0.14.13 (@colyseus/schema 1.0.25)
(function (global, factory) {
     true ? factory(exports) :
    0;
}(this, (function (exports) { 'use strict';

    //
    // Polyfills for legacy environments
    //
    /*
     * Support Android 4.4.x
     */
    if (!ArrayBuffer.isView) {
        ArrayBuffer.isView = function (a) {
            return a !== null && typeof (a) === 'object' && a.buffer instanceof ArrayBuffer;
        };
    }
    // Define globalThis if not available.
    // https://github.com/colyseus/colyseus.js/issues/86
    if (typeof (globalThis) === "undefined" &&
        typeof (window) !== "undefined") {
        // @ts-ignore
        window['globalThis'] = window;
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function apply(src, tar) {
    	tar.headers = src.headers || {};
    	tar.statusMessage = src.statusText;
    	tar.statusCode = src.status;
    	tar.data = src.response;
    }

    function send(method, uri, opts) {
    	return new Promise(function (res, rej) {
    		opts = opts || {};
    		var req = new XMLHttpRequest;
    		var k, tmp, arr, str=opts.body;
    		var headers = opts.headers || {};

    		// IE compatible
    		if (opts.timeout) req.timeout = opts.timeout;
    		req.ontimeout = req.onerror = function (err) {
    			err.timeout = err.type == 'timeout';
    			rej(err);
    		};

    		req.open(method, uri.href || uri);

    		req.onload = function () {
    			arr = req.getAllResponseHeaders().trim().split(/[\r\n]+/);
    			apply(req, req); //=> req.headers

    			while (tmp = arr.shift()) {
    				tmp = tmp.split(': ');
    				req.headers[tmp.shift().toLowerCase()] = tmp.join(': ');
    			}

    			tmp = req.headers['content-type'];
    			if (tmp && !!~tmp.indexOf('application/json')) {
    				try {
    					req.data = JSON.parse(req.data, opts.reviver);
    				} catch (err) {
    					apply(req, err);
    					return rej(err);
    				}
    			}

    			(req.status >= 400 ? rej : res)(req);
    		};

    		if (typeof FormData < 'u' && str instanceof FormData) ; else if (str && typeof str == 'object') {
    			headers['content-type'] = 'application/json';
    			str = JSON.stringify(str);
    		}

    		req.withCredentials = !!opts.withCredentials;

    		for (k in headers) {
    			req.setRequestHeader(k, headers[k]);
    		}

    		req.send(str);
    	});
    }

    var get = /*#__PURE__*/ send.bind(send, 'GET');
    var post = /*#__PURE__*/ send.bind(send, 'POST');
    var patch = /*#__PURE__*/ send.bind(send, 'PATCH');
    var del = /*#__PURE__*/ send.bind(send, 'DELETE');
    var put = /*#__PURE__*/ send.bind(send, 'PUT');

    var del_1 = del;
    var get_1 = get;
    var patch_1 = patch;
    var post_1 = post;
    var put_1 = put;
    var send_1 = send;

    var xhr = {
    	del: del_1,
    	get: get_1,
    	patch: patch_1,
    	post: post_1,
    	put: put_1,
    	send: send_1
    };

    var http = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), xhr, {
        'default': xhr,
        del: del_1,
        get: get_1,
        patch: patch_1,
        post: post_1,
        put: put_1,
        send: send_1
    }));

    var ServerError = /** @class */ (function (_super) {
        __extends(ServerError, _super);
        function ServerError(code, message) {
            var _this = _super.call(this, message) || this;
            _this.name = "ServerError";
            _this.code = code;
            return _this;
        }
        return ServerError;
    }(Error));

    /**
     * Copyright (c) 2014 Ion Drive Software Ltd.
     * https://github.com/darrachequesne/notepack/
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    /**
     * Patch for Colyseus:
     * -------------------
     *
     * added `offset` on Decoder constructor, for messages arriving with a code
     * before actual msgpack data
     */
    // 
    // DECODER
    // 
    function Decoder(buffer, offset) {
        this._offset = offset;
        if (buffer instanceof ArrayBuffer) {
            this._buffer = buffer;
            this._view = new DataView(this._buffer);
        }
        else if (ArrayBuffer.isView(buffer)) {
            this._buffer = buffer.buffer;
            this._view = new DataView(this._buffer, buffer.byteOffset, buffer.byteLength);
        }
        else {
            throw new Error('Invalid argument');
        }
    }
    function utf8Read$1(view, offset, length) {
        var string = '', chr = 0;
        for (var i = offset, end = offset + length; i < end; i++) {
            var byte = view.getUint8(i);
            if ((byte & 0x80) === 0x00) {
                string += String.fromCharCode(byte);
                continue;
            }
            if ((byte & 0xe0) === 0xc0) {
                string += String.fromCharCode(((byte & 0x1f) << 6) |
                    (view.getUint8(++i) & 0x3f));
                continue;
            }
            if ((byte & 0xf0) === 0xe0) {
                string += String.fromCharCode(((byte & 0x0f) << 12) |
                    ((view.getUint8(++i) & 0x3f) << 6) |
                    ((view.getUint8(++i) & 0x3f) << 0));
                continue;
            }
            if ((byte & 0xf8) === 0xf0) {
                chr = ((byte & 0x07) << 18) |
                    ((view.getUint8(++i) & 0x3f) << 12) |
                    ((view.getUint8(++i) & 0x3f) << 6) |
                    ((view.getUint8(++i) & 0x3f) << 0);
                if (chr >= 0x010000) { // surrogate pair
                    chr -= 0x010000;
                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
                }
                else {
                    string += String.fromCharCode(chr);
                }
                continue;
            }
            throw new Error('Invalid byte ' + byte.toString(16));
        }
        return string;
    }
    Decoder.prototype._array = function (length) {
        var value = new Array(length);
        for (var i = 0; i < length; i++) {
            value[i] = this._parse();
        }
        return value;
    };
    Decoder.prototype._map = function (length) {
        var key = '', value = {};
        for (var i = 0; i < length; i++) {
            key = this._parse();
            value[key] = this._parse();
        }
        return value;
    };
    Decoder.prototype._str = function (length) {
        var value = utf8Read$1(this._view, this._offset, length);
        this._offset += length;
        return value;
    };
    Decoder.prototype._bin = function (length) {
        var value = this._buffer.slice(this._offset, this._offset + length);
        this._offset += length;
        return value;
    };
    Decoder.prototype._parse = function () {
        var prefix = this._view.getUint8(this._offset++);
        var value, length = 0, type = 0, hi = 0, lo = 0;
        if (prefix < 0xc0) {
            // positive fixint
            if (prefix < 0x80) {
                return prefix;
            }
            // fixmap
            if (prefix < 0x90) {
                return this._map(prefix & 0x0f);
            }
            // fixarray
            if (prefix < 0xa0) {
                return this._array(prefix & 0x0f);
            }
            // fixstr
            return this._str(prefix & 0x1f);
        }
        // negative fixint
        if (prefix > 0xdf) {
            return (0xff - prefix + 1) * -1;
        }
        switch (prefix) {
            // nil
            case 0xc0:
                return null;
            // false
            case 0xc2:
                return false;
            // true
            case 0xc3:
                return true;
            // bin
            case 0xc4:
                length = this._view.getUint8(this._offset);
                this._offset += 1;
                return this._bin(length);
            case 0xc5:
                length = this._view.getUint16(this._offset);
                this._offset += 2;
                return this._bin(length);
            case 0xc6:
                length = this._view.getUint32(this._offset);
                this._offset += 4;
                return this._bin(length);
            // ext
            case 0xc7:
                length = this._view.getUint8(this._offset);
                type = this._view.getInt8(this._offset + 1);
                this._offset += 2;
                return [type, this._bin(length)];
            case 0xc8:
                length = this._view.getUint16(this._offset);
                type = this._view.getInt8(this._offset + 2);
                this._offset += 3;
                return [type, this._bin(length)];
            case 0xc9:
                length = this._view.getUint32(this._offset);
                type = this._view.getInt8(this._offset + 4);
                this._offset += 5;
                return [type, this._bin(length)];
            // float
            case 0xca:
                value = this._view.getFloat32(this._offset);
                this._offset += 4;
                return value;
            case 0xcb:
                value = this._view.getFloat64(this._offset);
                this._offset += 8;
                return value;
            // uint
            case 0xcc:
                value = this._view.getUint8(this._offset);
                this._offset += 1;
                return value;
            case 0xcd:
                value = this._view.getUint16(this._offset);
                this._offset += 2;
                return value;
            case 0xce:
                value = this._view.getUint32(this._offset);
                this._offset += 4;
                return value;
            case 0xcf:
                hi = this._view.getUint32(this._offset) * Math.pow(2, 32);
                lo = this._view.getUint32(this._offset + 4);
                this._offset += 8;
                return hi + lo;
            // int
            case 0xd0:
                value = this._view.getInt8(this._offset);
                this._offset += 1;
                return value;
            case 0xd1:
                value = this._view.getInt16(this._offset);
                this._offset += 2;
                return value;
            case 0xd2:
                value = this._view.getInt32(this._offset);
                this._offset += 4;
                return value;
            case 0xd3:
                hi = this._view.getInt32(this._offset) * Math.pow(2, 32);
                lo = this._view.getUint32(this._offset + 4);
                this._offset += 8;
                return hi + lo;
            // fixext
            case 0xd4:
                type = this._view.getInt8(this._offset);
                this._offset += 1;
                if (type === 0x00) {
                    this._offset += 1;
                    return void 0;
                }
                return [type, this._bin(1)];
            case 0xd5:
                type = this._view.getInt8(this._offset);
                this._offset += 1;
                return [type, this._bin(2)];
            case 0xd6:
                type = this._view.getInt8(this._offset);
                this._offset += 1;
                return [type, this._bin(4)];
            case 0xd7:
                type = this._view.getInt8(this._offset);
                this._offset += 1;
                if (type === 0x00) {
                    hi = this._view.getInt32(this._offset) * Math.pow(2, 32);
                    lo = this._view.getUint32(this._offset + 4);
                    this._offset += 8;
                    return new Date(hi + lo);
                }
                return [type, this._bin(8)];
            case 0xd8:
                type = this._view.getInt8(this._offset);
                this._offset += 1;
                return [type, this._bin(16)];
            // str
            case 0xd9:
                length = this._view.getUint8(this._offset);
                this._offset += 1;
                return this._str(length);
            case 0xda:
                length = this._view.getUint16(this._offset);
                this._offset += 2;
                return this._str(length);
            case 0xdb:
                length = this._view.getUint32(this._offset);
                this._offset += 4;
                return this._str(length);
            // array
            case 0xdc:
                length = this._view.getUint16(this._offset);
                this._offset += 2;
                return this._array(length);
            case 0xdd:
                length = this._view.getUint32(this._offset);
                this._offset += 4;
                return this._array(length);
            // map
            case 0xde:
                length = this._view.getUint16(this._offset);
                this._offset += 2;
                return this._map(length);
            case 0xdf:
                length = this._view.getUint32(this._offset);
                this._offset += 4;
                return this._map(length);
        }
        throw new Error('Could not parse');
    };
    function decode(buffer, offset) {
        if (offset === void 0) { offset = 0; }
        var decoder = new Decoder(buffer, offset);
        var value = decoder._parse();
        if (decoder._offset !== buffer.byteLength) {
            throw new Error((buffer.byteLength - decoder._offset) + ' trailing bytes');
        }
        return value;
    }
    // 
    // ENCODER
    // 
    function utf8Write(view, offset, str) {
        var c = 0;
        for (var i = 0, l = str.length; i < l; i++) {
            c = str.charCodeAt(i);
            if (c < 0x80) {
                view.setUint8(offset++, c);
            }
            else if (c < 0x800) {
                view.setUint8(offset++, 0xc0 | (c >> 6));
                view.setUint8(offset++, 0x80 | (c & 0x3f));
            }
            else if (c < 0xd800 || c >= 0xe000) {
                view.setUint8(offset++, 0xe0 | (c >> 12));
                view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);
                view.setUint8(offset++, 0x80 | (c & 0x3f));
            }
            else {
                i++;
                c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                view.setUint8(offset++, 0xf0 | (c >> 18));
                view.setUint8(offset++, 0x80 | (c >> 12) & 0x3f);
                view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);
                view.setUint8(offset++, 0x80 | (c & 0x3f));
            }
        }
    }
    function utf8Length$1(str) {
        var c = 0, length = 0;
        for (var i = 0, l = str.length; i < l; i++) {
            c = str.charCodeAt(i);
            if (c < 0x80) {
                length += 1;
            }
            else if (c < 0x800) {
                length += 2;
            }
            else if (c < 0xd800 || c >= 0xe000) {
                length += 3;
            }
            else {
                i++;
                length += 4;
            }
        }
        return length;
    }
    function _encode(bytes, defers, value) {
        var type = typeof value, i = 0, l = 0, hi = 0, lo = 0, length = 0, size = 0;
        if (type === 'string') {
            length = utf8Length$1(value);
            // fixstr
            if (length < 0x20) {
                bytes.push(length | 0xa0);
                size = 1;
            }
            // str 8
            else if (length < 0x100) {
                bytes.push(0xd9, length);
                size = 2;
            }
            // str 16
            else if (length < 0x10000) {
                bytes.push(0xda, length >> 8, length);
                size = 3;
            }
            // str 32
            else if (length < 0x100000000) {
                bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);
                size = 5;
            }
            else {
                throw new Error('String too long');
            }
            defers.push({ _str: value, _length: length, _offset: bytes.length });
            return size + length;
        }
        if (type === 'number') {
            // TODO: encode to float 32?
            // float 64
            if (Math.floor(value) !== value || !isFinite(value)) {
                bytes.push(0xcb);
                defers.push({ _float: value, _length: 8, _offset: bytes.length });
                return 9;
            }
            if (value >= 0) {
                // positive fixnum
                if (value < 0x80) {
                    bytes.push(value);
                    return 1;
                }
                // uint 8
                if (value < 0x100) {
                    bytes.push(0xcc, value);
                    return 2;
                }
                // uint 16
                if (value < 0x10000) {
                    bytes.push(0xcd, value >> 8, value);
                    return 3;
                }
                // uint 32
                if (value < 0x100000000) {
                    bytes.push(0xce, value >> 24, value >> 16, value >> 8, value);
                    return 5;
                }
                // uint 64
                hi = (value / Math.pow(2, 32)) >> 0;
                lo = value >>> 0;
                bytes.push(0xcf, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
                return 9;
            }
            else {
                // negative fixnum
                if (value >= -0x20) {
                    bytes.push(value);
                    return 1;
                }
                // int 8
                if (value >= -0x80) {
                    bytes.push(0xd0, value);
                    return 2;
                }
                // int 16
                if (value >= -0x8000) {
                    bytes.push(0xd1, value >> 8, value);
                    return 3;
                }
                // int 32
                if (value >= -0x80000000) {
                    bytes.push(0xd2, value >> 24, value >> 16, value >> 8, value);
                    return 5;
                }
                // int 64
                hi = Math.floor(value / Math.pow(2, 32));
                lo = value >>> 0;
                bytes.push(0xd3, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
                return 9;
            }
        }
        if (type === 'object') {
            // nil
            if (value === null) {
                bytes.push(0xc0);
                return 1;
            }
            if (Array.isArray(value)) {
                length = value.length;
                // fixarray
                if (length < 0x10) {
                    bytes.push(length | 0x90);
                    size = 1;
                }
                // array 16
                else if (length < 0x10000) {
                    bytes.push(0xdc, length >> 8, length);
                    size = 3;
                }
                // array 32
                else if (length < 0x100000000) {
                    bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length);
                    size = 5;
                }
                else {
                    throw new Error('Array too large');
                }
                for (i = 0; i < length; i++) {
                    size += _encode(bytes, defers, value[i]);
                }
                return size;
            }
            // fixext 8 / Date
            if (value instanceof Date) {
                var time = value.getTime();
                hi = Math.floor(time / Math.pow(2, 32));
                lo = time >>> 0;
                bytes.push(0xd7, 0, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
                return 10;
            }
            if (value instanceof ArrayBuffer) {
                length = value.byteLength;
                // bin 8
                if (length < 0x100) {
                    bytes.push(0xc4, length);
                    size = 2;
                }
                else 
                // bin 16
                if (length < 0x10000) {
                    bytes.push(0xc5, length >> 8, length);
                    size = 3;
                }
                else 
                // bin 32
                if (length < 0x100000000) {
                    bytes.push(0xc6, length >> 24, length >> 16, length >> 8, length);
                    size = 5;
                }
                else {
                    throw new Error('Buffer too large');
                }
                defers.push({ _bin: value, _length: length, _offset: bytes.length });
                return size + length;
            }
            if (typeof value.toJSON === 'function') {
                return _encode(bytes, defers, value.toJSON());
            }
            var keys = [], key = '';
            var allKeys = Object.keys(value);
            for (i = 0, l = allKeys.length; i < l; i++) {
                key = allKeys[i];
                if (typeof value[key] !== 'function') {
                    keys.push(key);
                }
            }
            length = keys.length;
            // fixmap
            if (length < 0x10) {
                bytes.push(length | 0x80);
                size = 1;
            }
            // map 16
            else if (length < 0x10000) {
                bytes.push(0xde, length >> 8, length);
                size = 3;
            }
            // map 32
            else if (length < 0x100000000) {
                bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length);
                size = 5;
            }
            else {
                throw new Error('Object too large');
            }
            for (i = 0; i < length; i++) {
                key = keys[i];
                size += _encode(bytes, defers, key);
                size += _encode(bytes, defers, value[key]);
            }
            return size;
        }
        // false/true
        if (type === 'boolean') {
            bytes.push(value ? 0xc3 : 0xc2);
            return 1;
        }
        // fixext 1 / undefined
        if (type === 'undefined') {
            bytes.push(0xd4, 0, 0);
            return 3;
        }
        throw new Error('Could not encode');
    }
    function encode(value) {
        var bytes = [];
        var defers = [];
        var size = _encode(bytes, defers, value);
        var buf = new ArrayBuffer(size);
        var view = new DataView(buf);
        var deferIndex = 0;
        var deferWritten = 0;
        var nextOffset = -1;
        if (defers.length > 0) {
            nextOffset = defers[0]._offset;
        }
        var defer, deferLength = 0, offset = 0;
        for (var i = 0, l = bytes.length; i < l; i++) {
            view.setUint8(deferWritten + i, bytes[i]);
            if (i + 1 !== nextOffset) {
                continue;
            }
            defer = defers[deferIndex];
            deferLength = defer._length;
            offset = deferWritten + nextOffset;
            if (defer._bin) {
                var bin = new Uint8Array(defer._bin);
                for (var j = 0; j < deferLength; j++) {
                    view.setUint8(offset + j, bin[j]);
                }
            }
            else if (defer._str) {
                utf8Write(view, offset, defer._str);
            }
            else if (defer._float !== undefined) {
                view.setFloat64(offset, defer._float);
            }
            deferIndex++;
            deferWritten += deferLength;
            if (defers[deferIndex]) {
                nextOffset = defers[deferIndex]._offset;
            }
        }
        return buf;
    }

    var browser = function () {
      throw new Error(
        'ws does not work in the browser. Browser clients must use the native ' +
          'WebSocket object'
      );
    };

    var WebSocket = globalThis.WebSocket || browser;
    var WebSocketTransport = /** @class */ (function () {
        function WebSocketTransport(events) {
            this.events = events;
        }
        WebSocketTransport.prototype.send = function (data) {
            if (data instanceof ArrayBuffer) {
                this.ws.send(data);
            }
            else if (Array.isArray(data)) {
                this.ws.send((new Uint8Array(data)).buffer);
            }
        };
        WebSocketTransport.prototype.connect = function (url) {
            this.ws = new WebSocket(url, this.protocols);
            this.ws.binaryType = 'arraybuffer';
            this.ws.onopen = this.events.onopen;
            this.ws.onmessage = this.events.onmessage;
            this.ws.onclose = this.events.onclose;
            this.ws.onerror = this.events.onerror;
        };
        WebSocketTransport.prototype.close = function (code, reason) {
            this.ws.close(code, reason);
        };
        return WebSocketTransport;
    }());

    var Connection = /** @class */ (function () {
        function Connection() {
            this.events = {};
            this.transport = new WebSocketTransport(this.events);
        }
        Connection.prototype.send = function (data) {
            this.transport.send(data);
        };
        Connection.prototype.connect = function (url) {
            this.transport.connect(url);
        };
        Connection.prototype.close = function (code, reason) {
            this.transport.close(code, reason);
        };
        return Connection;
    }());

    var serializers = {};
    function registerSerializer(id, serializer) {
        serializers[id] = serializer;
    }
    function getSerializer(id) {
        var serializer = serializers[id];
        if (!serializer) {
            throw new Error("missing serializer: " + id);
        }
        return serializer;
    }

    // Use codes between 0~127 for lesser throughput (1 byte)
    exports.Protocol = void 0;
    (function (Protocol) {
        // Room-related (10~19)
        Protocol[Protocol["HANDSHAKE"] = 9] = "HANDSHAKE";
        Protocol[Protocol["JOIN_ROOM"] = 10] = "JOIN_ROOM";
        Protocol[Protocol["ERROR"] = 11] = "ERROR";
        Protocol[Protocol["LEAVE_ROOM"] = 12] = "LEAVE_ROOM";
        Protocol[Protocol["ROOM_DATA"] = 13] = "ROOM_DATA";
        Protocol[Protocol["ROOM_STATE"] = 14] = "ROOM_STATE";
        Protocol[Protocol["ROOM_STATE_PATCH"] = 15] = "ROOM_STATE_PATCH";
        Protocol[Protocol["ROOM_DATA_SCHEMA"] = 16] = "ROOM_DATA_SCHEMA";
    })(exports.Protocol || (exports.Protocol = {}));
    exports.ErrorCode = void 0;
    (function (ErrorCode) {
        ErrorCode[ErrorCode["MATCHMAKE_NO_HANDLER"] = 4210] = "MATCHMAKE_NO_HANDLER";
        ErrorCode[ErrorCode["MATCHMAKE_INVALID_CRITERIA"] = 4211] = "MATCHMAKE_INVALID_CRITERIA";
        ErrorCode[ErrorCode["MATCHMAKE_INVALID_ROOM_ID"] = 4212] = "MATCHMAKE_INVALID_ROOM_ID";
        ErrorCode[ErrorCode["MATCHMAKE_UNHANDLED"] = 4213] = "MATCHMAKE_UNHANDLED";
        ErrorCode[ErrorCode["MATCHMAKE_EXPIRED"] = 4214] = "MATCHMAKE_EXPIRED";
        ErrorCode[ErrorCode["AUTH_FAILED"] = 4215] = "AUTH_FAILED";
        ErrorCode[ErrorCode["APPLICATION_ERROR"] = 4216] = "APPLICATION_ERROR";
    })(exports.ErrorCode || (exports.ErrorCode = {}));
    function utf8Read(view, offset) {
        var length = view[offset++];
        var string = '', chr = 0;
        for (var i = offset, end = offset + length; i < end; i++) {
            var byte = view[i];
            if ((byte & 0x80) === 0x00) {
                string += String.fromCharCode(byte);
                continue;
            }
            if ((byte & 0xe0) === 0xc0) {
                string += String.fromCharCode(((byte & 0x1f) << 6) |
                    (view[++i] & 0x3f));
                continue;
            }
            if ((byte & 0xf0) === 0xe0) {
                string += String.fromCharCode(((byte & 0x0f) << 12) |
                    ((view[++i] & 0x3f) << 6) |
                    ((view[++i] & 0x3f) << 0));
                continue;
            }
            if ((byte & 0xf8) === 0xf0) {
                chr = ((byte & 0x07) << 18) |
                    ((view[++i] & 0x3f) << 12) |
                    ((view[++i] & 0x3f) << 6) |
                    ((view[++i] & 0x3f) << 0);
                if (chr >= 0x010000) { // surrogate pair
                    chr -= 0x010000;
                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
                }
                else {
                    string += String.fromCharCode(chr);
                }
                continue;
            }
            throw new Error('Invalid byte ' + byte.toString(16));
        }
        return string;
    }
    // Faster for short strings than Buffer.byteLength
    function utf8Length(str) {
        if (str === void 0) { str = ''; }
        var c = 0;
        var length = 0;
        for (var i = 0, l = str.length; i < l; i++) {
            c = str.charCodeAt(i);
            if (c < 0x80) {
                length += 1;
            }
            else if (c < 0x800) {
                length += 2;
            }
            else if (c < 0xd800 || c >= 0xe000) {
                length += 3;
            }
            else {
                i++;
                length += 4;
            }
        }
        return length + 1;
    }

    let createNanoEvents = () => ({
      events: {},
      emit(event, ...args) {
    (this.events[event] || []).forEach(i => i(...args));
      },
      on(event, cb) {
    (this.events[event] = this.events[event] || []).push(cb);
        return () =>
          (this.events[event] = (this.events[event] || []).filter(i => i !== cb))
      }
    });

    var EventEmitter = /** @class */ (function () {
        function EventEmitter() {
            this.handlers = [];
        }
        EventEmitter.prototype.register = function (cb, once) {
            this.handlers.push(cb);
            return this;
        };
        EventEmitter.prototype.invoke = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this.handlers.forEach(function (handler) { return handler.apply(_this, args); });
        };
        EventEmitter.prototype.invokeAsync = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return Promise.all(this.handlers.map(function (handler) { return handler.apply(_this, args); }));
        };
        EventEmitter.prototype.remove = function (cb) {
            var index = this.handlers.indexOf(cb);
            this.handlers[index] = this.handlers[this.handlers.length - 1];
            this.handlers.pop();
        };
        EventEmitter.prototype.clear = function () {
            this.handlers = [];
        };
        return EventEmitter;
    }());
    function createSignal() {
        var emitter = new EventEmitter();
        function register(cb) {
            return emitter.register(cb, this === null);
        }
        register.once = function (cb) {
            var callback = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                cb.apply(this, args);
                emitter.remove(callback);
            };
            emitter.register(callback);
        };
        register.remove = function (cb) { return emitter.remove(cb); };
        register.invoke = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return emitter.invoke.apply(emitter, args);
        };
        register.invokeAsync = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return emitter.invokeAsync.apply(emitter, args);
        };
        register.clear = function () { return emitter.clear(); };
        return register;
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var umd = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        factory(exports) ;
    }(commonjsGlobal, (function (exports) {
        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation.

        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.

        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
        /* global Reflect, Promise */

        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };

        function __extends(d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        }

        function __decorate(decorators, target, key, desc) {
            var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
            if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
            else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
            return c > 3 && r && Object.defineProperty(target, key, r), r;
        }

        function __spreadArray(to, from) {
            for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
                to[j] = from[i];
            return to;
        }

        // export const SWITCH_TO_STRUCTURE = 193; (easily collides with DELETE_AND_ADD + fieldIndex = 2)
        var SWITCH_TO_STRUCTURE = 255; // (decoding collides with DELETE_AND_ADD + fieldIndex = 63)
        var TYPE_ID = 213;
        /**
         * Encoding Schema field operations.
         */
        exports.OPERATION = void 0;
        (function (OPERATION) {
            // add new structure/primitive
            OPERATION[OPERATION["ADD"] = 128] = "ADD";
            // replace structure/primitive
            OPERATION[OPERATION["REPLACE"] = 0] = "REPLACE";
            // delete field
            OPERATION[OPERATION["DELETE"] = 64] = "DELETE";
            // DELETE field, followed by an ADD
            OPERATION[OPERATION["DELETE_AND_ADD"] = 192] = "DELETE_AND_ADD";
            // TOUCH is used to determine hierarchy of nested Schema structures during serialization.
            // touches are NOT encoded.
            OPERATION[OPERATION["TOUCH"] = 1] = "TOUCH";
            // MapSchema Operations
            OPERATION[OPERATION["CLEAR"] = 10] = "CLEAR";
        })(exports.OPERATION || (exports.OPERATION = {}));
        // export enum OPERATION {
        //     // add new structure/primitive
        //     // (128)
        //     ADD = 128, // 10000000,
        //     // replace structure/primitive
        //     REPLACE = 1,// 00000001
        //     // delete field
        //     DELETE = 192, // 11000000
        //     // DELETE field, followed by an ADD
        //     DELETE_AND_ADD = 224, // 11100000
        //     // TOUCH is used to determine hierarchy of nested Schema structures during serialization.
        //     // touches are NOT encoded.
        //     TOUCH = 0, // 00000000
        //     // MapSchema Operations
        //     CLEAR = 10,
        // }

        //
        // Root holds all schema references by unique id
        //
        var Root = /** @class */ (function () {
            function Root() {
                //
                // Relation of refId => Schema structure
                // For direct access of structures during decoding time.
                //
                this.refs = new Map();
                this.refCounts = {};
                this.deletedRefs = new Set();
                this.nextUniqueId = 0;
            }
            Root.prototype.getNextUniqueId = function () {
                return this.nextUniqueId++;
            };
            // for decoding
            Root.prototype.addRef = function (refId, ref, incrementCount) {
                if (incrementCount === void 0) { incrementCount = true; }
                this.refs.set(refId, ref);
                if (incrementCount) {
                    this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;
                }
            };
            // for decoding
            Root.prototype.removeRef = function (refId) {
                this.refCounts[refId] = this.refCounts[refId] - 1;
                this.deletedRefs.add(refId);
            };
            Root.prototype.clearRefs = function () {
                this.refs.clear();
                this.deletedRefs.clear();
                this.refCounts = {};
            };
            // for decoding
            Root.prototype.garbageCollectDeletedRefs = function () {
                var _this = this;
                this.deletedRefs.forEach(function (refId) {
                    if (_this.refCounts[refId] <= 0) {
                        var ref = _this.refs.get(refId);
                        //
                        // Ensure child schema instances have their references removed as well.
                        //
                        if (ref instanceof Schema) {
                            for (var fieldName in ref['_definition'].schema) {
                                if (typeof (ref['_definition'].schema[fieldName]) !== "string" &&
                                    ref[fieldName] &&
                                    ref[fieldName]['$changes']) {
                                    _this.removeRef(ref[fieldName]['$changes'].refId);
                                }
                            }
                        }
                        else {
                            var definition = ref['$changes'].parent._definition;
                            var type = definition.schema[definition.fieldsByIndex[ref['$changes'].parentIndex]];
                            if (typeof (Object.values(type)[0]) === "function") {
                                Array.from(ref.values())
                                    .forEach(function (child) { return _this.removeRef(child['$changes'].refId); });
                            }
                        }
                        _this.refs.delete(refId);
                        delete _this.refCounts[refId];
                    }
                });
                // clear deleted refs.
                this.deletedRefs.clear();
            };
            return Root;
        }());
        var ChangeTree = /** @class */ (function () {
            function ChangeTree(ref, parent, root) {
                this.changed = false;
                this.changes = new Map();
                this.allChanges = new Set();
                // cached indexes for filtering
                this.caches = {};
                this.currentCustomOperation = 0;
                this.ref = ref;
                this.setParent(parent, root);
            }
            ChangeTree.prototype.setParent = function (parent, root, parentIndex) {
                var _this = this;
                if (!this.indexes) {
                    this.indexes = (this.ref instanceof Schema)
                        ? this.ref['_definition'].indexes
                        : {};
                }
                this.parent = parent;
                this.parentIndex = parentIndex;
                // avoid setting parents with empty `root`
                if (!root) {
                    return;
                }
                this.root = root;
                //
                // assign same parent on child structures
                //
                if (this.ref instanceof Schema) {
                    var definition = this.ref['_definition'];
                    for (var field in definition.schema) {
                        var value = this.ref[field];
                        if (value && value['$changes']) {
                            var parentIndex_1 = definition.indexes[field];
                            value['$changes'].setParent(this.ref, root, parentIndex_1);
                        }
                    }
                }
                else if (typeof (this.ref) === "object") {
                    this.ref.forEach(function (value, key) {
                        if (value instanceof Schema) {
                            var changeTreee = value['$changes'];
                            var parentIndex_2 = _this.ref['$changes'].indexes[key];
                            changeTreee.setParent(_this.ref, _this.root, parentIndex_2);
                        }
                    });
                }
            };
            ChangeTree.prototype.operation = function (op) {
                this.changes.set(--this.currentCustomOperation, op);
            };
            ChangeTree.prototype.change = function (fieldName, operation) {
                if (operation === void 0) { operation = exports.OPERATION.ADD; }
                var index = (typeof (fieldName) === "number")
                    ? fieldName
                    : this.indexes[fieldName];
                this.assertValidIndex(index, fieldName);
                var previousChange = this.changes.get(index);
                if (!previousChange ||
                    previousChange.op === exports.OPERATION.DELETE ||
                    previousChange.op === exports.OPERATION.TOUCH // (mazmorra.io's BattleAction issue)
                ) {
                    this.changes.set(index, {
                        op: (!previousChange)
                            ? operation
                            : (previousChange.op === exports.OPERATION.DELETE)
                                ? exports.OPERATION.DELETE_AND_ADD
                                : operation,
                        // : OPERATION.REPLACE,
                        index: index
                    });
                }
                this.allChanges.add(index);
                this.changed = true;
                this.touchParents();
            };
            ChangeTree.prototype.touch = function (fieldName) {
                var index = (typeof (fieldName) === "number")
                    ? fieldName
                    : this.indexes[fieldName];
                this.assertValidIndex(index, fieldName);
                if (!this.changes.has(index)) {
                    this.changes.set(index, { op: exports.OPERATION.TOUCH, index: index });
                }
                this.allChanges.add(index);
                // ensure touch is placed until the $root is found.
                this.touchParents();
            };
            ChangeTree.prototype.touchParents = function () {
                if (this.parent) {
                    this.parent['$changes'].touch(this.parentIndex);
                }
            };
            ChangeTree.prototype.getType = function (index) {
                if (this.ref['_definition']) {
                    var definition = this.ref['_definition'];
                    return definition.schema[definition.fieldsByIndex[index]];
                }
                else {
                    var definition = this.parent['_definition'];
                    var parentType = definition.schema[definition.fieldsByIndex[this.parentIndex]];
                    //
                    // Get the child type from parent structure.
                    // - ["string"] => "string"
                    // - { map: "string" } => "string"
                    // - { set: "string" } => "string"
                    //
                    return Object.values(parentType)[0];
                }
            };
            ChangeTree.prototype.getChildrenFilter = function () {
                var childFilters = this.parent['_definition'].childFilters;
                return childFilters && childFilters[this.parentIndex];
            };
            //
            // used during `.encode()`
            //
            ChangeTree.prototype.getValue = function (index) {
                return this.ref['getByIndex'](index);
            };
            ChangeTree.prototype.delete = function (fieldName) {
                var index = (typeof (fieldName) === "number")
                    ? fieldName
                    : this.indexes[fieldName];
                if (index === undefined) {
                    console.warn("@colyseus/schema " + this.ref.constructor.name + ": trying to delete non-existing index: " + fieldName + " (" + index + ")");
                    return;
                }
                var previousValue = this.getValue(index);
                // console.log("$changes.delete =>", { fieldName, index, previousValue });
                this.changes.set(index, { op: exports.OPERATION.DELETE, index: index });
                this.allChanges.delete(index);
                // delete cache
                delete this.caches[index];
                // remove `root` reference
                if (previousValue && previousValue['$changes']) {
                    previousValue['$changes'].parent = undefined;
                }
                this.changed = true;
                this.touchParents();
            };
            ChangeTree.prototype.discard = function (changed, discardAll) {
                var _this = this;
                if (changed === void 0) { changed = false; }
                if (discardAll === void 0) { discardAll = false; }
                //
                // Map, Array, etc:
                // Remove cached key to ensure ADD operations is unsed instead of
                // REPLACE in case same key is used on next patches.
                //
                // TODO: refactor this. this is not relevant for Collection and Set.
                //
                if (!(this.ref instanceof Schema)) {
                    this.changes.forEach(function (change) {
                        if (change.op === exports.OPERATION.DELETE) {
                            var index = _this.ref['getIndex'](change.index);
                            delete _this.indexes[index];
                        }
                    });
                }
                this.changes.clear();
                this.changed = changed;
                if (discardAll) {
                    this.allChanges.clear();
                }
                // re-set `currentCustomOperation`
                this.currentCustomOperation = 0;
            };
            /**
             * Recursively discard all changes from this, and child structures.
             */
            ChangeTree.prototype.discardAll = function () {
                var _this = this;
                this.changes.forEach(function (change) {
                    var value = _this.getValue(change.index);
                    if (value && value['$changes']) {
                        value['$changes'].discardAll();
                    }
                });
                this.discard();
            };
            // cache(field: number, beginIndex: number, endIndex: number) {
            ChangeTree.prototype.cache = function (field, cachedBytes) {
                this.caches[field] = cachedBytes;
            };
            ChangeTree.prototype.clone = function () {
                return new ChangeTree(this.ref, this.parent, this.root);
            };
            ChangeTree.prototype.ensureRefId = function () {
                // skip if refId is already set.
                if (this.refId !== undefined) {
                    return;
                }
                this.refId = this.root.getNextUniqueId();
            };
            ChangeTree.prototype.assertValidIndex = function (index, fieldName) {
                if (index === undefined) {
                    throw new Error("ChangeTree: missing index for field \"" + fieldName + "\"");
                }
            };
            return ChangeTree;
        }());

        //
        // Notes:
        // -----
        //
        // - The tsconfig.json of @colyseus/schema uses ES2018.
        // - ES2019 introduces `flatMap` / `flat`, which is not currently relevant, and caused other issues.
        //
        var DEFAULT_SORT = function (a, b) {
            var A = a.toString();
            var B = b.toString();
            if (A < B)
                return -1;
            else if (A > B)
                return 1;
            else
                return 0;
        };
        function getArrayProxy(value) {
            value['$proxy'] = true;
            //
            // compatibility with @colyseus/schema 0.5.x
            // - allow `map["key"]`
            // - allow `map["key"] = "xxx"`
            // - allow `delete map["key"]`
            //
            value = new Proxy(value, {
                get: function (obj, prop) {
                    if (typeof (prop) !== "symbol" &&
                        !isNaN(prop) // https://stackoverflow.com/a/175787/892698
                    ) {
                        return obj.at(prop);
                    }
                    else {
                        return obj[prop];
                    }
                },
                set: function (obj, prop, setValue) {
                    if (typeof (prop) !== "symbol" &&
                        !isNaN(prop)) {
                        var indexes = Array.from(obj['$items'].keys());
                        var key = parseInt(indexes[prop] || prop);
                        if (setValue === undefined || setValue === null) {
                            obj.deleteAt(key);
                        }
                        else {
                            obj.setAt(key, setValue);
                        }
                    }
                    else {
                        obj[prop] = setValue;
                    }
                    return true;
                },
                deleteProperty: function (obj, prop) {
                    if (typeof (prop) === "number") {
                        obj.deleteAt(prop);
                    }
                    else {
                        delete obj[prop];
                    }
                    return true;
                },
            });
            return value;
        }
        var ArraySchema = /** @class */ (function () {
            function ArraySchema() {
                var items = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    items[_i] = arguments[_i];
                }
                this.$changes = new ChangeTree(this);
                this.$items = new Map();
                this.$indexes = new Map();
                this.$refId = 0;
                this.push.apply(this, items);
            }
            ArraySchema.is = function (type) {
                return (
                // type format: ["string"]
                Array.isArray(type) ||
                    // type format: { array: "string" }
                    (type['array'] !== undefined));
            };
            Object.defineProperty(ArraySchema.prototype, "length", {
                get: function () {
                    return this.$items.size;
                },
                set: function (value) {
                    if (value === 0) {
                        this.clear();
                    }
                    else {
                        this.splice(value, this.length - value);
                    }
                },
                enumerable: false,
                configurable: true
            });
            ArraySchema.prototype.push = function () {
                var _this = this;
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
                var lastIndex;
                values.forEach(function (value) {
                    // set "index" for reference.
                    lastIndex = _this.$refId++;
                    _this.setAt(lastIndex, value);
                });
                return lastIndex;
            };
            /**
             * Removes the last element from an array and returns it.
             */
            ArraySchema.prototype.pop = function () {
                var key = Array.from(this.$indexes.values()).pop();
                if (key === undefined) {
                    return undefined;
                }
                this.$changes.delete(key);
                this.$indexes.delete(key);
                var value = this.$items.get(key);
                this.$items.delete(key);
                return value;
            };
            ArraySchema.prototype.at = function (index) {
                //
                // FIXME: this should be O(1)
                //
                var key = Array.from(this.$items.keys())[index];
                return this.$items.get(key);
            };
            ArraySchema.prototype.setAt = function (index, value) {
                var _a, _b;
                if (value['$changes'] !== undefined) {
                    value['$changes'].setParent(this, this.$changes.root, index);
                }
                var operation = (_b = (_a = this.$changes.indexes[index]) === null || _a === void 0 ? void 0 : _a.op) !== null && _b !== void 0 ? _b : exports.OPERATION.ADD;
                this.$changes.indexes[index] = index;
                this.$indexes.set(index, index);
                this.$items.set(index, value);
                this.$changes.change(index, operation);
            };
            ArraySchema.prototype.deleteAt = function (index) {
                var key = Array.from(this.$items.keys())[index];
                if (key === undefined) {
                    return false;
                }
                return this.$deleteAt(key);
            };
            ArraySchema.prototype.$deleteAt = function (index) {
                // delete at internal index
                this.$changes.delete(index);
                this.$indexes.delete(index);
                return this.$items.delete(index);
            };
            ArraySchema.prototype.clear = function (isDecoding) {
                var _this = this;
                // discard previous operations.
                this.$changes.discard(true, true);
                this.$changes.indexes = {};
                // clear previous indexes
                this.$indexes.clear();
                // flag child items for garbage collection.
                if (isDecoding && typeof (this.$changes.getType()) !== "string") {
                    this.$items.forEach(function (item) {
                        _this.$changes.root.removeRef(item['$changes'].refId);
                    });
                }
                // clear items
                this.$items.clear();
                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });
                // touch all structures until reach root
                this.$changes.touchParents();
            };
            /**
             * Combines two or more arrays.
             * @param items Additional items to add to the end of array1.
             */
            ArraySchema.prototype.concat = function () {
                var _a;
                var items = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    items[_i] = arguments[_i];
                }
                return new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], (_a = Array.from(this.$items.values())).concat.apply(_a, items))))();
            };
            /**
             * Adds all the elements of an array separated by the specified separator string.
             * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
             */
            ArraySchema.prototype.join = function (separator) {
                return Array.from(this.$items.values()).join(separator);
            };
            /**
             * Reverses the elements in an Array.
             */
            ArraySchema.prototype.reverse = function () {
                var _this = this;
                var indexes = Array.from(this.$items.keys());
                var reversedItems = Array.from(this.$items.values()).reverse();
                reversedItems.forEach(function (item, i) {
                    _this.setAt(indexes[i], item);
                });
                return this;
            };
            /**
             * Removes the first element from an array and returns it.
             */
            ArraySchema.prototype.shift = function () {
                var indexes = Array.from(this.$items.keys());
                var shiftAt = indexes.shift();
                if (shiftAt === undefined) {
                    return undefined;
                }
                var value = this.$items.get(shiftAt);
                this.$deleteAt(shiftAt);
                return value;
            };
            /**
             * Returns a section of an array.
             * @param start The beginning of the specified portion of the array.
             * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
             */
            ArraySchema.prototype.slice = function (start, end) {
                return new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], Array.from(this.$items.values()).slice(start, end))))();
            };
            /**
             * Sorts an array.
             * @param compareFn Function used to determine the order of the elements. It is expected to return
             * a negative value if first argument is less than second argument, zero if they're equal and a positive
             * value otherwise. If omitted, the elements are sorted in ascending, ASCII character order.
             * ```ts
             * [11,2,22,1].sort((a, b) => a - b)
             * ```
             */
            ArraySchema.prototype.sort = function (compareFn) {
                var _this = this;
                if (compareFn === void 0) { compareFn = DEFAULT_SORT; }
                var indexes = Array.from(this.$items.keys());
                var sortedItems = Array.from(this.$items.values()).sort(compareFn);
                sortedItems.forEach(function (item, i) {
                    _this.setAt(indexes[i], item);
                });
                return this;
            };
            /**
             * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.
             * @param start The zero-based location in the array from which to start removing elements.
             * @param deleteCount The number of elements to remove.
             * @param items Elements to insert into the array in place of the deleted elements.
             */
            ArraySchema.prototype.splice = function (start, deleteCount) {
                if (deleteCount === void 0) { deleteCount = this.length - start; }
                var items = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    items[_i - 2] = arguments[_i];
                }
                var indexes = Array.from(this.$items.keys());
                var removedItems = [];
                for (var i = start; i < start + deleteCount; i++) {
                    removedItems.push(this.$items.get(indexes[i]));
                    this.$deleteAt(indexes[i]);
                }
                return removedItems;
            };
            /**
             * Inserts new elements at the start of an array.
             * @param items  Elements to insert at the start of the Array.
             */
            ArraySchema.prototype.unshift = function () {
                var _this = this;
                var items = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    items[_i] = arguments[_i];
                }
                var length = this.length;
                var addedLength = items.length;
                // const indexes = Array.from(this.$items.keys());
                var previousValues = Array.from(this.$items.values());
                items.forEach(function (item, i) {
                    _this.setAt(i, item);
                });
                previousValues.forEach(function (previousValue, i) {
                    _this.setAt(addedLength + i, previousValue);
                });
                return length + addedLength;
            };
            /**
             * Returns the index of the first occurrence of a value in an array.
             * @param searchElement The value to locate in the array.
             * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
             */
            ArraySchema.prototype.indexOf = function (searchElement, fromIndex) {
                return Array.from(this.$items.values()).indexOf(searchElement, fromIndex);
            };
            /**
             * Returns the index of the last occurrence of a specified value in an array.
             * @param searchElement The value to locate in the array.
             * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
             */
            ArraySchema.prototype.lastIndexOf = function (searchElement, fromIndex) {
                if (fromIndex === void 0) { fromIndex = this.length - 1; }
                return Array.from(this.$items.values()).lastIndexOf(searchElement, fromIndex);
            };
            /**
             * Determines whether all the members of an array satisfy the specified test.
             * @param callbackfn A function that accepts up to three arguments. The every method calls
             * the callbackfn function for each element in the array until the callbackfn returns a value
             * which is coercible to the Boolean value false, or until the end of the array.
             * @param thisArg An object to which the this keyword can refer in the callbackfn function.
             * If thisArg is omitted, undefined is used as the this value.
             */
            ArraySchema.prototype.every = function (callbackfn, thisArg) {
                return Array.from(this.$items.values()).every(callbackfn, thisArg);
            };
            /**
             * Determines whether the specified callback function returns true for any element of an array.
             * @param callbackfn A function that accepts up to three arguments. The some method calls
             * the callbackfn function for each element in the array until the callbackfn returns a value
             * which is coercible to the Boolean value true, or until the end of the array.
             * @param thisArg An object to which the this keyword can refer in the callbackfn function.
             * If thisArg is omitted, undefined is used as the this value.
             */
            ArraySchema.prototype.some = function (callbackfn, thisArg) {
                return Array.from(this.$items.values()).some(callbackfn, thisArg);
            };
            /**
             * Performs the specified action for each element in an array.
             * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
             * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
             */
            ArraySchema.prototype.forEach = function (callbackfn, thisArg) {
                Array.from(this.$items.values()).forEach(callbackfn, thisArg);
            };
            /**
             * Calls a defined callback function on each element of an array, and returns an array that contains the results.
             * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
             * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
             */
            ArraySchema.prototype.map = function (callbackfn, thisArg) {
                return Array.from(this.$items.values()).map(callbackfn, thisArg);
            };
            ArraySchema.prototype.filter = function (callbackfn, thisArg) {
                return Array.from(this.$items.values()).filter(callbackfn, thisArg);
            };
            /**
             * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
             * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
             * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
             */
            ArraySchema.prototype.reduce = function (callbackfn, initialValue) {
                return Array.from(this.$items.values()).reduce(callbackfn, initialValue);
            };
            /**
             * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
             * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
             * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
             */
            ArraySchema.prototype.reduceRight = function (callbackfn, initialValue) {
                return Array.from(this.$items.values()).reduceRight(callbackfn, initialValue);
            };
            /**
             * Returns the value of the first element in the array where predicate is true, and undefined
             * otherwise.
             * @param predicate find calls predicate once for each element of the array, in ascending
             * order, until it finds one where predicate returns true. If such an element is found, find
             * immediately returns that element value. Otherwise, find returns undefined.
             * @param thisArg If provided, it will be used as the this value for each invocation of
             * predicate. If it is not provided, undefined is used instead.
             */
            ArraySchema.prototype.find = function (predicate, thisArg) {
                return Array.from(this.$items.values()).find(predicate, thisArg);
            };
            /**
             * Returns the index of the first element in the array where predicate is true, and -1
             * otherwise.
             * @param predicate find calls predicate once for each element of the array, in ascending
             * order, until it finds one where predicate returns true. If such an element is found,
             * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
             * @param thisArg If provided, it will be used as the this value for each invocation of
             * predicate. If it is not provided, undefined is used instead.
             */
            ArraySchema.prototype.findIndex = function (predicate, thisArg) {
                return Array.from(this.$items.values()).findIndex(predicate, thisArg);
            };
            /**
             * Returns the this object after filling the section identified by start and end with value
             * @param value value to fill array section with
             * @param start index to start filling the array at. If start is negative, it is treated as
             * length+start where length is the length of the array.
             * @param end index to stop filling the array at. If end is negative, it is treated as
             * length+end.
             */
            ArraySchema.prototype.fill = function (value, start, end) {
                //
                // TODO
                //
                throw new Error("ArraySchema#fill() not implemented");
            };
            /**
             * Returns the this object after copying a section of the array identified by start and end
             * to the same array starting at position target
             * @param target If target is negative, it is treated as length+target where length is the
             * length of the array.
             * @param start If start is negative, it is treated as length+start. If end is negative, it
             * is treated as length+end.
             * @param end If not specified, length of the this object is used as its default value.
             */
            ArraySchema.prototype.copyWithin = function (target, start, end) {
                //
                // TODO
                //
                throw new Error("ArraySchema#copyWithin() not implemented");
            };
            /**
             * Returns a string representation of an array.
             */
            ArraySchema.prototype.toString = function () { return this.$items.toString(); };
            /**
             * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
             */
            ArraySchema.prototype.toLocaleString = function () { return this.$items.toLocaleString(); };
            /** Iterator */
            ArraySchema.prototype[Symbol.iterator] = function () {
                return Array.from(this.$items.values())[Symbol.iterator]();
            };
            ArraySchema.prototype[Symbol.unscopables] = function () {
                return this.$items[Symbol.unscopables]();
            };
            /**
             * Returns an iterable of key, value pairs for every entry in the array
             */
            ArraySchema.prototype.entries = function () { return this.$items.entries(); };
            /**
             * Returns an iterable of keys in the array
             */
            ArraySchema.prototype.keys = function () { return this.$items.keys(); };
            /**
             * Returns an iterable of values in the array
             */
            ArraySchema.prototype.values = function () { return this.$items.values(); };
            /**
             * Determines whether an array includes a certain element, returning true or false as appropriate.
             * @param searchElement The element to search for.
             * @param fromIndex The position in this array at which to begin searching for searchElement.
             */
            ArraySchema.prototype.includes = function (searchElement, fromIndex) {
                return Array.from(this.$items.values()).includes(searchElement, fromIndex);
            };
            /**
             * Calls a defined callback function on each element of an array. Then, flattens the result into
             * a new array.
             * This is identical to a map followed by flat with depth 1.
             *
             * @param callback A function that accepts up to three arguments. The flatMap method calls the
             * callback function one time for each element in the array.
             * @param thisArg An object to which the this keyword can refer in the callback function. If
             * thisArg is omitted, undefined is used as the this value.
             */
            // @ts-ignore
            ArraySchema.prototype.flatMap = function (callback, thisArg) {
                // @ts-ignore
                throw new Error("ArraySchema#flatMap() is not supported.");
            };
            /**
             * Returns a new array with all sub-array elements concatenated into it recursively up to the
             * specified depth.
             *
             * @param depth The maximum recursion depth
             */
            // @ts-ignore
            ArraySchema.prototype.flat = function (depth) {
                // @ts-ignore
                throw new Error("ArraySchema#flat() is not supported.");
            };
            // get size () {
            //     return this.$items.size;
            // }
            ArraySchema.prototype.setIndex = function (index, key) {
                this.$indexes.set(index, key);
            };
            ArraySchema.prototype.getIndex = function (index) {
                return this.$indexes.get(index);
            };
            ArraySchema.prototype.getByIndex = function (index) {
                return this.$items.get(this.$indexes.get(index));
            };
            ArraySchema.prototype.deleteByIndex = function (index) {
                var key = this.$indexes.get(index);
                this.$items.delete(key);
                this.$indexes.delete(index);
            };
            ArraySchema.prototype.toArray = function () {
                return Array.from(this.$items.values());
            };
            ArraySchema.prototype.toJSON = function () {
                return this.toArray().map(function (value) {
                    return (typeof (value['toJSON']) === "function")
                        ? value['toJSON']()
                        : value;
                });
            };
            //
            // Decoding utilities
            //
            ArraySchema.prototype.clone = function (isDecoding) {
                var cloned;
                if (isDecoding) {
                    cloned = new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], Array.from(this.$items.values()))))();
                }
                else {
                    cloned = new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], this.map(function (item) { return ((item['$changes'])
                        ? item.clone()
                        : item); }))))();
                }
                return cloned;
            };
            ArraySchema.prototype.triggerAll = function () {
                Schema.prototype.triggerAll.apply(this);
            };
            return ArraySchema;
        }());

        function getMapProxy(value) {
            value['$proxy'] = true;
            value = new Proxy(value, {
                get: function (obj, prop) {
                    if (typeof (prop) !== "symbol" && // accessing properties
                        typeof (obj[prop]) === "undefined") {
                        return obj.get(prop);
                    }
                    else {
                        return obj[prop];
                    }
                },
                set: function (obj, prop, setValue) {
                    if (typeof (prop) !== "symbol" &&
                        (prop.indexOf("$") === -1 &&
                            prop !== "onAdd" &&
                            prop !== "onRemove" &&
                            prop !== "onChange")) {
                        obj.set(prop, setValue);
                    }
                    else {
                        obj[prop] = setValue;
                    }
                    return true;
                },
                deleteProperty: function (obj, prop) {
                    obj.delete(prop);
                    return true;
                },
            });
            return value;
        }
        var MapSchema = /** @class */ (function () {
            function MapSchema(initialValues) {
                var _this = this;
                this.$changes = new ChangeTree(this);
                this.$items = new Map();
                this.$indexes = new Map();
                this.$refId = 0;
                if (initialValues) {
                    if (initialValues instanceof Map) {
                        initialValues.forEach(function (v, k) { return _this.set(k, v); });
                    }
                    else {
                        for (var k in initialValues) {
                            this.set(k, initialValues[k]);
                        }
                    }
                }
            }
            MapSchema.is = function (type) {
                return type['map'] !== undefined;
            };
            /** Iterator */
            MapSchema.prototype[Symbol.iterator] = function () { return this.$items[Symbol.iterator](); };
            Object.defineProperty(MapSchema.prototype, Symbol.toStringTag, {
                get: function () { return this.$items[Symbol.toStringTag]; },
                enumerable: false,
                configurable: true
            });
            MapSchema.prototype.set = function (key, value) {
                if (value === undefined || value === null) {
                    throw new Error("MapSchema#set('" + key + "', " + value + "): trying to set " + value + " value on '" + key + "'.");
                }
                // get "index" for this value.
                var hasIndex = typeof (this.$changes.indexes[key]) !== "undefined";
                var index = (hasIndex)
                    ? this.$changes.indexes[key]
                    : this.$refId++;
                var operation = (hasIndex)
                    ? exports.OPERATION.REPLACE
                    : exports.OPERATION.ADD;
                var isRef = (value['$changes']) !== undefined;
                if (isRef) {
                    value['$changes'].setParent(this, this.$changes.root, index);
                }
                //
                // (encoding)
                // set a unique id to relate directly with this key/value.
                //
                if (!hasIndex) {
                    this.$changes.indexes[key] = index;
                    this.$indexes.set(index, key);
                }
                else if (isRef && // if is schema, force ADD operation if value differ from previous one.
                    this.$items.get(key) !== value) {
                    operation = exports.OPERATION.ADD;
                }
                this.$items.set(key, value);
                this.$changes.change(key, operation);
                return this;
            };
            MapSchema.prototype.get = function (key) {
                return this.$items.get(key);
            };
            MapSchema.prototype.delete = function (key) {
                //
                // TODO: add a "purge" method after .encode() runs, to cleanup removed `$indexes`
                //
                // We don't remove $indexes to allow setting the same key in the same patch
                // (See "should allow to remove and set an item in the same place" test)
                //
                // // const index = this.$changes.indexes[key];
                // // this.$indexes.delete(index);
                this.$changes.delete(key);
                return this.$items.delete(key);
            };
            MapSchema.prototype.clear = function (isDecoding) {
                var _this = this;
                // discard previous operations.
                this.$changes.discard(true, true);
                this.$changes.indexes = {};
                // clear previous indexes
                this.$indexes.clear();
                // flag child items for garbage collection.
                if (isDecoding && typeof (this.$changes.getType()) !== "string") {
                    this.$items.forEach(function (item) {
                        _this.$changes.root.removeRef(item['$changes'].refId);
                    });
                }
                // clear items
                this.$items.clear();
                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });
                // touch all structures until reach root
                this.$changes.touchParents();
            };
            MapSchema.prototype.has = function (key) {
                return this.$items.has(key);
            };
            MapSchema.prototype.forEach = function (callbackfn) {
                this.$items.forEach(callbackfn);
            };
            MapSchema.prototype.entries = function () {
                return this.$items.entries();
            };
            MapSchema.prototype.keys = function () {
                return this.$items.keys();
            };
            MapSchema.prototype.values = function () {
                return this.$items.values();
            };
            Object.defineProperty(MapSchema.prototype, "size", {
                get: function () {
                    return this.$items.size;
                },
                enumerable: false,
                configurable: true
            });
            MapSchema.prototype.setIndex = function (index, key) {
                this.$indexes.set(index, key);
            };
            MapSchema.prototype.getIndex = function (index) {
                return this.$indexes.get(index);
            };
            MapSchema.prototype.getByIndex = function (index) {
                return this.$items.get(this.$indexes.get(index));
            };
            MapSchema.prototype.deleteByIndex = function (index) {
                var key = this.$indexes.get(index);
                this.$items.delete(key);
                this.$indexes.delete(index);
            };
            MapSchema.prototype.toJSON = function () {
                var map = {};
                this.forEach(function (value, key) {
                    map[key] = (typeof (value['toJSON']) === "function")
                        ? value['toJSON']()
                        : value;
                });
                return map;
            };
            //
            // Decoding utilities
            //
            MapSchema.prototype.clone = function (isDecoding) {
                var cloned;
                if (isDecoding) {
                    // client-side
                    cloned = Object.assign(new MapSchema(), this);
                }
                else {
                    // server-side
                    cloned = new MapSchema();
                    this.forEach(function (value, key) {
                        if (value['$changes']) {
                            cloned.set(key, value['clone']());
                        }
                        else {
                            cloned.set(key, value);
                        }
                    });
                }
                return cloned;
            };
            MapSchema.prototype.triggerAll = function () {
                Schema.prototype.triggerAll.apply(this);
            };
            return MapSchema;
        }());

        var registeredTypes = {};
        function registerType(identifier, definition) {
            registeredTypes[identifier] = definition;
        }
        function getType(identifier) {
            return registeredTypes[identifier];
        }

        var SchemaDefinition = /** @class */ (function () {
            function SchemaDefinition() {
                //
                // TODO: use a "field" structure combining all these properties per-field.
                //
                this.indexes = {};
                this.fieldsByIndex = {};
                this.deprecated = {};
                this.descriptors = {};
            }
            SchemaDefinition.create = function (parent) {
                var definition = new SchemaDefinition();
                // support inheritance
                definition.schema = Object.assign({}, parent && parent.schema || {});
                definition.indexes = Object.assign({}, parent && parent.indexes || {});
                definition.fieldsByIndex = Object.assign({}, parent && parent.fieldsByIndex || {});
                definition.descriptors = Object.assign({}, parent && parent.descriptors || {});
                definition.deprecated = Object.assign({}, parent && parent.deprecated || {});
                return definition;
            };
            SchemaDefinition.prototype.addField = function (field, type) {
                var index = this.getNextFieldIndex();
                this.fieldsByIndex[index] = field;
                this.indexes[field] = index;
                this.schema[field] = (Array.isArray(type))
                    ? { array: type[0] }
                    : type;
            };
            SchemaDefinition.prototype.addFilter = function (field, cb) {
                if (!this.filters) {
                    this.filters = {};
                    this.indexesWithFilters = [];
                }
                this.filters[this.indexes[field]] = cb;
                this.indexesWithFilters.push(this.indexes[field]);
                return true;
            };
            SchemaDefinition.prototype.addChildrenFilter = function (field, cb) {
                var index = this.indexes[field];
                var type = this.schema[field];
                if (getType(Object.keys(type)[0])) {
                    if (!this.childFilters) {
                        this.childFilters = {};
                    }
                    this.childFilters[index] = cb;
                    return true;
                }
                else {
                    console.warn("@filterChildren: field '" + field + "' can't have children. Ignoring filter.");
                }
            };
            SchemaDefinition.prototype.getChildrenFilter = function (field) {
                return this.childFilters && this.childFilters[this.indexes[field]];
            };
            SchemaDefinition.prototype.getNextFieldIndex = function () {
                return Object.keys(this.schema || {}).length;
            };
            return SchemaDefinition;
        }());
        function hasFilter(klass) {
            return klass._context && klass._context.useFilters;
        }
        var Context = /** @class */ (function () {
            function Context() {
                this.types = {};
                this.schemas = new Map();
                this.useFilters = false;
            }
            Context.prototype.has = function (schema) {
                return this.schemas.has(schema);
            };
            Context.prototype.get = function (typeid) {
                return this.types[typeid];
            };
            Context.prototype.add = function (schema, typeid) {
                if (typeid === void 0) { typeid = this.schemas.size; }
                // FIXME: move this to somewhere else?
                // support inheritance
                schema._definition = SchemaDefinition.create(schema._definition);
                schema._typeid = typeid;
                this.types[typeid] = schema;
                this.schemas.set(schema, typeid);
            };
            Context.create = function (context) {
                if (context === void 0) { context = new Context; }
                return function (definition) {
                    return type(definition, context);
                };
            };
            return Context;
        }());
        var globalContext = new Context();
        /**
         * `@type()` decorator for proxies
         */
        function type(type, context) {
            if (context === void 0) { context = globalContext; }
            return function (target, field) {
                var constructor = target.constructor;
                constructor._context = context;
                /*
                 * static schema
                 */
                if (!context.has(constructor)) {
                    context.add(constructor);
                }
                var definition = constructor._definition;
                definition.addField(field, type);
                /**
                 * skip if descriptor already exists for this field (`@deprecated()`)
                 */
                if (definition.descriptors[field]) {
                    if (definition.deprecated[field]) {
                        // do not create accessors for deprecated properties.
                        return;
                    }
                    else {
                        // trying to define same property multiple times across inheritance.
                        // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572
                        try {
                            throw new Error("@colyseus/schema: Duplicate '" + field + "' definition on '" + constructor.name + "'.\nCheck @type() annotation");
                        }
                        catch (e) {
                            var definitionAtLine = e.stack.split("\n")[4].trim();
                            throw new Error(e.message + " " + definitionAtLine);
                        }
                    }
                }
                var isArray = ArraySchema.is(type);
                var isMap = !isArray && MapSchema.is(type);
                // TODO: refactor me.
                // Allow abstract intermediary classes with no fields to be serialized
                // (See "should support an inheritance with a Schema type without fields" test)
                if (typeof (type) !== "string" && !Schema.is(type)) {
                    var childType = Object.values(type)[0];
                    if (typeof (childType) !== "string" && !context.has(childType)) {
                        context.add(childType);
                    }
                }
                var fieldCached = "_" + field;
                definition.descriptors[fieldCached] = {
                    enumerable: false,
                    configurable: false,
                    writable: true,
                };
                definition.descriptors[field] = {
                    get: function () {
                        return this[fieldCached];
                    },
                    set: function (value) {
                        /**
                         * Create Proxy for array or map items
                         */
                        // skip if value is the same as cached.
                        if (value === this[fieldCached]) {
                            return;
                        }
                        if (value !== undefined &&
                            value !== null) {
                            // automaticallty transform Array into ArraySchema
                            if (isArray && !(value instanceof ArraySchema)) {
                                value = new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], value)))();
                            }
                            // automaticallty transform Map into MapSchema
                            if (isMap && !(value instanceof MapSchema)) {
                                value = new MapSchema(value);
                            }
                            // try to turn provided structure into a Proxy
                            if (value['$proxy'] === undefined) {
                                if (isMap) {
                                    value = getMapProxy(value);
                                }
                                else if (isArray) {
                                    value = getArrayProxy(value);
                                }
                            }
                            // flag the change for encoding.
                            this.$changes.change(field);
                            //
                            // call setParent() recursively for this and its child
                            // structures.
                            //
                            if (value['$changes']) {
                                value['$changes'].setParent(this, this.$changes.root, this._definition.indexes[field]);
                            }
                        }
                        else {
                            //
                            // Setting a field to `null` or `undefined` will delete it.
                            //
                            this.$changes.delete(field);
                        }
                        this[fieldCached] = value;
                    },
                    enumerable: true,
                    configurable: true
                };
            };
        }
        /**
         * `@filter()` decorator for defining data filters per client
         */
        function filter(cb) {
            return function (target, field) {
                var constructor = target.constructor;
                var definition = constructor._definition;
                if (definition.addFilter(field, cb)) {
                    constructor._context.useFilters = true;
                }
            };
        }
        function filterChildren(cb) {
            return function (target, field) {
                var constructor = target.constructor;
                var definition = constructor._definition;
                if (definition.addChildrenFilter(field, cb)) {
                    constructor._context.useFilters = true;
                }
            };
        }
        /**
         * `@deprecated()` flag a field as deprecated.
         * The previous `@type()` annotation should remain along with this one.
         */
        function deprecated(throws, context) {
            if (throws === void 0) { throws = true; }
            return function (target, field) {
                var constructor = target.constructor;
                var definition = constructor._definition;
                definition.deprecated[field] = true;
                if (throws) {
                    definition.descriptors[field] = {
                        get: function () { throw new Error(field + " is deprecated."); },
                        set: function (value) { },
                        enumerable: false,
                        configurable: true
                    };
                }
            };
        }
        function defineTypes(target, fields, context) {
            if (context === void 0) { context = target._context || globalContext; }
            for (var field in fields) {
                type(fields[field], context)(target.prototype, field);
            }
            return target;
        }

        /**
         * Copyright (c) 2018 Endel Dreyer
         * Copyright (c) 2014 Ion Drive Software Ltd.
         *
         * Permission is hereby granted, free of charge, to any person obtaining a copy
         * of this software and associated documentation files (the "Software"), to deal
         * in the Software without restriction, including without limitation the rights
         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
         * copies of the Software, and to permit persons to whom the Software is
         * furnished to do so, subject to the following conditions:
         *
         * The above copyright notice and this permission notice shall be included in all
         * copies or substantial portions of the Software.
         *
         * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
         * SOFTWARE
         */
        /**
         * msgpack implementation highly based on notepack.io
         * https://github.com/darrachequesne/notepack
         */
        function utf8Length(str) {
            var c = 0, length = 0;
            for (var i = 0, l = str.length; i < l; i++) {
                c = str.charCodeAt(i);
                if (c < 0x80) {
                    length += 1;
                }
                else if (c < 0x800) {
                    length += 2;
                }
                else if (c < 0xd800 || c >= 0xe000) {
                    length += 3;
                }
                else {
                    i++;
                    length += 4;
                }
            }
            return length;
        }
        function utf8Write(view, offset, str) {
            var c = 0;
            for (var i = 0, l = str.length; i < l; i++) {
                c = str.charCodeAt(i);
                if (c < 0x80) {
                    view[offset++] = c;
                }
                else if (c < 0x800) {
                    view[offset++] = 0xc0 | (c >> 6);
                    view[offset++] = 0x80 | (c & 0x3f);
                }
                else if (c < 0xd800 || c >= 0xe000) {
                    view[offset++] = 0xe0 | (c >> 12);
                    view[offset++] = 0x80 | (c >> 6 & 0x3f);
                    view[offset++] = 0x80 | (c & 0x3f);
                }
                else {
                    i++;
                    c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                    view[offset++] = 0xf0 | (c >> 18);
                    view[offset++] = 0x80 | (c >> 12 & 0x3f);
                    view[offset++] = 0x80 | (c >> 6 & 0x3f);
                    view[offset++] = 0x80 | (c & 0x3f);
                }
            }
        }
        function int8$1(bytes, value) {
            bytes.push(value & 255);
        }
        function uint8$1(bytes, value) {
            bytes.push(value & 255);
        }
        function int16$1(bytes, value) {
            bytes.push(value & 255);
            bytes.push((value >> 8) & 255);
        }
        function uint16$1(bytes, value) {
            bytes.push(value & 255);
            bytes.push((value >> 8) & 255);
        }
        function int32$1(bytes, value) {
            bytes.push(value & 255);
            bytes.push((value >> 8) & 255);
            bytes.push((value >> 16) & 255);
            bytes.push((value >> 24) & 255);
        }
        function uint32$1(bytes, value) {
            var b4 = value >> 24;
            var b3 = value >> 16;
            var b2 = value >> 8;
            var b1 = value;
            bytes.push(b1 & 255);
            bytes.push(b2 & 255);
            bytes.push(b3 & 255);
            bytes.push(b4 & 255);
        }
        function int64$1(bytes, value) {
            var high = Math.floor(value / Math.pow(2, 32));
            var low = value >>> 0;
            uint32$1(bytes, low);
            uint32$1(bytes, high);
        }
        function uint64$1(bytes, value) {
            var high = (value / Math.pow(2, 32)) >> 0;
            var low = value >>> 0;
            uint32$1(bytes, low);
            uint32$1(bytes, high);
        }
        function float32$1(bytes, value) {
            writeFloat32(bytes, value);
        }
        function float64$1(bytes, value) {
            writeFloat64(bytes, value);
        }
        var _int32$1 = new Int32Array(2);
        var _float32$1 = new Float32Array(_int32$1.buffer);
        var _float64$1 = new Float64Array(_int32$1.buffer);
        function writeFloat32(bytes, value) {
            _float32$1[0] = value;
            int32$1(bytes, _int32$1[0]);
        }
        function writeFloat64(bytes, value) {
            _float64$1[0] = value;
            int32$1(bytes, _int32$1[0 ]);
            int32$1(bytes, _int32$1[1 ]);
        }
        function boolean$1(bytes, value) {
            return uint8$1(bytes, value ? 1 : 0);
        }
        function string$1(bytes, value) {
            // encode `null` strings as empty.
            if (!value) {
                value = "";
            }
            var length = utf8Length(value);
            var size = 0;
            // fixstr
            if (length < 0x20) {
                bytes.push(length | 0xa0);
                size = 1;
            }
            // str 8
            else if (length < 0x100) {
                bytes.push(0xd9);
                uint8$1(bytes, length);
                size = 2;
            }
            // str 16
            else if (length < 0x10000) {
                bytes.push(0xda);
                uint16$1(bytes, length);
                size = 3;
            }
            // str 32
            else if (length < 0x100000000) {
                bytes.push(0xdb);
                uint32$1(bytes, length);
                size = 5;
            }
            else {
                throw new Error('String too long');
            }
            utf8Write(bytes, bytes.length, value);
            return size + length;
        }
        function number$1(bytes, value) {
            if (isNaN(value)) {
                return number$1(bytes, 0);
            }
            else if (!isFinite(value)) {
                return number$1(bytes, (value > 0) ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER);
            }
            else if (value !== (value | 0)) {
                bytes.push(0xcb);
                writeFloat64(bytes, value);
                return 9;
                // TODO: encode float 32?
                // is it possible to differentiate between float32 / float64 here?
                // // float 32
                // bytes.push(0xca);
                // writeFloat32(bytes, value);
                // return 5;
            }
            if (value >= 0) {
                // positive fixnum
                if (value < 0x80) {
                    uint8$1(bytes, value);
                    return 1;
                }
                // uint 8
                if (value < 0x100) {
                    bytes.push(0xcc);
                    uint8$1(bytes, value);
                    return 2;
                }
                // uint 16
                if (value < 0x10000) {
                    bytes.push(0xcd);
                    uint16$1(bytes, value);
                    return 3;
                }
                // uint 32
                if (value < 0x100000000) {
                    bytes.push(0xce);
                    uint32$1(bytes, value);
                    return 5;
                }
                // uint 64
                bytes.push(0xcf);
                uint64$1(bytes, value);
                return 9;
            }
            else {
                // negative fixnum
                if (value >= -0x20) {
                    bytes.push(0xe0 | (value + 0x20));
                    return 1;
                }
                // int 8
                if (value >= -0x80) {
                    bytes.push(0xd0);
                    int8$1(bytes, value);
                    return 2;
                }
                // int 16
                if (value >= -0x8000) {
                    bytes.push(0xd1);
                    int16$1(bytes, value);
                    return 3;
                }
                // int 32
                if (value >= -0x80000000) {
                    bytes.push(0xd2);
                    int32$1(bytes, value);
                    return 5;
                }
                // int 64
                bytes.push(0xd3);
                int64$1(bytes, value);
                return 9;
            }
        }

        var encode = /*#__PURE__*/Object.freeze({
            __proto__: null,
            utf8Write: utf8Write,
            int8: int8$1,
            uint8: uint8$1,
            int16: int16$1,
            uint16: uint16$1,
            int32: int32$1,
            uint32: uint32$1,
            int64: int64$1,
            uint64: uint64$1,
            float32: float32$1,
            float64: float64$1,
            writeFloat32: writeFloat32,
            writeFloat64: writeFloat64,
            boolean: boolean$1,
            string: string$1,
            number: number$1
        });

        /**
         * Copyright (c) 2018 Endel Dreyer
         * Copyright (c) 2014 Ion Drive Software Ltd.
         *
         * Permission is hereby granted, free of charge, to any person obtaining a copy
         * of this software and associated documentation files (the "Software"), to deal
         * in the Software without restriction, including without limitation the rights
         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
         * copies of the Software, and to permit persons to whom the Software is
         * furnished to do so, subject to the following conditions:
         *
         * The above copyright notice and this permission notice shall be included in all
         * copies or substantial portions of the Software.
         *
         * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
         * SOFTWARE
         */
        function utf8Read(bytes, offset, length) {
            var string = '', chr = 0;
            for (var i = offset, end = offset + length; i < end; i++) {
                var byte = bytes[i];
                if ((byte & 0x80) === 0x00) {
                    string += String.fromCharCode(byte);
                    continue;
                }
                if ((byte & 0xe0) === 0xc0) {
                    string += String.fromCharCode(((byte & 0x1f) << 6) |
                        (bytes[++i] & 0x3f));
                    continue;
                }
                if ((byte & 0xf0) === 0xe0) {
                    string += String.fromCharCode(((byte & 0x0f) << 12) |
                        ((bytes[++i] & 0x3f) << 6) |
                        ((bytes[++i] & 0x3f) << 0));
                    continue;
                }
                if ((byte & 0xf8) === 0xf0) {
                    chr = ((byte & 0x07) << 18) |
                        ((bytes[++i] & 0x3f) << 12) |
                        ((bytes[++i] & 0x3f) << 6) |
                        ((bytes[++i] & 0x3f) << 0);
                    if (chr >= 0x010000) { // surrogate pair
                        chr -= 0x010000;
                        string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
                    }
                    else {
                        string += String.fromCharCode(chr);
                    }
                    continue;
                }
                console.error('Invalid byte ' + byte.toString(16));
                // (do not throw error to avoid server/client from crashing due to hack attemps)
                // throw new Error('Invalid byte ' + byte.toString(16));
            }
            return string;
        }
        function int8(bytes, it) {
            return uint8(bytes, it) << 24 >> 24;
        }
        function uint8(bytes, it) {
            return bytes[it.offset++];
        }
        function int16(bytes, it) {
            return uint16(bytes, it) << 16 >> 16;
        }
        function uint16(bytes, it) {
            return bytes[it.offset++] | bytes[it.offset++] << 8;
        }
        function int32(bytes, it) {
            return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;
        }
        function uint32(bytes, it) {
            return int32(bytes, it) >>> 0;
        }
        function float32(bytes, it) {
            return readFloat32(bytes, it);
        }
        function float64(bytes, it) {
            return readFloat64(bytes, it);
        }
        function int64(bytes, it) {
            var low = uint32(bytes, it);
            var high = int32(bytes, it) * Math.pow(2, 32);
            return high + low;
        }
        function uint64(bytes, it) {
            var low = uint32(bytes, it);
            var high = uint32(bytes, it) * Math.pow(2, 32);
            return high + low;
        }
        var _int32 = new Int32Array(2);
        var _float32 = new Float32Array(_int32.buffer);
        var _float64 = new Float64Array(_int32.buffer);
        function readFloat32(bytes, it) {
            _int32[0] = int32(bytes, it);
            return _float32[0];
        }
        function readFloat64(bytes, it) {
            _int32[0 ] = int32(bytes, it);
            _int32[1 ] = int32(bytes, it);
            return _float64[0];
        }
        function boolean(bytes, it) {
            return uint8(bytes, it) > 0;
        }
        function string(bytes, it) {
            var prefix = bytes[it.offset++];
            var length;
            if (prefix < 0xc0) {
                // fixstr
                length = prefix & 0x1f;
            }
            else if (prefix === 0xd9) {
                length = uint8(bytes, it);
            }
            else if (prefix === 0xda) {
                length = uint16(bytes, it);
            }
            else if (prefix === 0xdb) {
                length = uint32(bytes, it);
            }
            var value = utf8Read(bytes, it.offset, length);
            it.offset += length;
            return value;
        }
        function stringCheck(bytes, it) {
            var prefix = bytes[it.offset];
            return (
            // fixstr
            (prefix < 0xc0 && prefix > 0xa0) ||
                // str 8
                prefix === 0xd9 ||
                // str 16
                prefix === 0xda ||
                // str 32
                prefix === 0xdb);
        }
        function number(bytes, it) {
            var prefix = bytes[it.offset++];
            if (prefix < 0x80) {
                // positive fixint
                return prefix;
            }
            else if (prefix === 0xca) {
                // float 32
                return readFloat32(bytes, it);
            }
            else if (prefix === 0xcb) {
                // float 64
                return readFloat64(bytes, it);
            }
            else if (prefix === 0xcc) {
                // uint 8
                return uint8(bytes, it);
            }
            else if (prefix === 0xcd) {
                // uint 16
                return uint16(bytes, it);
            }
            else if (prefix === 0xce) {
                // uint 32
                return uint32(bytes, it);
            }
            else if (prefix === 0xcf) {
                // uint 64
                return uint64(bytes, it);
            }
            else if (prefix === 0xd0) {
                // int 8
                return int8(bytes, it);
            }
            else if (prefix === 0xd1) {
                // int 16
                return int16(bytes, it);
            }
            else if (prefix === 0xd2) {
                // int 32
                return int32(bytes, it);
            }
            else if (prefix === 0xd3) {
                // int 64
                return int64(bytes, it);
            }
            else if (prefix > 0xdf) {
                // negative fixint
                return (0xff - prefix + 1) * -1;
            }
        }
        function numberCheck(bytes, it) {
            var prefix = bytes[it.offset];
            // positive fixint - 0x00 - 0x7f
            // float 32        - 0xca
            // float 64        - 0xcb
            // uint 8          - 0xcc
            // uint 16         - 0xcd
            // uint 32         - 0xce
            // uint 64         - 0xcf
            // int 8           - 0xd0
            // int 16          - 0xd1
            // int 32          - 0xd2
            // int 64          - 0xd3
            return (prefix < 0x80 ||
                (prefix >= 0xca && prefix <= 0xd3));
        }
        function arrayCheck(bytes, it) {
            return bytes[it.offset] < 0xa0;
            // const prefix = bytes[it.offset] ;
            // if (prefix < 0xa0) {
            //   return prefix;
            // // array
            // } else if (prefix === 0xdc) {
            //   it.offset += 2;
            // } else if (0xdd) {
            //   it.offset += 4;
            // }
            // return prefix;
        }
        function switchStructureCheck(bytes, it) {
            return (
            // previous byte should be `SWITCH_TO_STRUCTURE`
            bytes[it.offset - 1] === SWITCH_TO_STRUCTURE &&
                // next byte should be a number
                (bytes[it.offset] < 0x80 || (bytes[it.offset] >= 0xca && bytes[it.offset] <= 0xd3)));
        }

        var decode = /*#__PURE__*/Object.freeze({
            __proto__: null,
            int8: int8,
            uint8: uint8,
            int16: int16,
            uint16: uint16,
            int32: int32,
            uint32: uint32,
            float32: float32,
            float64: float64,
            int64: int64,
            uint64: uint64,
            readFloat32: readFloat32,
            readFloat64: readFloat64,
            boolean: boolean,
            string: string,
            stringCheck: stringCheck,
            number: number,
            numberCheck: numberCheck,
            arrayCheck: arrayCheck,
            switchStructureCheck: switchStructureCheck
        });

        var CollectionSchema = /** @class */ (function () {
            function CollectionSchema(initialValues) {
                var _this = this;
                this.$changes = new ChangeTree(this);
                this.$items = new Map();
                this.$indexes = new Map();
                this.$refId = 0;
                if (initialValues) {
                    initialValues.forEach(function (v) { return _this.add(v); });
                }
            }
            CollectionSchema.is = function (type) {
                return type['collection'] !== undefined;
            };
            CollectionSchema.prototype.add = function (value) {
                // set "index" for reference.
                var index = this.$refId++;
                var isRef = (value['$changes']) !== undefined;
                if (isRef) {
                    value['$changes'].setParent(this, this.$changes.root, index);
                }
                this.$changes.indexes[index] = index;
                this.$indexes.set(index, index);
                this.$items.set(index, value);
                this.$changes.change(index);
                return index;
            };
            CollectionSchema.prototype.at = function (index) {
                var key = Array.from(this.$items.keys())[index];
                return this.$items.get(key);
            };
            CollectionSchema.prototype.entries = function () {
                return this.$items.entries();
            };
            CollectionSchema.prototype.delete = function (item) {
                var entries = this.$items.entries();
                var index;
                var entry;
                while (entry = entries.next()) {
                    if (entry.done) {
                        break;
                    }
                    if (item === entry.value[1]) {
                        index = entry.value[0];
                        break;
                    }
                }
                if (index === undefined) {
                    return false;
                }
                this.$changes.delete(index);
                this.$indexes.delete(index);
                return this.$items.delete(index);
            };
            CollectionSchema.prototype.clear = function (isDecoding) {
                var _this = this;
                // discard previous operations.
                this.$changes.discard(true, true);
                this.$changes.indexes = {};
                // clear previous indexes
                this.$indexes.clear();
                // flag child items for garbage collection.
                if (isDecoding && typeof (this.$changes.getType()) !== "string") {
                    this.$items.forEach(function (item) {
                        _this.$changes.root.removeRef(item['$changes'].refId);
                    });
                }
                // clear items
                this.$items.clear();
                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });
                // touch all structures until reach root
                this.$changes.touchParents();
            };
            CollectionSchema.prototype.has = function (value) {
                return Array.from(this.$items.values()).some(function (v) { return v === value; });
            };
            CollectionSchema.prototype.forEach = function (callbackfn) {
                var _this = this;
                this.$items.forEach(function (value, key, _) { return callbackfn(value, key, _this); });
            };
            CollectionSchema.prototype.values = function () {
                return this.$items.values();
            };
            Object.defineProperty(CollectionSchema.prototype, "size", {
                get: function () {
                    return this.$items.size;
                },
                enumerable: false,
                configurable: true
            });
            CollectionSchema.prototype.setIndex = function (index, key) {
                this.$indexes.set(index, key);
            };
            CollectionSchema.prototype.getIndex = function (index) {
                return this.$indexes.get(index);
            };
            CollectionSchema.prototype.getByIndex = function (index) {
                return this.$items.get(this.$indexes.get(index));
            };
            CollectionSchema.prototype.deleteByIndex = function (index) {
                var key = this.$indexes.get(index);
                this.$items.delete(key);
                this.$indexes.delete(index);
            };
            CollectionSchema.prototype.toArray = function () {
                return Array.from(this.$items.values());
            };
            CollectionSchema.prototype.toJSON = function () {
                var values = [];
                this.forEach(function (value, key) {
                    values.push((typeof (value['toJSON']) === "function")
                        ? value['toJSON']()
                        : value);
                });
                return values;
            };
            //
            // Decoding utilities
            //
            CollectionSchema.prototype.clone = function (isDecoding) {
                var cloned;
                if (isDecoding) {
                    // client-side
                    cloned = Object.assign(new CollectionSchema(), this);
                }
                else {
                    // server-side
                    cloned = new CollectionSchema();
                    this.forEach(function (value) {
                        if (value['$changes']) {
                            cloned.add(value['clone']());
                        }
                        else {
                            cloned.add(value);
                        }
                    });
                }
                return cloned;
            };
            CollectionSchema.prototype.triggerAll = function () {
                Schema.prototype.triggerAll.apply(this);
            };
            return CollectionSchema;
        }());

        var SetSchema = /** @class */ (function () {
            function SetSchema(initialValues) {
                var _this = this;
                this.$changes = new ChangeTree(this);
                this.$items = new Map();
                this.$indexes = new Map();
                this.$refId = 0;
                if (initialValues) {
                    initialValues.forEach(function (v) { return _this.add(v); });
                }
            }
            SetSchema.is = function (type) {
                return type['set'] !== undefined;
            };
            SetSchema.prototype.add = function (value) {
                var _a, _b;
                // immediatelly return false if value already added.
                if (this.has(value)) {
                    return false;
                }
                // set "index" for reference.
                var index = this.$refId++;
                if ((value['$changes']) !== undefined) {
                    value['$changes'].setParent(this, this.$changes.root, index);
                }
                var operation = (_b = (_a = this.$changes.indexes[index]) === null || _a === void 0 ? void 0 : _a.op) !== null && _b !== void 0 ? _b : exports.OPERATION.ADD;
                this.$changes.indexes[index] = index;
                this.$indexes.set(index, index);
                this.$items.set(index, value);
                this.$changes.change(index, operation);
                return index;
            };
            SetSchema.prototype.entries = function () {
                return this.$items.entries();
            };
            SetSchema.prototype.delete = function (item) {
                var entries = this.$items.entries();
                var index;
                var entry;
                while (entry = entries.next()) {
                    if (entry.done) {
                        break;
                    }
                    if (item === entry.value[1]) {
                        index = entry.value[0];
                        break;
                    }
                }
                if (index === undefined) {
                    return false;
                }
                this.$changes.delete(index);
                this.$indexes.delete(index);
                return this.$items.delete(index);
            };
            SetSchema.prototype.clear = function (isDecoding) {
                var _this = this;
                // discard previous operations.
                this.$changes.discard(true, true);
                this.$changes.indexes = {};
                // clear previous indexes
                this.$indexes.clear();
                // flag child items for garbage collection.
                if (isDecoding && typeof (this.$changes.getType()) !== "string") {
                    this.$items.forEach(function (item) {
                        _this.$changes.root.removeRef(item['$changes'].refId);
                    });
                }
                // clear items
                this.$items.clear();
                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });
                // touch all structures until reach root
                this.$changes.touchParents();
            };
            SetSchema.prototype.has = function (value) {
                var values = this.$items.values();
                var has = false;
                var entry;
                while (entry = values.next()) {
                    if (entry.done) {
                        break;
                    }
                    if (value === entry.value) {
                        has = true;
                        break;
                    }
                }
                return has;
            };
            SetSchema.prototype.forEach = function (callbackfn) {
                var _this = this;
                this.$items.forEach(function (value, key, _) { return callbackfn(value, key, _this); });
            };
            SetSchema.prototype.values = function () {
                return this.$items.values();
            };
            Object.defineProperty(SetSchema.prototype, "size", {
                get: function () {
                    return this.$items.size;
                },
                enumerable: false,
                configurable: true
            });
            SetSchema.prototype.setIndex = function (index, key) {
                this.$indexes.set(index, key);
            };
            SetSchema.prototype.getIndex = function (index) {
                return this.$indexes.get(index);
            };
            SetSchema.prototype.getByIndex = function (index) {
                return this.$items.get(this.$indexes.get(index));
            };
            SetSchema.prototype.deleteByIndex = function (index) {
                var key = this.$indexes.get(index);
                this.$items.delete(key);
                this.$indexes.delete(index);
            };
            SetSchema.prototype.toArray = function () {
                return Array.from(this.$items.values());
            };
            SetSchema.prototype.toJSON = function () {
                var values = [];
                this.forEach(function (value, key) {
                    values.push((typeof (value['toJSON']) === "function")
                        ? value['toJSON']()
                        : value);
                });
                return values;
            };
            //
            // Decoding utilities
            //
            SetSchema.prototype.clone = function (isDecoding) {
                var cloned;
                if (isDecoding) {
                    // client-side
                    cloned = Object.assign(new SetSchema(), this);
                }
                else {
                    // server-side
                    cloned = new SetSchema();
                    this.forEach(function (value) {
                        if (value['$changes']) {
                            cloned.add(value['clone']());
                        }
                        else {
                            cloned.add(value);
                        }
                    });
                }
                return cloned;
            };
            SetSchema.prototype.triggerAll = function () {
                Schema.prototype.triggerAll.apply(this);
            };
            return SetSchema;
        }());

        /**
         * Extracted from https://www.npmjs.com/package/strong-events
         */
        var EventEmitter_ = /** @class */ (function () {
            function EventEmitter_() {
                this.handlers = [];
            }
            EventEmitter_.prototype.register = function (cb, once) {
                this.handlers.push(cb);
                return this;
            };
            EventEmitter_.prototype.invoke = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                this.handlers.forEach(function (handler) { return handler.apply(void 0, args); });
            };
            EventEmitter_.prototype.invokeAsync = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return Promise.all(this.handlers.map(function (handler) { return handler.apply(void 0, args); }));
            };
            EventEmitter_.prototype.remove = function (cb) {
                var index = this.handlers.indexOf(cb);
                this.handlers[index] = this.handlers[this.handlers.length - 1];
                this.handlers.pop();
            };
            EventEmitter_.prototype.clear = function () {
                this.handlers = [];
            };
            return EventEmitter_;
        }());

        var ClientState = /** @class */ (function () {
            function ClientState() {
                this.refIds = new WeakSet();
                this.containerIndexes = new WeakMap();
            }
            // containerIndexes = new Map<ChangeTree, Set<number>>();
            ClientState.prototype.addRefId = function (changeTree) {
                if (!this.refIds.has(changeTree)) {
                    this.refIds.add(changeTree);
                    this.containerIndexes.set(changeTree, new Set());
                }
            };
            ClientState.get = function (client) {
                if (client.$filterState === undefined) {
                    client.$filterState = new ClientState();
                }
                return client.$filterState;
            };
            return ClientState;
        }());

        var EncodeSchemaError = /** @class */ (function (_super) {
            __extends(EncodeSchemaError, _super);
            function EncodeSchemaError() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return EncodeSchemaError;
        }(Error));
        function assertType(value, type, klass, field) {
            var typeofTarget;
            var allowNull = false;
            switch (type) {
                case "number":
                case "int8":
                case "uint8":
                case "int16":
                case "uint16":
                case "int32":
                case "uint32":
                case "int64":
                case "uint64":
                case "float32":
                case "float64":
                    typeofTarget = "number";
                    if (isNaN(value)) {
                        console.log("trying to encode \"NaN\" in " + klass.constructor.name + "#" + field);
                    }
                    break;
                case "string":
                    typeofTarget = "string";
                    allowNull = true;
                    break;
                case "boolean":
                    // boolean is always encoded as true/false based on truthiness
                    return;
            }
            if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {
                var foundValue = "'" + JSON.stringify(value) + "'" + ((value && value.constructor && " (" + value.constructor.name + ")") || '');
                throw new EncodeSchemaError("a '" + typeofTarget + "' was expected, but " + foundValue + " was provided in " + klass.constructor.name + "#" + field);
            }
        }
        function assertInstanceType(value, type, klass, field) {
            if (!(value instanceof type)) {
                throw new EncodeSchemaError("a '" + type.name + "' was expected, but '" + value.constructor.name + "' was provided in " + klass.constructor.name + "#" + field);
            }
        }
        function encodePrimitiveType(type, bytes, value, klass, field) {
            assertType(value, type, klass, field);
            var encodeFunc = encode[type];
            if (encodeFunc) {
                encodeFunc(bytes, value);
            }
            else {
                throw new EncodeSchemaError("a '" + type + "' was expected, but " + value + " was provided in " + klass.constructor.name + "#" + field);
            }
        }
        function decodePrimitiveType(type, bytes, it) {
            return decode[type](bytes, it);
        }
        /**
         * Schema encoder / decoder
         */
        var Schema = /** @class */ (function () {
            // allow inherited classes to have a constructor
            function Schema() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                // fix enumerability of fields for end-user
                Object.defineProperties(this, {
                    $changes: {
                        value: new ChangeTree(this, undefined, new Root()),
                        enumerable: false,
                        writable: true
                    },
                    $listeners: {
                        value: {},
                        enumerable: false,
                        writable: true
                    },
                });
                var descriptors = this._definition.descriptors;
                if (descriptors) {
                    Object.defineProperties(this, descriptors);
                }
                //
                // Assign initial values
                //
                if (args[0]) {
                    this.assign(args[0]);
                }
            }
            Schema.onError = function (e) {
                console.error(e);
            };
            Schema.is = function (type) {
                return (type['_definition'] &&
                    type['_definition'].schema !== undefined);
            };
            Schema.prototype.assign = function (props) {
                Object.assign(this, props);
                return this;
            };
            Object.defineProperty(Schema.prototype, "_definition", {
                get: function () { return this.constructor._definition; },
                enumerable: false,
                configurable: true
            });
            Schema.prototype.listen = function (attr, callback) {
                var _this = this;
                if (!this.$listeners[attr]) {
                    this.$listeners[attr] = new EventEmitter_();
                }
                this.$listeners[attr].register(callback);
                // return un-register callback.
                return function () {
                    return _this.$listeners[attr].remove(callback);
                };
            };
            Schema.prototype.decode = function (bytes, it, ref, allChanges) {
                if (it === void 0) { it = { offset: 0 }; }
                if (ref === void 0) { ref = this; }
                if (allChanges === void 0) { allChanges = new Map(); }
                var $root = this.$changes.root;
                var totalBytes = bytes.length;
                var refId = 0;
                var changes = [];
                $root.refs.set(refId, this);
                allChanges.set(refId, changes);
                while (it.offset < totalBytes) {
                    var byte = bytes[it.offset++];
                    if (byte == SWITCH_TO_STRUCTURE) {
                        refId = number(bytes, it);
                        var nextRef = $root.refs.get(refId);
                        //
                        // Trying to access a reference that haven't been decoded yet.
                        //
                        if (!nextRef) {
                            throw new Error("\"refId\" not found: " + refId);
                        }
                        ref = nextRef;
                        // create empty list of changes for this refId.
                        changes = [];
                        allChanges.set(refId, changes);
                        continue;
                    }
                    var changeTree = ref['$changes'];
                    var isSchema = (ref['_definition'] !== undefined);
                    var operation = (isSchema)
                        ? (byte >> 6) << 6 // "compressed" index + operation
                        : byte; // "uncompressed" index + operation (array/map items)
                    if (operation === exports.OPERATION.CLEAR) {
                        //
                        // TODO: refactor me!
                        // The `.clear()` method is calling `$root.removeRef(refId)` for
                        // each item inside this collection
                        //
                        ref.clear(true);
                        continue;
                    }
                    var fieldIndex = (isSchema)
                        ? byte % (operation || 255) // if "REPLACE" operation (0), use 255
                        : number(bytes, it);
                    var fieldName = (isSchema)
                        ? (ref['_definition'].fieldsByIndex[fieldIndex])
                        : "";
                    var type = changeTree.getType(fieldIndex);
                    var value = void 0;
                    var previousValue = void 0;
                    var dynamicIndex = void 0;
                    if (!isSchema) {
                        previousValue = ref['getByIndex'](fieldIndex);
                        if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) { // ADD or DELETE_AND_ADD
                            dynamicIndex = (ref instanceof MapSchema)
                                ? string(bytes, it)
                                : fieldIndex;
                            ref['setIndex'](fieldIndex, dynamicIndex);
                        }
                        else {
                            // here
                            dynamicIndex = ref['getIndex'](fieldIndex);
                        }
                    }
                    else {
                        previousValue = ref["_" + fieldName];
                    }
                    //
                    // Delete operations
                    //
                    if ((operation & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {
                        if (operation !== exports.OPERATION.DELETE_AND_ADD) {
                            ref['deleteByIndex'](fieldIndex);
                        }
                        // Flag `refId` for garbage collection.
                        if (previousValue && previousValue['$changes']) {
                            $root.removeRef(previousValue['$changes'].refId);
                        }
                        value = null;
                    }
                    if (fieldName === undefined) {
                        console.warn("@colyseus/schema: definition mismatch");
                        //
                        // keep skipping next bytes until reaches a known structure
                        // by local decoder.
                        //
                        var nextIterator = { offset: it.offset };
                        while (it.offset < totalBytes) {
                            if (switchStructureCheck(bytes, it)) {
                                nextIterator.offset = it.offset + 1;
                                if ($root.refs.has(number(bytes, nextIterator))) {
                                    break;
                                }
                            }
                            it.offset++;
                        }
                        continue;
                    }
                    else if (operation === exports.OPERATION.DELETE) ;
                    else if (Schema.is(type)) {
                        var refId_1 = number(bytes, it);
                        value = $root.refs.get(refId_1);
                        if (operation !== exports.OPERATION.REPLACE) {
                            var childType = this.getSchemaType(bytes, it, type);
                            if (!value) {
                                value = this.createTypeInstance(childType);
                                value.$changes.refId = refId_1;
                                if (previousValue) {
                                    value.onChange = previousValue.onChange;
                                    value.onRemove = previousValue.onRemove;
                                    value.$listeners = previousValue.$listeners;
                                    if (previousValue['$changes'].refId &&
                                        refId_1 !== previousValue['$changes'].refId) {
                                        $root.removeRef(previousValue['$changes'].refId);
                                    }
                                }
                            }
                            $root.addRef(refId_1, value, (value !== previousValue));
                        }
                    }
                    else if (typeof (type) === "string") {
                        //
                        // primitive value (number, string, boolean, etc)
                        //
                        value = decodePrimitiveType(type, bytes, it);
                    }
                    else {
                        var typeDef = getType(Object.keys(type)[0]);
                        var refId_2 = number(bytes, it);
                        var valueRef = ($root.refs.has(refId_2))
                            ? previousValue || $root.refs.get(refId_2)
                            : new typeDef.constructor();
                        value = valueRef.clone(true);
                        value.$changes.refId = refId_2;
                        // preserve schema callbacks
                        if (previousValue) {
                            value.onAdd = previousValue.onAdd;
                            value.onRemove = previousValue.onRemove;
                            value.onChange = previousValue.onChange;
                            if (previousValue['$changes'].refId &&
                                refId_2 !== previousValue['$changes'].refId) {
                                $root.removeRef(previousValue['$changes'].refId);
                                //
                                // Trigger onRemove if structure has been replaced.
                                //
                                var deletes = [];
                                var entries = previousValue.entries();
                                var iter = void 0;
                                while ((iter = entries.next()) && !iter.done) {
                                    var _a = iter.value, key = _a[0], value_1 = _a[1];
                                    deletes.push({
                                        op: exports.OPERATION.DELETE,
                                        field: key,
                                        value: undefined,
                                        previousValue: value_1,
                                    });
                                }
                                allChanges.set(previousValue['$changes'].refId, deletes);
                            }
                        }
                        $root.addRef(refId_2, value, (valueRef !== previousValue));
                        //
                        // TODO: deprecate proxies on next version.
                        // get proxy to target value.
                        //
                        if (typeDef.getProxy) {
                            value = typeDef.getProxy(value);
                        }
                    }
                    var hasChange = (previousValue !== value);
                    if (value !== null &&
                        value !== undefined) {
                        if (value['$changes']) {
                            value['$changes'].setParent(changeTree.ref, changeTree.root, fieldIndex);
                        }
                        if (ref instanceof Schema) {
                            ref[fieldName] = value;
                            //
                            // FIXME: use `_field` instead of `field`.
                            //
                            // `field` is going to use the setter of the PropertyDescriptor
                            // and create a proxy for array/map. This is only useful for
                            // backwards-compatibility with @colyseus/schema@0.5.x
                            //
                            // // ref[_field] = value;
                        }
                        else if (ref instanceof MapSchema) {
                            // const key = ref['$indexes'].get(field);
                            var key = dynamicIndex;
                            // ref.set(key, value);
                            ref['$items'].set(key, value);
                        }
                        else if (ref instanceof ArraySchema) {
                            // const key = ref['$indexes'][field];
                            // console.log("SETTING FOR ArraySchema =>", { field, key, value });
                            // ref[key] = value;
                            ref.setAt(fieldIndex, value);
                        }
                        else if (ref instanceof CollectionSchema) {
                            var index = ref.add(value);
                            ref['setIndex'](fieldIndex, index);
                        }
                        else if (ref instanceof SetSchema) {
                            var index = ref.add(value);
                            if (index !== false) {
                                ref['setIndex'](fieldIndex, index);
                            }
                        }
                    }
                    if (hasChange
                    // &&
                    // (
                    //     this.onChange || ref.$listeners[field]
                    // )
                    ) {
                        changes.push({
                            op: operation,
                            field: fieldName,
                            dynamicIndex: dynamicIndex,
                            value: value,
                            previousValue: previousValue,
                        });
                    }
                }
                this._triggerChanges(allChanges);
                // drop references of unused schemas
                $root.garbageCollectDeletedRefs();
                return allChanges;
            };
            Schema.prototype.encode = function (encodeAll, bytes, useFilters) {
                if (encodeAll === void 0) { encodeAll = false; }
                if (bytes === void 0) { bytes = []; }
                if (useFilters === void 0) { useFilters = false; }
                var rootChangeTree = this.$changes;
                var refIdsVisited = new WeakSet();
                var changeTrees = [rootChangeTree];
                var numChangeTrees = 1;
                for (var i = 0; i < numChangeTrees; i++) {
                    var changeTree = changeTrees[i];
                    var ref = changeTree.ref;
                    var isSchema = (ref instanceof Schema);
                    // Generate unique refId for the ChangeTree.
                    changeTree.ensureRefId();
                    // mark this ChangeTree as visited.
                    refIdsVisited.add(changeTree);
                    // root `refId` is skipped.
                    if (changeTree !== rootChangeTree &&
                        (changeTree.changed || encodeAll)) {
                        uint8$1(bytes, SWITCH_TO_STRUCTURE);
                        number$1(bytes, changeTree.refId);
                    }
                    var changes = (encodeAll)
                        ? Array.from(changeTree.allChanges)
                        : Array.from(changeTree.changes.values());
                    for (var j = 0, cl = changes.length; j < cl; j++) {
                        var operation = (encodeAll)
                            ? { op: exports.OPERATION.ADD, index: changes[j] }
                            : changes[j];
                        var fieldIndex = operation.index;
                        var field = (isSchema)
                            ? ref['_definition'].fieldsByIndex && ref['_definition'].fieldsByIndex[fieldIndex]
                            : fieldIndex;
                        // cache begin index if `useFilters`
                        var beginIndex = bytes.length;
                        // encode field index + operation
                        if (operation.op !== exports.OPERATION.TOUCH) {
                            if (isSchema) {
                                //
                                // Compress `fieldIndex` + `operation` into a single byte.
                                // This adds a limitaion of 64 fields per Schema structure
                                //
                                uint8$1(bytes, (fieldIndex | operation.op));
                            }
                            else {
                                uint8$1(bytes, operation.op);
                                // custom operations
                                if (operation.op === exports.OPERATION.CLEAR) {
                                    continue;
                                }
                                // indexed operations
                                number$1(bytes, fieldIndex);
                            }
                        }
                        //
                        // encode "alias" for dynamic fields (maps)
                        //
                        if (!isSchema &&
                            (operation.op & exports.OPERATION.ADD) == exports.OPERATION.ADD // ADD or DELETE_AND_ADD
                        ) {
                            if (ref instanceof MapSchema) {
                                //
                                // MapSchema dynamic key
                                //
                                var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                                string$1(bytes, dynamicIndex);
                            }
                        }
                        if (operation.op === exports.OPERATION.DELETE) {
                            //
                            // TODO: delete from filter cache data.
                            //
                            // if (useFilters) {
                            //     delete changeTree.caches[fieldIndex];
                            // }
                            continue;
                        }
                        // const type = changeTree.childType || ref._schema[field];
                        var type = changeTree.getType(fieldIndex);
                        // const type = changeTree.getType(fieldIndex);
                        var value = changeTree.getValue(fieldIndex);
                        // Enqueue ChangeTree to be visited
                        if (value &&
                            value['$changes'] &&
                            !refIdsVisited.has(value['$changes'])) {
                            changeTrees.push(value['$changes']);
                            value['$changes'].ensureRefId();
                            numChangeTrees++;
                        }
                        if (operation.op === exports.OPERATION.TOUCH) {
                            continue;
                        }
                        if (Schema.is(type)) {
                            assertInstanceType(value, type, ref, field);
                            //
                            // Encode refId for this instance.
                            // The actual instance is going to be encoded on next `changeTree` iteration.
                            //
                            number$1(bytes, value.$changes.refId);
                            // Try to encode inherited TYPE_ID if it's an ADD operation.
                            if ((operation.op & exports.OPERATION.ADD) === exports.OPERATION.ADD) {
                                this.tryEncodeTypeId(bytes, type, value.constructor);
                            }
                        }
                        else if (typeof (type) === "string") {
                            //
                            // Primitive values
                            //
                            encodePrimitiveType(type, bytes, value, ref, field);
                        }
                        else {
                            //
                            // Custom type (MapSchema, ArraySchema, etc)
                            //
                            var definition = getType(Object.keys(type)[0]);
                            //
                            // ensure a ArraySchema has been provided
                            //
                            assertInstanceType(ref["_" + field], definition.constructor, ref, field);
                            //
                            // Encode refId for this instance.
                            // The actual instance is going to be encoded on next `changeTree` iteration.
                            //
                            number$1(bytes, value.$changes.refId);
                        }
                        if (useFilters) {
                            // cache begin / end index
                            changeTree.cache(fieldIndex, bytes.slice(beginIndex));
                        }
                    }
                    if (!encodeAll && !useFilters) {
                        changeTree.discard();
                    }
                }
                return bytes;
            };
            Schema.prototype.encodeAll = function (useFilters) {
                return this.encode(true, [], useFilters);
            };
            Schema.prototype.applyFilters = function (client, encodeAll) {
                var _a, _b;
                if (encodeAll === void 0) { encodeAll = false; }
                var root = this;
                var refIdsDissallowed = new Set();
                var $filterState = ClientState.get(client);
                var changeTrees = [this.$changes];
                var numChangeTrees = 1;
                var filteredBytes = [];
                var _loop_1 = function (i) {
                    var changeTree = changeTrees[i];
                    if (refIdsDissallowed.has(changeTree.refId)) {
                        return "continue";
                    }
                    var ref = changeTree.ref;
                    var isSchema = ref instanceof Schema;
                    uint8$1(filteredBytes, SWITCH_TO_STRUCTURE);
                    number$1(filteredBytes, changeTree.refId);
                    var clientHasRefId = $filterState.refIds.has(changeTree);
                    var isEncodeAll = (encodeAll || !clientHasRefId);
                    // console.log("REF:", ref.constructor.name);
                    // console.log("Encode all?", isEncodeAll);
                    //
                    // include `changeTree` on list of known refIds by this client.
                    //
                    $filterState.addRefId(changeTree);
                    var containerIndexes = $filterState.containerIndexes.get(changeTree);
                    var changes = (isEncodeAll)
                        ? Array.from(changeTree.allChanges)
                        : Array.from(changeTree.changes.values());
                    //
                    // WORKAROUND: tries to re-evaluate previously not included @filter() attributes
                    // - see "DELETE a field of Schema" test case.
                    //
                    if (!encodeAll &&
                        isSchema &&
                        ref._definition.indexesWithFilters) {
                        var indexesWithFilters = ref._definition.indexesWithFilters;
                        indexesWithFilters.forEach(function (indexWithFilter) {
                            if (!containerIndexes.has(indexWithFilter) &&
                                changeTree.allChanges.has(indexWithFilter)) {
                                if (isEncodeAll) {
                                    changes.push(indexWithFilter);
                                }
                                else {
                                    changes.push({ op: exports.OPERATION.ADD, index: indexWithFilter, });
                                }
                            }
                        });
                    }
                    for (var j = 0, cl = changes.length; j < cl; j++) {
                        var change = (isEncodeAll)
                            ? { op: exports.OPERATION.ADD, index: changes[j] }
                            : changes[j];
                        // custom operations
                        if (change.op === exports.OPERATION.CLEAR) {
                            uint8$1(filteredBytes, change.op);
                            continue;
                        }
                        var fieldIndex = change.index;
                        //
                        // Deleting fields: encode the operation + field index
                        //
                        if (change.op === exports.OPERATION.DELETE) {
                            //
                            // DELETE operations also need to go through filtering.
                            //
                            // TODO: cache the previous value so we can access the value (primitive or `refId`)
                            // (check against `$filterState.refIds`)
                            //
                            if (isSchema) {
                                uint8$1(filteredBytes, change.op | fieldIndex);
                            }
                            else {
                                uint8$1(filteredBytes, change.op);
                                number$1(filteredBytes, fieldIndex);
                            }
                            continue;
                        }
                        // indexed operation
                        var value = changeTree.getValue(fieldIndex);
                        var type = changeTree.getType(fieldIndex);
                        if (isSchema) {
                            // Is a Schema!
                            var filter = (ref._definition.filters &&
                                ref._definition.filters[fieldIndex]);
                            if (filter && !filter.call(ref, client, value, root)) {
                                if (value && value['$changes']) {
                                    refIdsDissallowed.add(value['$changes'].refId);
                                }
                                continue;
                            }
                        }
                        else {
                            // Is a collection! (map, array, etc.)
                            var parent = changeTree.parent;
                            var filter = changeTree.getChildrenFilter();
                            if (filter && !filter.call(parent, client, ref['$indexes'].get(fieldIndex), value, root)) {
                                if (value && value['$changes']) {
                                    refIdsDissallowed.add(value['$changes'].refId);
                                }
                                continue;
                            }
                        }
                        // visit child ChangeTree on further iteration.
                        if (value['$changes']) {
                            changeTrees.push(value['$changes']);
                            numChangeTrees++;
                        }
                        //
                        // Copy cached bytes
                        //
                        if (change.op !== exports.OPERATION.TOUCH) {
                            //
                            // TODO: refactor me!
                            //
                            if (change.op === exports.OPERATION.ADD || isSchema) {
                                //
                                // use cached bytes directly if is from Schema type.
                                //
                                filteredBytes.push.apply(filteredBytes, (_a = changeTree.caches[fieldIndex]) !== null && _a !== void 0 ? _a : []);
                                containerIndexes.add(fieldIndex);
                            }
                            else {
                                if (containerIndexes.has(fieldIndex)) {
                                    //
                                    // use cached bytes if already has the field
                                    //
                                    filteredBytes.push.apply(filteredBytes, (_b = changeTree.caches[fieldIndex]) !== null && _b !== void 0 ? _b : []);
                                }
                                else {
                                    //
                                    // force ADD operation if field is not known by this client.
                                    //
                                    containerIndexes.add(fieldIndex);
                                    uint8$1(filteredBytes, exports.OPERATION.ADD);
                                    number$1(filteredBytes, fieldIndex);
                                    if (ref instanceof MapSchema) {
                                        //
                                        // MapSchema dynamic key
                                        //
                                        var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                                        string$1(filteredBytes, dynamicIndex);
                                    }
                                    if (value['$changes']) {
                                        number$1(filteredBytes, value['$changes'].refId);
                                    }
                                    else {
                                        // "encodePrimitiveType" without type checking.
                                        // the type checking has been done on the first .encode() call.
                                        encode[type](filteredBytes, value);
                                    }
                                }
                            }
                        }
                        else if (value['$changes'] && !isSchema) {
                            //
                            // TODO:
                            // - track ADD/REPLACE/DELETE instances on `$filterState`
                            // - do NOT always encode dynamicIndex for MapSchema.
                            //   (If client already has that key, only the first index is necessary.)
                            //
                            uint8$1(filteredBytes, exports.OPERATION.ADD);
                            number$1(filteredBytes, fieldIndex);
                            if (ref instanceof MapSchema) {
                                //
                                // MapSchema dynamic key
                                //
                                var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                                string$1(filteredBytes, dynamicIndex);
                            }
                            number$1(filteredBytes, value['$changes'].refId);
                        }
                    }
                };
                for (var i = 0; i < numChangeTrees; i++) {
                    _loop_1(i);
                }
                return filteredBytes;
            };
            Schema.prototype.clone = function () {
                var cloned = new (this.constructor);
                var schema = this._definition.schema;
                for (var field in schema) {
                    if (typeof (this[field]) === "object" &&
                        typeof (this[field].clone) === "function") {
                        // deep clone
                        cloned[field] = this[field].clone();
                    }
                    else {
                        // primitive values
                        cloned[field] = this[field];
                    }
                }
                return cloned;
            };
            Schema.prototype.triggerAll = function () {
                // skip if haven't received any remote refs yet.
                if (this.$changes.root.refs.size === 0) {
                    return;
                }
                var allChanges = new Map();
                Schema.prototype._triggerAllFillChanges.call(this, this, allChanges);
                try {
                    Schema.prototype._triggerChanges.call(this, allChanges);
                }
                catch (e) {
                    Schema.onError(e);
                }
            };
            Schema.prototype.toJSON = function () {
                var schema = this._definition.schema;
                var deprecated = this._definition.deprecated;
                var obj = {};
                for (var field in schema) {
                    if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== "undefined") {
                        obj[field] = (typeof (this[field]['toJSON']) === "function")
                            ? this[field]['toJSON']()
                            : this["_" + field];
                    }
                }
                return obj;
            };
            Schema.prototype.discardAllChanges = function () {
                this.$changes.discardAll();
            };
            Schema.prototype.getByIndex = function (index) {
                return this[this._definition.fieldsByIndex[index]];
            };
            Schema.prototype.deleteByIndex = function (index) {
                this[this._definition.fieldsByIndex[index]] = undefined;
            };
            Schema.prototype.tryEncodeTypeId = function (bytes, type, targetType) {
                if (type._typeid !== targetType._typeid) {
                    uint8$1(bytes, TYPE_ID);
                    number$1(bytes, targetType._typeid);
                }
            };
            Schema.prototype.getSchemaType = function (bytes, it, defaultType) {
                var type;
                if (bytes[it.offset] === TYPE_ID) {
                    it.offset++;
                    type = this.constructor._context.get(number(bytes, it));
                }
                return type || defaultType;
            };
            Schema.prototype.createTypeInstance = function (type) {
                var instance = new type();
                // assign root on $changes
                instance.$changes.root = this.$changes.root;
                return instance;
            };
            Schema.prototype._triggerAllFillChanges = function (ref, allChanges) {
                if (allChanges.has(ref['$changes'].refId)) {
                    return;
                }
                var changes = [];
                allChanges.set(ref['$changes'].refId || 0, changes);
                if (ref instanceof Schema) {
                    var schema = ref._definition.schema;
                    for (var fieldName in schema) {
                        var _field = "_" + fieldName;
                        var value = ref[_field];
                        if (value !== undefined) {
                            changes.push({
                                op: exports.OPERATION.ADD,
                                field: fieldName,
                                value: value,
                                previousValue: undefined
                            });
                            if (value['$changes'] !== undefined) {
                                Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);
                            }
                        }
                    }
                }
                else {
                    var entries = ref.entries();
                    var iter = void 0;
                    while ((iter = entries.next()) && !iter.done) {
                        var _a = iter.value, key = _a[0], value = _a[1];
                        changes.push({
                            op: exports.OPERATION.ADD,
                            field: key,
                            dynamicIndex: key,
                            value: value,
                            previousValue: undefined,
                        });
                        if (value['$changes'] !== undefined) {
                            Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);
                        }
                    }
                }
            };
            Schema.prototype._triggerChanges = function (allChanges) {
                var _this = this;
                allChanges.forEach(function (changes, refId) {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                    if (changes.length > 0) {
                        var ref = _this.$changes.root.refs.get(refId);
                        var isSchema = ref instanceof Schema;
                        for (var i = 0; i < changes.length; i++) {
                            var change = changes[i];
                            var listener = ref['$listeners'] && ref['$listeners'][change.field];
                            if (!isSchema) {
                                if (change.op === exports.OPERATION.ADD && change.previousValue === undefined) {
                                    (_b = (_a = ref).onAdd) === null || _b === void 0 ? void 0 : _b.call(_a, change.value, (_c = change.dynamicIndex) !== null && _c !== void 0 ? _c : change.field);
                                }
                                else if (change.op === exports.OPERATION.DELETE) {
                                    //
                                    // FIXME: `previousValue` should always be avaiiable.
                                    // ADD + DELETE operations are still encoding DELETE operation.
                                    //
                                    if (change.previousValue !== undefined) {
                                        (_e = (_d = ref).onRemove) === null || _e === void 0 ? void 0 : _e.call(_d, change.previousValue, (_f = change.dynamicIndex) !== null && _f !== void 0 ? _f : change.field);
                                    }
                                }
                                else if (change.op === exports.OPERATION.DELETE_AND_ADD) {
                                    if (change.previousValue !== undefined) {
                                        (_h = (_g = ref).onRemove) === null || _h === void 0 ? void 0 : _h.call(_g, change.previousValue, change.dynamicIndex);
                                    }
                                    (_k = (_j = ref).onAdd) === null || _k === void 0 ? void 0 : _k.call(_j, change.value, change.dynamicIndex);
                                }
                                else if (change.op === exports.OPERATION.REPLACE ||
                                    change.value !== change.previousValue) {
                                    (_m = (_l = ref).onChange) === null || _m === void 0 ? void 0 : _m.call(_l, change.value, change.dynamicIndex);
                                }
                            }
                            //
                            // trigger onRemove on child structure.
                            //
                            if ((change.op & exports.OPERATION.DELETE) === exports.OPERATION.DELETE &&
                                change.previousValue instanceof Schema &&
                                change.previousValue.onRemove) {
                                change.previousValue.onRemove();
                            }
                            if (listener) {
                                try {
                                    listener.invoke(change.value, change.previousValue);
                                }
                                catch (e) {
                                    Schema.onError(e);
                                }
                            }
                        }
                        if (isSchema) {
                            if (ref.onChange) {
                                try {
                                    ref.onChange(changes);
                                }
                                catch (e) {
                                    Schema.onError(e);
                                }
                            }
                        }
                    }
                });
            };
            Schema._definition = SchemaDefinition.create();
            return Schema;
        }());

        function dumpChanges(schema) {
            var changeTrees = [schema['$changes']];
            var numChangeTrees = 1;
            var dump = {};
            var currentStructure = dump;
            var _loop_1 = function (i) {
                var changeTree = changeTrees[i];
                changeTree.changes.forEach(function (change) {
                    var ref = changeTree.ref;
                    var fieldIndex = change.index;
                    var field = (ref['_definition'])
                        ? ref['_definition'].fieldsByIndex[fieldIndex]
                        : ref['$indexes'].get(fieldIndex);
                    currentStructure[field] = changeTree.getValue(fieldIndex);
                });
            };
            for (var i = 0; i < numChangeTrees; i++) {
                _loop_1(i);
            }
            return dump;
        }

        var reflectionContext = new Context();
        /**
         * Reflection
         */
        var ReflectionField = /** @class */ (function (_super) {
            __extends(ReflectionField, _super);
            function ReflectionField() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            __decorate([
                type("string", reflectionContext)
            ], ReflectionField.prototype, "name", void 0);
            __decorate([
                type("string", reflectionContext)
            ], ReflectionField.prototype, "type", void 0);
            __decorate([
                type("number", reflectionContext)
            ], ReflectionField.prototype, "referencedType", void 0);
            return ReflectionField;
        }(Schema));
        var ReflectionType = /** @class */ (function (_super) {
            __extends(ReflectionType, _super);
            function ReflectionType() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.fields = new ArraySchema();
                return _this;
            }
            __decorate([
                type("number", reflectionContext)
            ], ReflectionType.prototype, "id", void 0);
            __decorate([
                type([ReflectionField], reflectionContext)
            ], ReflectionType.prototype, "fields", void 0);
            return ReflectionType;
        }(Schema));
        var Reflection = /** @class */ (function (_super) {
            __extends(Reflection, _super);
            function Reflection() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.types = new ArraySchema();
                return _this;
            }
            Reflection.encode = function (instance) {
                var rootSchemaType = instance.constructor;
                var reflection = new Reflection();
                reflection.rootType = rootSchemaType._typeid;
                var buildType = function (currentType, schema) {
                    for (var fieldName in schema) {
                        var field = new ReflectionField();
                        field.name = fieldName;
                        var fieldType = void 0;
                        if (typeof (schema[fieldName]) === "string") {
                            fieldType = schema[fieldName];
                        }
                        else {
                            var type_1 = schema[fieldName];
                            var childTypeSchema = void 0;
                            //
                            // TODO: refactor below.
                            //
                            if (Schema.is(type_1)) {
                                fieldType = "ref";
                                childTypeSchema = schema[fieldName];
                            }
                            else {
                                fieldType = Object.keys(type_1)[0];
                                if (typeof (type_1[fieldType]) === "string") {
                                    fieldType += ":" + type_1[fieldType]; // array:string
                                }
                                else {
                                    childTypeSchema = type_1[fieldType];
                                }
                            }
                            field.referencedType = (childTypeSchema)
                                ? childTypeSchema._typeid
                                : -1;
                        }
                        field.type = fieldType;
                        currentType.fields.push(field);
                    }
                    reflection.types.push(currentType);
                };
                var types = rootSchemaType._context.types;
                for (var typeid in types) {
                    var type_2 = new ReflectionType();
                    type_2.id = Number(typeid);
                    buildType(type_2, types[typeid]._definition.schema);
                }
                return reflection.encodeAll();
            };
            Reflection.decode = function (bytes, it) {
                var context = new Context();
                var reflection = new Reflection();
                reflection.decode(bytes, it);
                var schemaTypes = reflection.types.reduce(function (types, reflectionType) {
                    var schema = /** @class */ (function (_super) {
                        __extends(_, _super);
                        function _() {
                            return _super !== null && _super.apply(this, arguments) || this;
                        }
                        return _;
                    }(Schema));
                    var typeid = reflectionType.id;
                    types[typeid] = schema;
                    context.add(schema, typeid);
                    return types;
                }, {});
                reflection.types.forEach(function (reflectionType) {
                    var schemaType = schemaTypes[reflectionType.id];
                    reflectionType.fields.forEach(function (field) {
                        var _a;
                        if (field.referencedType !== undefined) {
                            var fieldType = field.type;
                            var refType = schemaTypes[field.referencedType];
                            // map or array of primitive type (-1)
                            if (!refType) {
                                var typeInfo = field.type.split(":");
                                fieldType = typeInfo[0];
                                refType = typeInfo[1];
                            }
                            if (fieldType === "ref") {
                                type(refType, context)(schemaType.prototype, field.name);
                            }
                            else {
                                type((_a = {}, _a[fieldType] = refType, _a), context)(schemaType.prototype, field.name);
                            }
                        }
                        else {
                            type(field.type, context)(schemaType.prototype, field.name);
                        }
                    });
                });
                var rootType = schemaTypes[reflection.rootType];
                var rootInstance = new rootType();
                /**
                 * auto-initialize referenced types on root type
                 * to allow registering listeners immediatelly on client-side
                 */
                for (var fieldName in rootType._definition.schema) {
                    var fieldType = rootType._definition.schema[fieldName];
                    if (typeof (fieldType) !== "string") {
                        rootInstance[fieldName] = (typeof (fieldType) === "function")
                            ? new fieldType() // is a schema reference
                            : new (getType(Object.keys(fieldType)[0])).constructor(); // is a "collection"
                    }
                }
                return rootInstance;
            };
            __decorate([
                type([ReflectionType], reflectionContext)
            ], Reflection.prototype, "types", void 0);
            __decorate([
                type("number", reflectionContext)
            ], Reflection.prototype, "rootType", void 0);
            return Reflection;
        }(Schema));

        registerType("map", { constructor: MapSchema, getProxy: getMapProxy });
        registerType("array", { constructor: ArraySchema, getProxy: getArrayProxy });
        registerType("set", { constructor: SetSchema });
        registerType("collection", { constructor: CollectionSchema, });

        exports.ArraySchema = ArraySchema;
        exports.CollectionSchema = CollectionSchema;
        exports.Context = Context;
        exports.MapSchema = MapSchema;
        exports.Reflection = Reflection;
        exports.ReflectionField = ReflectionField;
        exports.ReflectionType = ReflectionType;
        exports.Schema = Schema;
        exports.SchemaDefinition = SchemaDefinition;
        exports.SetSchema = SetSchema;
        exports.decode = decode;
        exports.defineTypes = defineTypes;
        exports.deprecated = deprecated;
        exports.dumpChanges = dumpChanges;
        exports.encode = encode;
        exports.filter = filter;
        exports.filterChildren = filterChildren;
        exports.hasFilter = hasFilter;
        exports.registerType = registerType;
        exports.type = type;

        Object.defineProperty(exports, '__esModule', { value: true });

    })));
    });

    var Room = /** @class */ (function () {
        function Room(name, rootSchema) {
            var _this = this;
            // Public signals
            this.onStateChange = createSignal();
            this.onError = createSignal();
            this.onLeave = createSignal();
            this.onJoin = createSignal();
            this.hasJoined = false;
            this.onMessageHandlers = createNanoEvents();
            this.id = null;
            this.name = name;
            if (rootSchema) {
                this.serializer = new (getSerializer("schema"));
                this.rootSchema = rootSchema;
                this.serializer.state = new rootSchema();
            }
            this.onError(function (code, message) { return console.warn("colyseus.js - onError => (" + code + ") " + message); });
            this.onLeave(function () { return _this.removeAllListeners(); });
        }
        Room.prototype.connect = function (endpoint) {
            var _this = this;
            this.connection = new Connection();
            this.connection.events.onmessage = this.onMessageCallback.bind(this);
            this.connection.events.onclose = function (e) {
                if (!_this.hasJoined) {
                    console.warn("Room connection was closed unexpectedly (" + e.code + "): " + e.reason);
                    _this.onError.invoke(e.code, e.reason);
                    return;
                }
                _this.onLeave.invoke(e.code);
                _this.destroy();
            };
            this.connection.events.onerror = function (e) {
                console.warn("Room, onError (" + e.code + "): " + e.reason);
                _this.onError.invoke(e.code, e.reason);
            };
            this.connection.connect(endpoint);
        };
        Room.prototype.leave = function (consented) {
            var _this = this;
            if (consented === void 0) { consented = true; }
            return new Promise(function (resolve) {
                _this.onLeave(function (code) { return resolve(code); });
                if (_this.connection) {
                    if (consented) {
                        _this.connection.send([exports.Protocol.LEAVE_ROOM]);
                    }
                    else {
                        _this.connection.close();
                    }
                }
                else {
                    _this.onLeave.invoke(4000); // "consented" code
                }
            });
        };
        Room.prototype.onMessage = function (type, callback) {
            return this.onMessageHandlers.on(this.getMessageHandlerKey(type), callback);
        };
        Room.prototype.send = function (type, message) {
            var initialBytes = [exports.Protocol.ROOM_DATA];
            if (typeof (type) === "string") {
                umd.encode.string(initialBytes, type);
            }
            else {
                umd.encode.number(initialBytes, type);
            }
            var arr;
            if (message !== undefined) {
                var encoded = encode(message);
                arr = new Uint8Array(initialBytes.length + encoded.byteLength);
                arr.set(new Uint8Array(initialBytes), 0);
                arr.set(new Uint8Array(encoded), initialBytes.length);
            }
            else {
                arr = new Uint8Array(initialBytes);
            }
            this.connection.send(arr.buffer);
        };
        Object.defineProperty(Room.prototype, "state", {
            get: function () {
                return this.serializer.getState();
            },
            enumerable: false,
            configurable: true
        });
        Room.prototype.removeAllListeners = function () {
            this.onJoin.clear();
            this.onStateChange.clear();
            this.onError.clear();
            this.onLeave.clear();
            this.onMessageHandlers.events = {};
        };
        Room.prototype.onMessageCallback = function (event) {
            var bytes = Array.from(new Uint8Array(event.data));
            var code = bytes[0];
            if (code === exports.Protocol.JOIN_ROOM) {
                var offset = 1;
                this.serializerId = utf8Read(bytes, offset);
                offset += utf8Length(this.serializerId);
                // Instantiate serializer if not locally available.
                if (!this.serializer) {
                    var serializer = getSerializer(this.serializerId);
                    this.serializer = new serializer();
                }
                if (bytes.length > offset && this.serializer.handshake) {
                    this.serializer.handshake(bytes, { offset: offset });
                }
                this.hasJoined = true;
                this.onJoin.invoke();
                // acknowledge successfull JOIN_ROOM
                this.connection.send([exports.Protocol.JOIN_ROOM]);
            }
            else if (code === exports.Protocol.ERROR) {
                var it_1 = { offset: 1 };
                var code_1 = umd.decode.number(bytes, it_1);
                var message = umd.decode.string(bytes, it_1);
                this.onError.invoke(code_1, message);
            }
            else if (code === exports.Protocol.LEAVE_ROOM) {
                this.leave();
            }
            else if (code === exports.Protocol.ROOM_DATA_SCHEMA) {
                var it_2 = { offset: 1 };
                var context_1 = this.serializer.getState().constructor._context;
                var type = context_1.get(umd.decode.number(bytes, it_2));
                var message = new type();
                message.decode(bytes, it_2);
                this.dispatchMessage(type, message);
            }
            else if (code === exports.Protocol.ROOM_STATE) {
                bytes.shift(); // drop `code` byte
                this.setState(bytes);
            }
            else if (code === exports.Protocol.ROOM_STATE_PATCH) {
                bytes.shift(); // drop `code` byte
                this.patch(bytes);
            }
            else if (code === exports.Protocol.ROOM_DATA) {
                var it_3 = { offset: 1 };
                var type = (umd.decode.stringCheck(bytes, it_3))
                    ? umd.decode.string(bytes, it_3)
                    : umd.decode.number(bytes, it_3);
                var message = (bytes.length > it_3.offset)
                    ? decode(event.data, it_3.offset)
                    : undefined;
                this.dispatchMessage(type, message);
            }
        };
        Room.prototype.setState = function (encodedState) {
            this.serializer.setState(encodedState);
            this.onStateChange.invoke(this.serializer.getState());
        };
        Room.prototype.patch = function (binaryPatch) {
            this.serializer.patch(binaryPatch);
            this.onStateChange.invoke(this.serializer.getState());
        };
        Room.prototype.dispatchMessage = function (type, message) {
            var messageType = this.getMessageHandlerKey(type);
            if (this.onMessageHandlers.events[messageType]) {
                this.onMessageHandlers.emit(messageType, message);
            }
            else if (this.onMessageHandlers.events['*']) {
                this.onMessageHandlers.emit('*', type, message);
            }
            else {
                console.warn("colyseus.js: onMessage() not registered for type '" + type + "'.");
            }
        };
        Room.prototype.destroy = function () {
            if (this.serializer) {
                this.serializer.teardown();
            }
        };
        Room.prototype.getMessageHandlerKey = function (type) {
            switch (typeof (type)) {
                // typeof Schema
                case "function": return "$" + type._typeid;
                // string
                case "string": return type;
                // number
                case "number": return "i" + type;
                default: throw new Error("invalid message type.");
            }
        };
        return Room;
    }());

    /// <reference path="../typings/cocos-creator.d.ts" />
    /**
     * We do not assign 'storage' to window.localStorage immediatelly for React
     * Native compatibility. window.localStorage is not present when this module is
     * loaded.
     */
    var storage;
    function getStorage() {
        if (!storage) {
            storage = (typeof (cc) !== 'undefined' && cc.sys && cc.sys.localStorage)
                ? cc.sys.localStorage // compatibility with cocos creator
                : typeof (window) !== "undefined" && window.localStorage //RN does have window object at this point, but localStorage is not defined
                    ? window.localStorage // regular browser environment
                    : {
                        cache: {},
                        setItem: function (key, value) { this.cache[key] = value; },
                        getItem: function (key) { this.cache[key]; },
                        removeItem: function (key) { delete this.cache[key]; },
                    };
        }
        return storage;
    }
    function setItem(key, value) {
        getStorage().setItem(key, value);
    }
    function removeItem(key) {
        getStorage().removeItem(key);
    }
    function getItem(key, callback) {
        var value = getStorage().getItem(key);
        if (typeof (Promise) === 'undefined' || // old browsers
            !(value instanceof Promise)) {
            // browser has synchronous return
            callback(value);
        }
        else {
            // react-native is asynchronous
            value.then(function (id) { return callback(id); });
        }
    }

    var TOKEN_STORAGE = "colyseus-auth-token";
    exports.Platform = void 0;
    (function (Platform) {
        Platform["ios"] = "ios";
        Platform["android"] = "android";
    })(exports.Platform || (exports.Platform = {}));
    var Auth = /** @class */ (function () {
        function Auth(endpoint) {
            var _this = this;
            this._id = undefined;
            this.username = undefined;
            this.displayName = undefined;
            this.avatarUrl = undefined;
            this.isAnonymous = undefined;
            this.email = undefined;
            this.lang = undefined;
            this.location = undefined;
            this.timezone = undefined;
            this.metadata = undefined;
            this.devices = undefined;
            this.facebookId = undefined;
            this.twitterId = undefined;
            this.googleId = undefined;
            this.gameCenterId = undefined;
            this.steamId = undefined;
            this.friendIds = undefined;
            this.blockedUserIds = undefined;
            this.createdAt = undefined;
            this.updatedAt = undefined;
            // auth token
            this.token = undefined;
            this.endpoint = endpoint.replace("ws", "http");
            getItem(TOKEN_STORAGE, function (token) { return _this.token = token; });
        }
        Object.defineProperty(Auth.prototype, "hasToken", {
            get: function () {
                return !!this.token;
            },
            enumerable: false,
            configurable: true
        });
        Auth.prototype.login = function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var queryParams, data, attr;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            queryParams = Object.assign({}, options);
                            if (this.hasToken) {
                                queryParams.token = this.token;
                            }
                            return [4 /*yield*/, this.request('post', '/auth', queryParams)];
                        case 1:
                            data = _a.sent();
                            // set & cache token
                            this.token = data.token;
                            setItem(TOKEN_STORAGE, this.token);
                            for (attr in data) {
                                if (this.hasOwnProperty(attr)) {
                                    this[attr] = data[attr];
                                }
                            }
                            this.registerPingService();
                            return [2 /*return*/, this];
                    }
                });
            });
        };
        Auth.prototype.save = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('put', '/auth', {}, {
                                username: this.username,
                                displayName: this.displayName,
                                avatarUrl: this.avatarUrl,
                                lang: this.lang,
                                location: this.location,
                                timezone: this.timezone,
                            })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, this];
                    }
                });
            });
        };
        Auth.prototype.getFriends = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('get', '/friends/all')];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.getOnlineFriends = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('get', '/friends/online')];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.getFriendRequests = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('get', '/friends/requests')];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.sendFriendRequest = function (friendId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('post', '/friends/requests', { userId: friendId })];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.acceptFriendRequest = function (friendId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('put', '/friends/requests', { userId: friendId })];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.declineFriendRequest = function (friendId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('del', '/friends/requests', { userId: friendId })];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.blockUser = function (friendId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('post', '/friends/block', { userId: friendId })];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.unblockUser = function (friendId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('put', '/friends/block', { userId: friendId })];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.request = function (method, segments, query, body, headers) {
            if (query === void 0) { query = {}; }
            if (headers === void 0) { headers = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var queryParams, name_1, queryString, opts;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            headers['Accept'] = 'application/json';
                            if (this.hasToken) {
                                headers['Authorization'] = 'Bearer ' + this.token;
                            }
                            queryParams = [];
                            for (name_1 in query) {
                                queryParams.push(name_1 + "=" + query[name_1]);
                            }
                            queryString = (queryParams.length > 0)
                                ? "?" + queryParams.join("&")
                                : '';
                            opts = { headers: headers };
                            if (body) {
                                opts.body = body;
                            }
                            return [4 /*yield*/, http[method]("" + this.endpoint + segments + queryString, opts)];
                        case 1: return [2 /*return*/, (_a.sent()).data];
                    }
                });
            });
        };
        Auth.prototype.logout = function () {
            this.token = undefined;
            removeItem(TOKEN_STORAGE);
            this.unregisterPingService();
        };
        Auth.prototype.registerPingService = function (timeout) {
            var _this = this;
            if (timeout === void 0) { timeout = 15000; }
            this.unregisterPingService();
            this.keepOnlineInterval = setInterval(function () { return _this.request('get', '/auth'); }, timeout);
        };
        Auth.prototype.unregisterPingService = function () {
            clearInterval(this.keepOnlineInterval);
        };
        return Auth;
    }());

    var _a;
    var MatchMakeError = /** @class */ (function (_super) {
        __extends(MatchMakeError, _super);
        function MatchMakeError(message, code) {
            var _this = _super.call(this, message) || this;
            _this.code = code;
            Object.setPrototypeOf(_this, MatchMakeError.prototype);
            return _this;
        }
        return MatchMakeError;
    }(Error));
    // - React Native does not provide `window.location`
    // - Cocos Creator (Native) does not provide `window.location.hostname` 
    var DEFAULT_ENDPOINT = (typeof (window) !== "undefined" && typeof ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hostname) !== "undefined")
        ? window.location.protocol.replace("http", "ws") + "//" + window.location.hostname + (window.location.port && ":" + window.location.port)
        : "ws://127.0.0.1:2567";
    var Client = /** @class */ (function () {
        function Client(endpoint) {
            if (endpoint === void 0) { endpoint = DEFAULT_ENDPOINT; }
            this.endpoint = endpoint;
        }
        Object.defineProperty(Client.prototype, "auth", {
            get: function () {
                if (!this._auth) {
                    this._auth = new Auth(this.endpoint);
                }
                return this._auth;
            },
            enumerable: false,
            configurable: true
        });
        Client.prototype.joinOrCreate = function (roomName, options, rootSchema) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('joinOrCreate', roomName, options, rootSchema)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Client.prototype.create = function (roomName, options, rootSchema) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('create', roomName, options, rootSchema)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Client.prototype.join = function (roomName, options, rootSchema) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('join', roomName, options, rootSchema)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Client.prototype.joinById = function (roomId, options, rootSchema) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('joinById', roomId, options, rootSchema)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Client.prototype.reconnect = function (roomId, sessionId, rootSchema) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('joinById', roomId, { sessionId: sessionId }, rootSchema)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Client.prototype.getAvailableRooms = function (roomName) {
            if (roomName === void 0) { roomName = ""; }
            return __awaiter(this, void 0, void 0, function () {
                var url;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            url = this.endpoint.replace("ws", "http") + "/matchmake/" + roomName;
                            return [4 /*yield*/, get_1(url, { headers: { 'Accept': 'application/json' } })];
                        case 1: return [2 /*return*/, (_a.sent()).data];
                    }
                });
            });
        };
        Client.prototype.consumeSeatReservation = function (response, rootSchema) {
            return __awaiter(this, void 0, void 0, function () {
                var room;
                return __generator(this, function (_a) {
                    room = this.createRoom(response.room.name, rootSchema);
                    room.id = response.room.roomId;
                    room.sessionId = response.sessionId;
                    room.connect(this.buildEndpoint(response.room, { sessionId: room.sessionId }));
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            var onError = function (code, message) { return reject(new ServerError(code, message)); };
                            room.onError.once(onError);
                            room['onJoin'].once(function () {
                                room.onError.remove(onError);
                                resolve(room);
                            });
                        })];
                });
            });
        };
        Client.prototype.createMatchMakeRequest = function (method, roomName, options, rootSchema) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var url, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            url = this.endpoint.replace("ws", "http") + "/matchmake/" + method + "/" + roomName;
                            // automatically forward auth token, if present
                            if (this._auth && this._auth.hasToken) {
                                options.token = this._auth.token;
                            }
                            return [4 /*yield*/, post_1(url, {
                                    headers: {
                                        'Accept': 'application/json',
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify(options)
                                })];
                        case 1:
                            response = (_a.sent()).data;
                            if (response.error) {
                                throw new MatchMakeError(response.error, response.code);
                            }
                            return [2 /*return*/, this.consumeSeatReservation(response, rootSchema)];
                    }
                });
            });
        };
        Client.prototype.createRoom = function (roomName, rootSchema) {
            return new Room(roomName, rootSchema);
        };
        Client.prototype.buildEndpoint = function (room, options) {
            if (options === void 0) { options = {}; }
            var params = [];
            for (var name_1 in options) {
                if (!options.hasOwnProperty(name_1)) {
                    continue;
                }
                params.push(name_1 + "=" + options[name_1]);
            }
            return this.endpoint + "/" + room.processId + "/" + room.roomId + "?" + params.join('&');
        };
        return Client;
    }());

    var SchemaSerializer = /** @class */ (function () {
        function SchemaSerializer() {
        }
        SchemaSerializer.prototype.setState = function (rawState) {
            this.state.decode(rawState);
        };
        SchemaSerializer.prototype.getState = function () {
            return this.state;
        };
        SchemaSerializer.prototype.patch = function (patches) {
            this.state.decode(patches);
        };
        SchemaSerializer.prototype.teardown = function () {
            var _a, _b;
            (_b = (_a = this.state) === null || _a === void 0 ? void 0 : _a['$changes']) === null || _b === void 0 ? void 0 : _b.root.clearRefs();
        };
        SchemaSerializer.prototype.handshake = function (bytes, it) {
            if (this.state) {
                // validate client/server definitinos
                var reflection = new umd.Reflection();
                reflection.decode(bytes, it);
            }
            else {
                // initialize reflected state from server
                this.state = umd.Reflection.decode(bytes, it);
            }
        };
        return SchemaSerializer;
    }());

    var NoneSerializer = /** @class */ (function () {
        function NoneSerializer() {
        }
        NoneSerializer.prototype.setState = function (rawState) { };
        NoneSerializer.prototype.getState = function () { return null; };
        NoneSerializer.prototype.patch = function (patches) { };
        NoneSerializer.prototype.teardown = function () { };
        NoneSerializer.prototype.handshake = function (bytes) { };
        return NoneSerializer;
    }());

    registerSerializer('schema', SchemaSerializer);
    registerSerializer('none', NoneSerializer);

    exports.Auth = Auth;
    exports.Client = Client;
    exports.Room = Room;
    exports.SchemaSerializer = SchemaSerializer;
    exports.registerSerializer = registerSerializer;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=colyseus.js.map


/***/ }),

/***/ "../node_modules/kontra/kontra.mjs":
/*!*****************************************!*\
  !*** ../node_modules/kontra/kontra.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "Animation": () => (/* binding */ factory),
/* harmony export */   "Button": () => (/* binding */ factory$5),
/* harmony export */   "GameLoop": () => (/* binding */ GameLoop),
/* harmony export */   "GameObject": () => (/* binding */ factory$2),
/* harmony export */   "Grid": () => (/* binding */ factory$6),
/* harmony export */   "Pool": () => (/* binding */ factory$7),
/* harmony export */   "Quadtree": () => (/* binding */ factory$8),
/* harmony export */   "Scene": () => (/* binding */ factory$9),
/* harmony export */   "Sprite": () => (/* binding */ factory$3),
/* harmony export */   "SpriteSheet": () => (/* binding */ factory$a),
/* harmony export */   "Text": () => (/* binding */ factory$4),
/* harmony export */   "TileEngine": () => (/* binding */ TileEngine),
/* harmony export */   "Vector": () => (/* binding */ factory$1),
/* harmony export */   "angleToTarget": () => (/* binding */ angleToTarget),
/* harmony export */   "audioAssets": () => (/* binding */ audioAssets),
/* harmony export */   "bindKeys": () => (/* binding */ bindKeys),
/* harmony export */   "clamp": () => (/* binding */ clamp),
/* harmony export */   "collides": () => (/* binding */ collides),
/* harmony export */   "dataAssets": () => (/* binding */ dataAssets),
/* harmony export */   "degToRad": () => (/* binding */ degToRad),
/* harmony export */   "emit": () => (/* binding */ emit),
/* harmony export */   "extendObject": () => (/* binding */ extendObject),
/* harmony export */   "getCanvas": () => (/* binding */ getCanvas),
/* harmony export */   "getContext": () => (/* binding */ getContext),
/* harmony export */   "getPointer": () => (/* binding */ getPointer),
/* harmony export */   "getStoreItem": () => (/* binding */ getStoreItem),
/* harmony export */   "getWorldRect": () => (/* binding */ getWorldRect),
/* harmony export */   "imageAssets": () => (/* binding */ imageAssets),
/* harmony export */   "init": () => (/* binding */ init),
/* harmony export */   "initKeys": () => (/* binding */ initKeys),
/* harmony export */   "initPointer": () => (/* binding */ initPointer),
/* harmony export */   "inverseLerp": () => (/* binding */ inverseLerp),
/* harmony export */   "keyMap": () => (/* binding */ keyMap),
/* harmony export */   "keyPressed": () => (/* binding */ keyPressed),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "load": () => (/* binding */ load),
/* harmony export */   "loadAudio": () => (/* binding */ loadAudio),
/* harmony export */   "loadData": () => (/* binding */ loadData),
/* harmony export */   "loadImage": () => (/* binding */ loadImage),
/* harmony export */   "off": () => (/* binding */ off),
/* harmony export */   "on": () => (/* binding */ on),
/* harmony export */   "onPointerDown": () => (/* binding */ onPointerDown),
/* harmony export */   "onPointerUp": () => (/* binding */ onPointerUp),
/* harmony export */   "pointerOver": () => (/* binding */ pointerOver),
/* harmony export */   "pointerPressed": () => (/* binding */ pointerPressed),
/* harmony export */   "radToDeg": () => (/* binding */ radToDeg),
/* harmony export */   "randInt": () => (/* binding */ randInt),
/* harmony export */   "registerPlugin": () => (/* binding */ registerPlugin),
/* harmony export */   "rotatePoint": () => (/* binding */ rotatePoint),
/* harmony export */   "seedRand": () => (/* binding */ seedRand),
/* harmony export */   "setAudioPath": () => (/* binding */ setAudioPath),
/* harmony export */   "setDataPath": () => (/* binding */ setDataPath),
/* harmony export */   "setImagePath": () => (/* binding */ setImagePath),
/* harmony export */   "setStoreItem": () => (/* binding */ setStoreItem),
/* harmony export */   "track": () => (/* binding */ track),
/* harmony export */   "unbindKeys": () => (/* binding */ unbindKeys),
/* harmony export */   "unregisterPlugin": () => (/* binding */ unregisterPlugin),
/* harmony export */   "untrack": () => (/* binding */ untrack)
/* harmony export */ });
/**
 * A simple event system. Allows you to hook into Kontra lifecycle events or create your own, such as for [Plugins](api/plugin).
 *
 * ```js
 * import { on, off, emit } from 'kontra';
 *
 * function callback(a, b, c) {
 *   console.log({a, b, c});
 * });
 *
 * on('myEvent', callback);
 * emit('myEvent', 1, 2, 3);  //=> {a: 1, b: 2, c: 3}
 * off('myEvent', callback);
 * ```
 * @sectionName Events
 */

// expose for testing
let callbacks = {};

/**
 * There are currently only three lifecycle events:
 * - `init` - Emitted after `kontra.init()` is called.
 * - `tick` - Emitted every frame of [GameLoop](api/gameLoop) before the loops `update()` and `render()` functions are called.
 * - `assetLoaded` - Emitted after an asset has fully loaded using the asset loader. The callback function is passed the asset and the url of the asset as parameters.
 * @sectionName Lifecycle Events
 */

/**
 * Register a callback for an event to be called whenever the event is emitted. The callback will be passed all arguments used in the `emit` call.
 * @function on
 *
 * @param {String} event - Name of the event.
 * @param {Function} callback - Function that will be called when the event is emitted.
 */
function on(event, callback) {
  callbacks[event] = callbacks[event] || [];
  callbacks[event].push(callback);
}

/**
 * Remove a callback for an event.
 * @function off
 *
 * @param {String} event - Name of the event.
 * @param {Function} callback - The function that was passed during registration.
 */
function off(event, callback) {
  callbacks[event] = (callbacks[event] || []).filter(fn => fn != callback);
}

/**
 * Call all callback functions for the event. All arguments will be passed to the callback functions.
 * @function emit
 *
 * @param {String} event - Name of the event.
 * @param {...*} args - Comma separated list of arguments passed to all callbacks.
 */
function emit(event, ...args) {
  (callbacks[event] || []).map(fn => fn(...args));
}

/**
 * Functions for initializing the Kontra library and getting the canvas and context
 * objects.
 *
 * ```js
 * import { getCanvas, getContext, init } from 'kontra';
 *
 * let { canvas, context } = init();
 *
 * // or can get canvas and context through functions
 * canvas = getCanvas();
 * context = getContext();
 * ```
 * @sectionName Core
 */

let canvasEl, context;

/**
 * Return the canvas element.
 * @function getCanvas
 *
 * @returns {HTMLCanvasElement} The canvas element for the game.
 */
function getCanvas() {
  return canvasEl;
}

/**
 * Return the context object.
 * @function getContext
 *
 * @returns {CanvasRenderingContext2D} The context object the game draws to.
 */
function getContext() {
  return context;
}

/**
 * Initialize the library and set up the canvas. Typically you will call `init()` as the first thing and give it the canvas to use. This will allow all Kontra objects to reference the canvas when created.
 *
 * ```js
 * import { init } from 'kontra';
 *
 * let { canvas, context } = init('game');
 * ```
 * @function init
 *
 * @param {String|HTMLCanvasElement} [canvas] - The canvas for Kontra to use. Can either be the ID of the canvas element or the canvas element itself. Defaults to using the first canvas element on the page.
 *
 * @returns {{canvas: HTMLCanvasElement, context: CanvasRenderingContext2D}} An object with properties `canvas` and `context`. `canvas` it the canvas element for the game and `context` is the context object the game draws to.
 */
function init(canvas) {

  // check if canvas is a string first, an element next, or default to getting
  // first canvas on page
  canvasEl = document.getElementById(canvas) ||
             canvas ||
             document.querySelector('canvas');

  // @ifdef DEBUG
  if (!canvasEl) {
    throw Error('You must provide a canvas element for the game');
  }
  // @endif

  context = canvasEl.getContext('2d');
  context.imageSmoothingEnabled = false;

  emit('init');

  return { canvas: canvasEl, context };
}

/**
 * An object for drawing sprite sheet animations.
 *
 * An animation defines the sequence of frames to use from a sprite sheet. It also defines at what speed the animation should run using `frameRate`.
 *
 * Typically you don't create an Animation directly, but rather you would create them from a [SpriteSheet](api/spriteSheet) by passing the `animations` argument.
 *
 * ```js
 * import { SpriteSheet, Animation } from 'kontra';
 *
 * let image = new Image();
 * image.src = 'assets/imgs/character_walk_sheet.png';
 * image.onload = function() {
 *   let spriteSheet = SpriteSheet({
 *     image: image,
 *     frameWidth: 72,
 *     frameHeight: 97
 *   });
 *
 *   // you typically wouldn't create an Animation this way
 *   let animation = Animation({
 *     spriteSheet: spriteSheet,
 *     frames: [1,2,3,6],
 *     frameRate: 30
 *   });
 * };
 * ```
 * @class Animation
 *
 * @param {Object} properties - Properties of the animation.
 * @param {SpriteSheet} properties.spriteSheet - Sprite sheet for the animation.
 * @param {Number[]} properties.frames - List of frames of the animation.
 * @param {Number}  properties.frameRate - Number of frames to display in one second.
 * @param {Boolean} [properties.loop=true] - If the animation should loop.
 */
class Animation {
  constructor({spriteSheet, frames, frameRate, loop = true}) {

    /**
     * The sprite sheet to use for the animation.
     * @memberof Animation
     * @property {SpriteSheet} spriteSheet
     */
    this.spriteSheet = spriteSheet;

    /**
     * Sequence of frames to use from the sprite sheet.
     * @memberof Animation
     * @property {Number[]} frames
     */
    this.frames = frames;

    /**
     * Number of frames to display per second. Adjusting this value will change the speed of the animation.
     * @memberof Animation
     * @property {Number} frameRate
     */
    this.frameRate = frameRate;

    /**
     * If the animation should loop back to the beginning once completed.
     * @memberof Animation
     * @property {Boolean} loop
     */
    this.loop = loop;

    let { width, height, margin = 0 } = spriteSheet.frame;

    /**
     * The width of an individual frame. Taken from the [frame width value](api/spriteSheet#frame) of the sprite sheet.
     * @memberof Animation
     * @property {Number} width
     */
    this.width = width;

    /**
     * The height of an individual frame. Taken from the [frame height value](api/spriteSheet#frame) of the sprite sheet.
     * @memberof Animation
     * @property {Number} height
     */
    this.height = height;

    /**
     * The space between each frame. Taken from the [frame margin value](api/spriteSheet#frame) of the sprite sheet.
     * @memberof Animation
     * @property {Number} margin
     */
    this.margin = margin;

    // f = frame, a = accumulator
    this._f = 0;
    this._a = 0;
  }

  /**
   * Clone an animation so it can be used more than once. By default animations passed to [Sprite](api/sprite) will be cloned so no two sprites update the same animation. Otherwise two sprites who shared the same animation would make it update twice as fast.
   * @memberof Animation
   * @function clone
   *
   * @returns {Animation} A new Animation instance.
   */
  clone() {
    return new Animation(this);
  }

  /**
   * Reset an animation to the first frame.
   * @memberof Animation
   * @function reset
   */
  reset() {
    this._f = 0;
    this._a = 0;
  }

  /**
   * Update the animation.
   * @memberof Animation
   * @function update
   *
   * @param {Number} [dt=1/60] - Time since last update.
   */
  update(dt = 1/60) {

    // if the animation doesn't loop we stop at the last frame
    if (!this.loop && this._f == this.frames.length-1) return;

    this._a += dt;

    // update to the next frame if it's time
    while (this._a * this.frameRate >= 1) {
      this._f = ++this._f % this.frames.length;
      this._a -= 1 / this.frameRate;
    }
  }

  /**
   * Draw the current frame of the animation.
   * @memberof Animation
   * @function render
   *
   * @param {Object} properties - Properties to draw the animation.
   * @param {Number} properties.x - X position to draw the animation.
   * @param {Number} properties.y - Y position to draw the animation.
   * @param {Number} [properties.width] - width of the sprite. Defaults to [Animation.width](api/animation#width).
   * @param {Number} [properties.height] - height of the sprite. Defaults to [Animation.height](api/animation#height).
   * @param {CanvasRenderingContext2D} [properties.context] - The context the animation should draw to. Defaults to [core.getContext()](api/core#getContext).
   */
  render({x, y, width = this.width, height = this.height, context = getContext()}) {

    // get the row and col of the frame
    let row = this.frames[this._f] / this.spriteSheet._f | 0;
    let col = this.frames[this._f] % this.spriteSheet._f | 0;

    context.drawImage(
      this.spriteSheet.image,
      col * this.width + (col * 2 + 1) * this.margin,
      row * this.height + (row * 2 + 1) * this.margin,
      this.width, this.height,
      x, y,
      width, height
    );
  }
}

function factory() {
  return new Animation(...arguments);
}
factory.prototype = Animation.prototype;
factory.class = Animation;

/**
 * A promise based asset loader for loading images, audio, and data files. An `assetLoaded` event is emitted after each asset is fully loaded. The callback for the event is passed the asset and the url to the asset as parameters.
 *
 * ```js
 * import { load, on } from 'kontra';
 *
 * let numAssets = 3;
 * let assetsLoaded = 0;
 * on('assetLoaded', (asset, url) => {
 *   assetsLoaded++;
 *
 *   // inform user or update progress bar
 * });
 *
 * load(
 *   'assets/imgs/character.png',
 *   'assets/data/tile_engine_basic.json',
 *   ['/audio/music.ogg', '/audio/music.mp3']
 * ).then(function(assets) {
 *   // all assets have loaded
 * }).catch(function(err) {
 *   // error loading an asset
 * });
 * ```
 * @sectionName Assets
 */

let imageRegex = /(jpeg|jpg|gif|png|webp)$/;
let audioRegex = /(wav|mp3|ogg|aac)$/;
let leadingSlash = /^\//;
let trailingSlash = /\/$/;
let dataMap = new WeakMap();

let imagePath = '';
let audioPath = '';
let dataPath = '';

/**
 * Get the full URL from the base.
 *
 * @param {String} url - The URL to the asset.
 * @param {String} base - Base URL.
 *
 * @returns {String}
 */
function getUrl(url, base) {
  return new URL(url, base).href;
}

/**
 * Join a base path and asset path.
 *
 * @param {String} base - The asset base path.
 * @param {String} url - The URL to the asset.
 *
 * @returns {String}
 */
function joinPath(base, url) {
  return [base.replace(trailingSlash, ''), base ? url.replace(leadingSlash, '') : url]
    .filter(s => s)
    .join('/')
}

/**
 * Get the extension of an asset.
 *
 * @param {String} url - The URL to the asset.
 *
 * @returns {String}
 */
function getExtension(url) {
  return url.split('.').pop();
}

/**
 * Get the name of an asset.
 *
 * @param {String} url - The URL to the asset.
 *
 * @returns {String}
 */
function getName(url) {
  let name = url.replace('.' + getExtension(url), '');

  // remove leading slash if there is no folder in the path
  // @see https://stackoverflow.com/a/50592629/2124254
  return name.split('/').length == 2 ? name.replace(leadingSlash, '') : name;
}

/**
 * Get browser audio playability.
 * @see https://github.com/Modernizr/Modernizr/blob/master/feature-detects/audio.js
 *
 * @param {HTMLMediaElement} audio - Audio element.
 *
 * @returns {object}
 */
function getCanPlay(audio) {
  return {
    wav: audio.canPlayType('audio/wav; codecs="1"'),
    mp3: audio.canPlayType('audio/mpeg;'),
    ogg: audio.canPlayType('audio/ogg; codecs="vorbis"'),
    aac: audio.canPlayType('audio/aac;')
  };
}

/**
 * Object of all loaded image assets by both file name and path. If the base [image path](api/assets#setImagePath) was set before the image was loaded, the file name and path will not include the base image path.
 *
 * ```js
 * import { load, setImagePath, imageAssets } from 'kontra';
 *
 * load('assets/imgs/character.png').then(function() {
 *   // Image asset can be accessed by both
 *   // name: imageAssets['assets/imgs/character']
 *   // path: imageAssets['assets/imgs/character.png']
 * });
 *
 * setImagePath('assets/imgs');
 * load('character_walk_sheet.png').then(function() {
 *   // Image asset can be accessed by both
 *   // name: imageAssets['character_walk_sheet']
 *   // path: imageAssets['character_walk_sheet.png']
 * });
 * ```
 * @property {{[name: String]: HTMLImageElement}} imageAssets
 */
let imageAssets = {};

/**
 * Object of all loaded audio assets by both file name and path. If the base [audio path](api/assets#setAudioPath) was set before the audio was loaded, the file name and path will not include the base audio path.
 *
 * ```js
 * import { load, setAudioPath, audioAssets } from 'kontra';
 *
 * load('/audio/music.ogg').then(function() {
 *   // Audio asset can be accessed by both
 *   // name: audioAssets['/audio/music']
 *   // path: audioAssets['/audio/music.ogg']
 * });
 *
 * setAudioPath('/audio');
 * load('sound.ogg').then(function() {
 *   // Audio asset can be accessed by both
 *   // name: audioAssets['sound']
 *   // path: audioAssets['sound.ogg']
 * });
 * ```
 * @property {{[name: String]: HTMLAudioElement}} audioAssets
 */
let audioAssets = {};

/**
 * Object of all loaded data assets by both file name and path. If the base [data path](api/assets#setDataPath) was set before the data was loaded, the file name and path will not include the base data path.
 *
 * ```js
 * import { load, setDataPath, dataAssets } from 'kontra';
 *
 * load('assets/data/file.txt').then(function() {
 *   // Audio asset can be accessed by both
 *   // name: dataAssets['assets/data/file']
 *   // path: dataAssets['assets/data/file.txt']
 * });
 *
 * setDataPath('assets/data');
 * load('info.json').then(function() {
 *   // Audio asset can be accessed by both
 *   // name: dataAssets['info']
 *   // path: dataAssets['info.json']
 * });
 * ```
 * @property {{[name: String]: any}} dataAssets
 */
let dataAssets = {};

/**
 * Add a global kontra object so TileEngine can access information about the
 * loaded assets when kontra is loaded in parts rather than as a whole (e.g.
 * `import { load, TileEngine } from 'kontra';`)
 */
function addGlobal() {
  if (!window.__k) {
    window.__k = {
      dm: dataMap,
      u: getUrl,
      d: dataAssets,
      i: imageAssets
    };
  }
}

/**
 * Sets the base path for all image assets. If a base path is set, all load calls for image assets will prepend the base path to the URL.
 *
 * ```js
 * import { setImagePath, load } from 'kontra';
 *
 * setImagePath('/imgs');
 * load('character.png');  // loads '/imgs/character.png'
 * ```
 * @function setImagePath
 *
 * @param {String} path - Base image path.
 */
function setImagePath(path) {
  imagePath = path;
}

/**
 * Sets the base path for all audio assets. If a base path is set, all load calls for audio assets will prepend the base path to the URL.
 *
 * ```js
 * import { setAudioPath, load } from 'kontra';
 *
 * setAudioPath('/audio');
 * load('music.ogg');  // loads '/audio/music.ogg'
 * ```
 * @function setAudioPath
 *
 * @param {String} path - Base audio path.
 */
function setAudioPath(path) {
  audioPath = path;
}

/**
 * Sets the base path for all data assets. If a base path is set, all load calls for data assets will prepend the base path to the URL.
 *
 * ```js
 * import { setDataPath, load } from 'kontra';
 *
 * setDataPath('/data');
 * load('file.json');  // loads '/data/file.json'
 * ```
 * @function setDataPath
 *
 * @param {String} path - Base data path.
 */
function setDataPath(path) {
  dataPath = path;
}

/**
 * Load a single Image asset. Uses the base [image path](api/assets#setImagePath) to resolve the URL.
 *
 * Once loaded, the asset will be accessible on the the [imageAssets](api/assets#imageAssets) property.
 *
 * ```js
 * import { loadImage } from 'kontra';
 *
 * loadImage('car.png').then(function(image) {
 *   console.log(image.src);  //=> 'car.png'
 * })
 * ```
 * @function loadImage
 *
 * @param {String} url - The URL to the Image file.
 *
 * @returns {Promise<HTMLImageElement>} A deferred promise. Promise resolves with the Image.
 */
function loadImage(url) {
  addGlobal();

  return new Promise((resolve, reject) => {
    let resolvedUrl, image, fullUrl;

    resolvedUrl = joinPath(imagePath, url);
    if (imageAssets[resolvedUrl]) return resolve(imageAssets[resolvedUrl]);

    image = new Image();

    image.onload = function loadImageOnLoad() {
      fullUrl = getUrl(resolvedUrl, window.location.href);
      imageAssets[ getName(url) ] = imageAssets[resolvedUrl] = imageAssets[fullUrl] = this;
      emit('assetLoaded', this, url);
      resolve(this);
    };

    image.onerror = function loadImageOnError() {
      reject(/* @ifdef DEBUG */ 'Unable to load image ' + /* @endif */ resolvedUrl);
    };

    image.src = resolvedUrl;
  });
}

/**
 * Load a single Audio asset. Supports loading multiple audio formats which the loader will use to load the first audio format supported by the browser in the order listed. Uses the base [audio path](api/assets#setAudioPath) to resolve the URL.
 *
 * Once loaded, the asset will be accessible on the the [audioAssets](api/assets#audioAssets) property. Since the loader determines which audio asset to load based on browser support, you should only reference the audio by its name and not by its file path since there's no guarantee which asset was loaded.
 *
 * ```js
 * import { loadAudio, audioAssets } from 'kontra';
 *
 * loadAudio([
 *   '/audio/music.mp3',
 *   '/audio/music.ogg'
 * ]).then(function(audio) {
 *
 *   // access audio by its name only (not by its .mp3 or .ogg path)
 *   audioAssets['/audio/music'].play();
 * })
 * ```
 * @function loadAudio
 *
 * @param {String} url - The URL to the Audio file.
 *
 * @returns {Promise<HTMLAudioElement>} A deferred promise. Promise resolves with the Audio.
 */
function loadAudio(url) {
  return new Promise((resolve, reject) => {
    let _url = url, audioEl, canPlay, resolvedUrl, fullUrl;

    audioEl = new Audio();
    canPlay = getCanPlay(audioEl);

    // determine the first audio format the browser can play
    url = [].concat(url)
            .reduce((playableSource, source) => playableSource
              ? playableSource
              : canPlay[ getExtension(source) ]
                ? source
                : null
            , 0);  // 0 is the shortest falsy value

    if (!url) {
      return reject(/* @ifdef DEBUG */ 'cannot play any of the audio formats provided ' + /* @endif */ _url);
    }

    resolvedUrl = joinPath(audioPath, url);
    if (audioAssets[resolvedUrl]) return resolve(audioAssets[resolvedUrl]);

    audioEl.addEventListener('canplay', function loadAudioOnLoad() {
      fullUrl = getUrl(resolvedUrl, window.location.href);
      audioAssets[ getName(url) ] = audioAssets[resolvedUrl] = audioAssets[fullUrl] = this;
      emit('assetLoaded', this, url);
      resolve(this);
    });

    audioEl.onerror = function loadAudioOnError() {
      reject(/* @ifdef DEBUG */ 'Unable to load audio ' + /* @endif */ resolvedUrl);
    };

    audioEl.src = resolvedUrl;
    audioEl.load();
  });
}

/**
 * Load a single Data asset. Uses the base [data path](api/assets#setDataPath) to resolve the URL.
 *
 * Once loaded, the asset will be accessible on the the [dataAssets](api/assets#dataAssets) property.
 *
 * ```js
 * import { loadData } from 'kontra';
 *
 * loadData('assets/data/tile_engine_basic.json').then(function(data) {
 *   // data contains the parsed JSON data
 * })
 * ```
 * @function loadData
 *
 * @param {String} url - The URL to the Data file.
 *
 * @returns {Promise} A deferred promise. Promise resolves with the contents of the file. If the file is a JSON file, the contents will be parsed as JSON.
 */
function loadData(url) {
  addGlobal();
  let resolvedUrl, fullUrl;

  resolvedUrl = joinPath(dataPath, url);
  if (dataAssets[resolvedUrl]) return Promise.resolve(dataAssets[resolvedUrl]);

  return fetch(resolvedUrl).then(response => {
    if (!response.ok) throw response;
    return response.clone().json().catch(() => response.text())
  }).then(response => {
    fullUrl = getUrl(resolvedUrl, window.location.href);
    if (typeof response === 'object') {
      dataMap.set(response, fullUrl);
    }

    dataAssets[ getName(url) ] = dataAssets[resolvedUrl] = dataAssets[fullUrl] = response;
    emit('assetLoaded', response, url);
    return response;
  });
}

/**
 * Load Image, Audio, or data files. Uses the [loadImage](api/assets#loadImage), [loadAudio](api/assets#loadAudio), and [loadData](api/assets#loadData) functions to load each asset type.
 *
 * ```js
 * import { load } from 'kontra';
 *
 * load(
 *   'assets/imgs/character.png',
 *   'assets/data/tile_engine_basic.json',
 *   ['/audio/music.ogg', '/audio/music.mp3']
 * ).then(function(assets) {
 *   // all assets have loaded
 * }).catch(function(err) {
 *   // error loading an asset
 * });
 * ```
 * @function load
 *
 * @param {...String[]} urls - Comma separated list of asset urls to load.
 *
 * @returns {Promise<any[]>} A deferred promise. Resolves with all the loaded assets.
 */
function load(...urls) {
  addGlobal();

  return Promise.all(
    urls.map(asset => {
      // account for a string or an array for the url
      let extension = getExtension( [].concat(asset)[0] );

      return extension.match(imageRegex)
        ? loadImage(asset)
        : extension.match(audioRegex)
          ? loadAudio(asset)
          : loadData(asset);
    })
  );
}

/**
 * A group of helpful functions that are commonly used for game development. Includes things such as converting between radians and degrees and getting random integers.
 *
 * ```js
 * import { degToRad } from 'kontra';
 *
 * let radians = degToRad(180);  // => 3.14
 * ```
 * @sectionName Helpers
 */

/**
 * Convert degrees to radians.
 * @function degToRad
 *
 * @param {Number} deg - Degrees to convert.
 *
 * @returns {Number} The value in radians.
 */
function degToRad(deg) {
  return deg * Math.PI / 180;
}

/**
 * Convert radians to degrees.
 * @function radToDeg
 *
 * @param {Number} rad - Radians to convert.
 *
 * @returns {Number} The value in degrees.
 */
function radToDeg(rad) {
  return rad * 180 / Math.PI;
}

/**
 * Return the angle in radians from one point to another point.
 *
 * ```js
 * import { angleToTarget, Sprite } from 'kontra';
 *
 * let sprite = Sprite({
 *   x: 10,
 *   y: 10,
 *   width: 20,
 *   height: 40,
 *   color: 'blue'
 * });
 *
 * sprite.rotation = angleToTarget(sprite, {x: 100, y: 30});
 *
 * let sprite2 = Sprite({
 *   x: 100,
 *   y: 30,
 *   width: 20,
 *   height: 40,
 *   color: 'red',
 * });
 *
 * sprite2.rotation = angleToTarget(sprite2, sprite);
 * ```
 * @function angleToTarget
 *
 * @param {{x: Number, y: Number}} source - The {x,y} source point.
 * @param {{x: Number, y: Number}} target - The {x,y} target point.
 *
 * @returns {Number} Angle (in radians) from the source point to the target point.
 */
function angleToTarget(source, target) {

  // atan2 returns the counter-clockwise angle in respect to the x-axis, but
  // the canvas rotation system is based on the y-axis (rotation of 0 = up).
  // so we need to add a quarter rotation to return a counter-clockwise
  // rotation in respect to the y-axis
  return Math.atan2(target.y - source.y, target.x - source.x) + Math.PI / 2;
}

/**
 * Rotate a point by an angle.
 * @function rotatePoint
 *
 * @param {{x: Number, y: Number}} point - The {x,y} point to rotate.
 * @param {Number} angle - Angle (in radians) to rotate.
 *
 * @returns {{x: Number, y: Number}} The new x and y coordinates after rotation.
 */
function rotatePoint(point, angle) {
  let sin = Math.sin(angle);
  let cos = Math.cos(angle);
  let x = point.x * cos - point.y * sin;
  let y = point.x * sin + point.y * cos;

  return {x, y};
}

/**
 * Return a random integer between a minimum (inclusive) and maximum (inclusive) integer.
 * @see https://stackoverflow.com/a/1527820/2124254
 * @function randInt
 *
 * @param {Number} min - Min integer.
 * @param {Number} max - Max integer.
 *
 * @returns {Number} Random integer between min and max values.
 */
function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Create a seeded random number generator.
 *
 * ```js
 * import { seedRand } from 'kontra';
 *
 * let rand = seedRand('kontra');
 * console.log(rand());  // => always 0.33761959057301283
 * ```
 * @see https://stackoverflow.com/a/47593316/2124254
 * @see https://github.com/bryc/code/blob/master/jshash/PRNGs.md
 *
 * @function seedRand
 *
 * @param {String} str - String to seed the random number generator.
 *
 * @returns {() => Number} Seeded random number generator function.
 */
 function seedRand(str) {
  // based on the above references, this was the smallest code yet decent
  // quality seed random function

  // first create a suitable hash of the seed string using xfnv1a
  // @see https://github.com/bryc/code/blob/master/jshash/PRNGs.md#addendum-a-seed-generating-functions
  for(var i = 0, h = 2166136261 >>> 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 16777619);
  }
  h += h << 13; h ^= h >>> 7;
  h += h << 3;  h ^= h >>> 17;
  let seed = (h += h << 5) >>> 0;

  // then return the seed function and discard the first result
  // @see https://github.com/bryc/code/blob/master/jshash/PRNGs.md#lcg-lehmer-rng
  let rand = () => (2 ** 31 - 1 & (seed = Math.imul(48271, seed))) / 2 ** 31;
  rand();
  return rand;
}

/**
 * Linearly interpolate between two values. The function calculates the number between two values based on a percent. Great for smooth transitions.
 *
 * ```js
 * import { lerp } from 'kontra';
 *
 * console.log( lerp(10, 20, 0.5) );  // => 15
 * console.log( lerp(10, 20, 2) );  // => 30
 * ```
 * @function lerp
 *
 * @param {Number} start - Start value.
 * @param {Number} end - End value.
 * @param {Number} percent - Percent to interpolate.
 *
 * @returns {Number} Interpolated number between the start and end values
 */
function lerp(start, end, percent) {
  return start * (1 - percent) + end * percent;
}

/**
 * Return the linear interpolation percent between two values. The function calculates the percent between two values of a given value.
 *
 * ```js
 * import { inverseLerp } from 'kontra';
 *
 * console.log( inverseLerp(10, 20, 15) );  // => 0.5
 * console.log( inverseLerp(10, 20, 30) );  // => 2
 * ```
 * @function inverseLerp
 *
 * @param {Number} start - Start value.
 * @param {Number} end - End value.
 * @param {Number} value - Value between start and end.
 *
 * @returns {Number} Percent difference between the start and end values.
 */
function inverseLerp(start, end, value) {
  return (value - start) / (end - start);
}

/**
 * Clamp a number between two values, preventing it from going below or above the minimum and maximum values.
 * @function clamp
 *
 * @param {Number} min - Min value.
 * @param {Number} max - Max value.
 * @param {Number} value - Value to clamp.
 *
 * @returns {Number} Value clamped between min and max.
 */
function clamp(min, max, value) {
  return Math.min( Math.max(min, value), max );
}

/**
 * Save an item to localStorage. A value of `undefined` will remove the item from localStorage.
 * @function setStoreItem
 *
 * @param {String} key - The name of the key.
 * @param {*} value - The value to store.
 */
function setStoreItem(key, value) {
  if (value === undefined) {
    localStorage.removeItem(key);
  }
  else {
    localStorage.setItem(key, JSON.stringify(value));
  }
}

/**
 * Retrieve an item from localStorage and convert it back to its original type.
 *
 * Normally when you save a value to LocalStorage it converts it into a string. So if you were to save a number, it would be saved as `"12"` instead of `12`. This function enables the value to be returned as `12`.
 * @function getStoreItem
 *
 * @param {String} key - Name of the key of the item to retrieve.
 *
 * @returns {*} The retrieved item.
 */
function getStoreItem(key) {
  let value = localStorage.getItem(key);

  try {
    value = JSON.parse(value);
  }
  catch(e) {}

  return value;
}

/**
 * Check if a two objects collide. Uses a simple [Axis-Aligned Bounding Box (AABB) collision check](https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection#Axis-Aligned_Bounding_Box). Takes into account the sprites [anchor](api/gameObject#anchor) and [scale](api/gameObject#scale).
 *
 * **NOTE:** Does not take into account object rotation. If you need collision detection between rotated objects you will need to implement your own `collides()` function. I suggest looking at the Separate Axis Theorem.
 *
 *
 * ```js
 * import { Sprite, collides } from 'kontra';
 *
 * let sprite = Sprite({
 *   x: 100,
 *   y: 200,
 *   width: 20,
 *   height: 40
 * });
 *
 * let sprite2 = Sprite({
 *   x: 150,
 *   y: 200,
 *   width: 20,
 *   height: 20
 * });
 *
 * collides(sprite, sprite2);  //=> false
 *
 * sprite2.x = 115;
 *
 * collides(sprite, sprite2);  //=> true
 * ```
 * @function collides
 *
 * @param {{x: number, y: number, width: number, height: number}|{world: {x: number, y: number, width: number, height: number}}} obj1 - Object reference.
 * @param {{x: number, y: number, width: number, height: number}|{world: {x: number, y: number, width: number, height: number}}} obj2 - Object to check collision against.
 *
 * @returns {Boolean|null} `true` if the objects collide, `false` otherwise. Will return `null` if the either of the two objects are rotated.
 */
function collides(obj1, obj2) {
  if (obj1.rotation || obj2.rotation) return null;

  // @ifdef GAMEOBJECT_SCALE||GAMEOBJECT_ANCHOR
  // destructure results to obj1 and obj2
  [obj1, obj2] = [obj1, obj2].map(obj => getWorldRect(obj));
  // @endif

  return obj1.x < obj2.x + obj2.width &&
         obj1.x + obj1.width > obj2.x &&
         obj1.y < obj2.y + obj2.height &&
         obj1.y + obj1.height > obj2.y;
}

/**
 * Return the world rect of an object. The rect is the world position of the top-left corner of the object and its size. Takes into account the objects anchor and scale.
 * @function getWorldRect
 *
 * @param {{x: number, y: number, width: number, height: number}|{world: {x: number, y: number, width: number, height: number}}|{mapwidth: number, mapheight: number}} obj - Object to get world rect of.
 *
 * @returns {{x: number, y: number, width: number, height: number}} The world `x`, `y`, `width`, and `height` of the object.
 */
function getWorldRect(obj) {
  let {
    x = 0,
    y = 0,
    width,
    height
  } = obj.world || obj;

  // take into account tileEngine
  if (obj.mapwidth) {
    width = obj.mapwidth;
    height = obj.mapheight;
  }

  // @ifdef GAMEOBJECT_ANCHOR
  // account for anchor
  if (obj.anchor) {
    x -= width * obj.anchor.x;
    y -= height * obj.anchor.y;
  }
  // @endif

  // @ifdef GAMEOBJECT_SCALE
  // account for negative scales
  if (width < 0) {
    x += width;
    width *= -1;
  }
  if (height < 0) {
    y += height;
    height *= -1;
  }
  // @endif

  return {
    x,
    y,
    width,
    height
  };
}

/**
 * A simple 2d vector object.
 *
 * ```js
 * import { Vector } from 'kontra';
 *
 * let vector = Vector(100, 200);
 * ```
 * @class Vector
 *
 * @param {Number} [x=0] - X coordinate of the vector.
 * @param {Number} [y=0] - Y coordinate of the vector.
 */
class Vector {
  constructor(x = 0, y = 0, vec = {}) {
    this.x = x;
    this.y = y;

    // @ifdef VECTOR_CLAMP
    // preserve vector clamping when creating new vectors
    if (vec._c) {
      this.clamp(vec._a, vec._b, vec._d, vec._e);

      // reset x and y so clamping takes effect
      this.x = x;
      this.y = y;
    }
    // @endif
  }

  /**
   * Calculate the addition of the current vector with the given vector.
   * @memberof Vector
   * @function add
   *
   * @param {Vector|{x: number, y: number}} vector - Vector to add to the current Vector.
   *
   * @returns {Vector} A new Vector instance whose value is the addition of the two vectors.
   */
  add(vec) {
    return new Vector(
      this.x + vec.x,
      this.y + vec.y,
      this
    );
  }

  // @ifdef VECTOR_SUBTRACT
  /**
   * Calculate the subtraction of the current vector with the given vector.
   * @memberof Vector
   * @function subtract
   *
   * @param {Vector|{x: number, y: number}} vector - Vector to subtract from the current Vector.
   *
   * @returns {Vector} A new Vector instance whose value is the subtraction of the two vectors.
   */
   subtract(vec) {
    return new Vector(
      this.x - vec.x,
      this.y - vec.y,
      this
    );
  }
  // @endif

  // @ifdef VECTOR_SCALE
  /**
   * Calculate the multiple of the current vector by a value.
   * @memberof Vector
   * @function scale
   *
   * @param {Number} value - Value to scale the current Vector.
   *
   * @returns {Vector} A new Vector instance whose value is multiplied by the scalar.
   */
  scale(value) {
    return new Vector(
      this.x * value,
      this.y * value
    );
  }
  // @endif

  // @ifdef VECTOR_NORMALIZE
  /**
   * Calculate the normalized value of the current vector. Requires the Vector [length](api/vector#length) function.
   * @memberof Vector
   * @function normalize
   *
   * @returns {Vector} A new Vector instance whose value is the normalized vector.
   */
  // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var
  normalize(length = this.length()) {
    return new Vector(
      this.x / length,
      this.y / length
    );
  }
  // @endif

  // @ifdef VECTOR_DOT||VECTOR_ANGLE
  /**
   * Calculate the dot product of the current vector with the given vector.
   * @memberof Vector
   * @function dot
   *
   * @param {Vector|{x: number, y: number}} vector - Vector to dot product against.
   *
   * @returns {Number} The dot product of the vectors.
   */
  dot(vec) {
    return this.x * vec.x + this.y * vec.y;
  }
  // @endif

  // @ifdef VECTOR_LENGTH||VECTOR_NORMALIZE||VECTOR_ANGLE
  /**
   * Calculate the length (magnitude) of the Vector.
   * @memberof Vector
   * @function length
   *
   * @returns {Number} The length of the vector.
   */
  length() {
    return Math.hypot(this.x, this.y);
  }
  // @endif

  // @ifdef VECTOR_DISTANCE
  /**
   * Calculate the distance between the current vector and the given vector.
   * @memberof Vector
   * @function distance
   *
   * @param {Vector|{x: number, y: number}} vector - Vector to calculate the distance between.
   *
   * @returns {Number} The distance between the two vectors.
   */
  distance(vec) {
    return Math.hypot(this.x - vec.x, this.y - vec.y);
  }
  // @endif

  // @ifdef VECTOR_ANGLE
  /**
   * Calculate the angle (in radians) between the current vector and the given vector. Requires the Vector [dot](api/vector#dot) and [length](api/vector#length) functions.
   * @memberof Vector
   * @function angle
   *
   * @param {Vector} vector - Vector to calculate the angle between.
   *
   * @returns {Number} The angle (in radians) between the two vectors.
   */
  angle(vec) {
    return Math.acos(this.dot(vec) / (this.length() * vec.length()));
  }
  // @endif

  // @ifdef VECTOR_CLAMP
  /**
   * Clamp the Vector between two points, preventing `x` and `y` from going below or above the minimum and maximum values. Perfect for keeping a sprite from going outside the game boundaries.
   *
   * ```js
   * import { Vector } from 'kontra';
   *
   * let vector = Vector(100, 200);
   * vector.clamp(0, 0, 200, 300);
   *
   * vector.x += 200;
   * console.log(vector.x);  //=> 200
   *
   * vector.y -= 300;
   * console.log(vector.y);  //=> 0
   *
   * vector.add({x: -500, y: 500});
   * console.log(vector);    //=> {x: 0, y: 300}
   * ```
   * @memberof Vector
   * @function clamp
   *
   * @param {Number} xMin - Minimum x value.
   * @param {Number} yMin - Minimum y value.
   * @param {Number} xMax - Maximum x value.
   * @param {Number} yMax - Maximum y value.
   */
  clamp(xMin, yMin, xMax, yMax) {
    this._c = true;
    this._a = xMin;
    this._b = yMin;
    this._d = xMax;
    this._e = yMax;
  }

  /**
   * X coordinate of the vector.
   * @memberof Vector
   * @property {Number} x
   */
  get x() {
    return this._x;
  }

  /**
   * Y coordinate of the vector.
   * @memberof Vector
   * @property {Number} y
   */
  get y() {
    return this._y;
  }

  set x(value) {
    this._x = (this._c ? clamp(this._a, this._d, value) : value);
  }

  set y(value) {
    this._y = (this._c ? clamp(this._b, this._e, value) : value);
  }
  // @endif
}

function factory$1() {
  return new Vector(...arguments);
}
factory$1.prototype = Vector.prototype;
factory$1.class = Vector;

/**
 * This is a private class that is used just to help make the GameObject class more manageable and smaller.
 *
 * It maintains everything that can be changed in the update function:
 * position
 * velocity
 * acceleration
 * ttl
 */
class Updatable {

  constructor(properties) {
    return this.init(properties);
  }

  init(properties = {}) {

    // --------------------------------------------------
    // defaults
    // --------------------------------------------------

    /**
     * The game objects position vector. Represents the local position of the object as opposed to the [world](api/gameObject#world) position.
     * @property {Vector} position
     * @memberof GameObject
     * @page GameObject
     */
    this.position = factory$1();

    // --------------------------------------------------
    // optionals
    // --------------------------------------------------

    // @ifdef GAMEOBJECT_VELOCITY
    /**
     * The game objects velocity vector.
     * @memberof GameObject
     * @property {Vector} velocity
     * @page GameObject
     */
    this.velocity = factory$1();
    // @endif

    // @ifdef GAMEOBJECT_ACCELERATION
    /**
     * The game objects acceleration vector.
     * @memberof GameObject
     * @property {Vector} acceleration
     * @page GameObject
     */
    this.acceleration = factory$1();
    // @endif

    // @ifdef GAMEOBJECT_TTL
    /**
     * How may frames the game object should be alive.
     * @memberof GameObject
     * @property {Number} ttl
     * @page GameObject
     */
    this.ttl = Infinity;
    // @endif

    // add all properties to the object, overriding any defaults
    Object.assign(this, properties);
  }

  /**
   * Update the position of the game object and all children using their velocity and acceleration. Calls the game objects [advance()](api/gameObject#advance) function.
   * @memberof GameObject
   * @function update
   * @page GameObject
   *
   * @param {Number} [dt] - Time since last update.
   */
  update(dt) {
    this.advance(dt);
  }

  /**
   * Move the game object by its acceleration and velocity. If you pass `dt` it will multiply the vector and acceleration by that number. This means the `dx`, `dy`, `ddx` and `ddy` should be the how far you want the object to move in 1 second rather than in 1 frame.
   *
   * If you override the game objects [update()](api/gameObject#update) function with your own update function, you can call this function to move the game object normally.
   *
   * ```js
   * import { GameObject } from 'kontra';
   *
   * let gameObject = GameObject({
   *   x: 100,
   *   y: 200,
   *   width: 20,
   *   height: 40,
   *   dx: 5,
   *   dy: 2,
   *   update: function() {
   *     // move the game object normally
   *     this.advance();
   *
   *     // change the velocity at the edges of the canvas
   *     if (this.x < 0 ||
   *         this.x + this.width > this.context.canvas.width) {
   *       this.dx = -this.dx;
   *     }
   *     if (this.y < 0 ||
   *         this.y + this.height > this.context.canvas.height) {
   *       this.dy = -this.dy;
   *     }
   *   }
   * });
   * ```
   * @memberof GameObject
   * @function advance
   * @page GameObject
   *
   * @param {Number} [dt] - Time since last update.
   *
   */
  advance(dt) {
    // @ifdef GAMEOBJECT_VELOCITY
    // @ifdef GAMEOBJECT_ACCELERATION
    let acceleration = this.acceleration;

    // @ifdef VECTOR_SCALE
    if (dt) {
      acceleration = acceleration.scale(dt);
    }
    // @endif

    this.velocity = this.velocity.add(acceleration);
    // @endif
    // @endif

    // @ifdef GAMEOBJECT_VELOCITY
    let velocity = this.velocity;

    // @ifdef VECTOR_SCALE
    if (dt) {
      velocity = velocity.scale(dt);
    }
    // @endif

    this.position = this.position.add(velocity);
    this._pc();
    // @endif

    // @ifdef GAMEOBJECT_TTL
    this.ttl--;
    // @endif
  }

  // --------------------------------------------------
  // velocity
  // --------------------------------------------------

  // @ifdef GAMEOBJECT_VELOCITY
  /**
   * X coordinate of the velocity vector.
   * @memberof GameObject
   * @property {Number} dx
   * @page GameObject
   */
  get dx() {
    return this.velocity.x;
  }

  /**
   * Y coordinate of the velocity vector.
   * @memberof GameObject
   * @property {Number} dy
   * @page GameObject
   */
  get dy() {
    return this.velocity.y;
  }

  set dx(value) {
    this.velocity.x = value;
  }

  set dy(value) {
    this.velocity.y = value;
  }
  // @endif

  // --------------------------------------------------
  // acceleration
  // --------------------------------------------------

  // @ifdef GAMEOBJECT_ACCELERATION
  /**
   * X coordinate of the acceleration vector.
   * @memberof GameObject
   * @property {Number} ddx
   * @page GameObject
   */
  get ddx() {
    return this.acceleration.x;
  }

  /**
   * Y coordinate of the acceleration vector.
   * @memberof GameObject
   * @property {Number} ddy
   * @page GameObject
   */
  get ddy() {
    return this.acceleration.y;
  }

  set ddx(value) {
    this.acceleration.x = value;
  }

  set ddy(value) {
    this.acceleration.y = value;
  }
  // @endif

  // --------------------------------------------------
  // ttl
  // --------------------------------------------------

  // @ifdef GAMEOBJECT_TTL
  /**
   * Check if the game object is alive.
   * @memberof GameObject
   * @function isAlive
   * @page GameObject
   *
   * @returns {Boolean} `true` if the game objects [ttl](api/gameObject#ttl) property is above `0`, `false` otherwise.
   */
  isAlive() {
    return this.ttl > 0;
  }
  // @endif

  _pc() {}
}

// noop function
let noop = () => {};

// style used for DOM nodes needed for screen readers
let srOnlyStyle = 'position:absolute;width:1px;height:1px;overflow:hidden;';

// append a node directly after the canvas and as the last
// element of other kontra nodes
function addToDom(node, canvas) {
  let container = canvas.parentNode;

  node.setAttribute('data-kontra', '');
  if (container) {
    let target = container.querySelector('[data-kontra]:last-of-type') || canvas;
    container.insertBefore(node, target.nextSibling);
  }
  else {
    document.body.appendChild(node);
  }
}

/**
 * The base class of most renderable classes. Handles things such as position, rotation, anchor, and the update and render life cycle.
 *
 * Typically you don't create a GameObject directly, but rather extend it for new classes.
 * @class GameObject
 *
 * @param {Object} [properties] - Properties of the game object.
 * @param {Number} [properties.x] - X coordinate of the position vector.
 * @param {Number} [properties.y] - Y coordinate of the position vector.
 * @param {Number} [properties.width] - Width of the game object.
 * @param {Number} [properties.height] - Height of the game object.
 *
 * @param {CanvasRenderingContext2D} [properties.context] - The context the game object should draw to. Defaults to [core.getContext()](api/core#getContext).
 *
 * @param {Number} [properties.dx] - X coordinate of the velocity vector.
 * @param {Number} [properties.dy] - Y coordinate of the velocity vector.
 * @param {Number} [properties.ddx] - X coordinate of the acceleration vector.
 * @param {Number} [properties.ddy] - Y coordinate of the acceleration vector.
 * @param {Number} [properties.ttl=Infinity] - How many frames the game object should be alive. Used by [Pool](api/pool).
 *
 * @param {{x: number, y: number}} [properties.anchor={x:0,y:0}] - The x and y origin of the game object. {x:0, y:0} is the top left corner of the game object, {x:1, y:1} is the bottom right corner.
 * @param {Number} [properties.sx=0] - The x camera position.
 * @param {Number} [properties.sy=0] - The y camera position.
 * @param {GameObject[]} [properties.children] - Children to add to the game object.
 * @param {Number} [properties.opacity=1] - The opacity of the game object.
 * @param {Number} [properties.rotation=0] - The rotation around the anchor in radians.
 * @param {Number} [properties.scaleX=1] - The x scale of the game object.
 * @param {Number} [properties.scaleY=1] - The y scale of the game object.
 *
 * @param {(dt?: number) => void} [properties.update] - Function called every frame to update the game object.
 * @param {Function} [properties.render] - Function called every frame to render the game object.
 *
 * @param {...*} properties.props - Any additional properties you need added to the game object. For example, if you pass `gameObject({type: 'player'})` then the game object will also have a property of the same name and value. You can pass as many additional properties as you want.
 */
class GameObject extends Updatable {
  /**
   * @docs docs/api_docs/gameObject.js
   */

  /**
   * Use this function to reinitialize a game object. It takes the same properties object as the constructor. Useful it you want to repurpose a game object.
   * @memberof GameObject
   * @function init
   *
   * @param {Object} properties - Properties of the game object.
   */
  init({

    // --------------------------------------------------
    // defaults
    // --------------------------------------------------

    /**
     * The width of the game object. Represents the local width of the object as opposed to the [world](api/gameObject#world) width.
     * @memberof GameObject
     * @property {Number} width
     */
    width = 0,

    /**
     * The height of the game object. Represents the local height of the object as opposed to the [world](api/gameObject#world) height.
     * @memberof GameObject
     * @property {Number} height
     */
    height = 0,

    /**
     * The context the game object will draw to.
     * @memberof GameObject
     * @property {CanvasRenderingContext2D} context
     */
    context = getContext(),

    render = this.draw,
    update = this.advance,

    // --------------------------------------------------
    // optionals
    // --------------------------------------------------

    // @ifdef GAMEOBJECT_GROUP
    /**
     * The game objects parent object.
     * @memberof GameObject
     * @property {GameObject|null} parent
     */

    /**
     * The game objects children objects.
     * @memberof GameObject
     * @property {GameObject[]} children
     */
    children = [],
    // @endif

    // @ifdef GAMEOBJECT_ANCHOR
    /**
     * The x and y origin of the game object. {x:0, y:0} is the top left corner of the game object, {x:1, y:1} is the bottom right corner.
     * @memberof GameObject
     * @property {{x: number, y: number}} anchor
     *
     * @example
     * // exclude-code:start
     * let { GameObject } = kontra;
     * // exclude-code:end
     * // exclude-script:start
     * import { GameObject } from 'kontra';
     * // exclude-script:end
     *
     * let gameObject = GameObject({
     *   x: 150,
     *   y: 100,
     *   width: 50,
     *   height: 50,
     *   color: 'red',
     *   // exclude-code:start
     *   context: context,
     *   // exclude-code:end
     *   render: function() {
     *     this.context.fillStyle = this.color;
     *     this.context.fillRect(0, 0, this.height, this.width);
     *   }
     * });
     *
     * function drawOrigin(gameObject) {
     *   gameObject.context.fillStyle = 'yellow';
     *   gameObject.context.beginPath();
     *   gameObject.context.arc(gameObject.x, gameObject.y, 3, 0, 2*Math.PI);
     *   gameObject.context.fill();
     * }
     *
     * gameObject.render();
     * drawOrigin(gameObject);
     *
     * gameObject.anchor = {x: 0.5, y: 0.5};
     * gameObject.x = 300;
     * gameObject.render();
     * drawOrigin(gameObject);
     *
     * gameObject.anchor = {x: 1, y: 1};
     * gameObject.x = 450;
     * gameObject.render();
     * drawOrigin(gameObject);
     */
    anchor = {x: 0, y: 0},
    // @endif

    // @ifdef GAMEOBJECT_CAMERA
    /**
     * The X coordinate of the camera.
     * @memberof GameObject
     * @property {Number} sx
     */
    sx = 0,

    /**
     * The Y coordinate of the camera.
     * @memberof GameObject
     * @property {Number} sy
     */
    sy = 0,
    // @endif

    // @ifdef GAMEOBJECT_OPACITY
    /**
     * The opacity of the object. Represents the local opacity of the object as opposed to the [world](api/gameObject#world) opacity.
     * @memberof GameObject
     * @property {Number} opacity
     */
    opacity = 1,
    // @endif

    // @ifdef GAMEOBJECT_ROTATION
    /**
     * The rotation of the game object around the anchor in radians. Represents the local rotation of the object as opposed to the [world](api/gameObject#world) rotation.
     * @memberof GameObject
     * @property {Number} rotation
     */
    rotation = 0,
    // @endif

    // @ifdef GAMEOBJECT_SCALE
    /**
     * The x scale of the object. Represents the local x scale of the object as opposed to the [world](api/gameObject#world) x scale.
     * @memberof GameObject
     * @property {Number} scaleX
     */
    scaleX = 1,

    /**
     * The y scale of the object. Represents the local y scale of the object as opposed to the [world](api/gameObject#world) y scale.
     * @memberof GameObject
     * @property {Number} scaleY
     */
    scaleY = 1,
    // @endif

    ...props
  } = {}) {

    // @ifdef GAMEOBJECT_GROUP
    this.children = [];
    // @endif

    // by setting defaults to the parameters and passing them into
    // the init, we can ensure that a parent class can set overriding
    // defaults and the GameObject won't undo it (if we set
    // `this.width` then no parent could provide a default value for
    // width)
    super.init({
      width,
      height,
      context,

      // @ifdef GAMEOBJECT_ANCHOR
      anchor,
      // @endif

      // @ifdef GAMEOBJECT_CAMERA
      sx,
      sy,
      // @endif

      // @ifdef GAMEOBJECT_OPACITY
      opacity,
      // @endif

      // @ifdef GAMEOBJECT_ROTATION
      rotation,
      // @endif

      // @ifdef GAMEOBJECT_SCALE
      scaleX,
      scaleY,
      // @endif

      ...props
    });

    // di = done init
    this._di = true;
    this._uw();

    // @ifdef GAMEOBJECT_GROUP
    children.map(child => this.addChild(child));
    // @endif

    // rf = render function
    this._rf = render;

    // uf = update function
    this._uf = update;
  }

  /**
   * Update all children
   */
  update(dt) {
    this._uf(dt);

    // @ifdef GAMEOBJECT_GROUP
    this.children.map(child => child.update && child.update(dt));
    // @endif
  }

  /**
   * Render the game object and all children. Calls the game objects [draw()](api/gameObject#draw) function.
   * @memberof GameObject
   * @function render
   *
   * @param {Function} [filterObjects] - [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) function which is used to filter which children to render.
   */
  render(filterObjects) {
    let context = this.context;
    context.save();

    // 1) translate to position
    //
    // it's faster to only translate if one of the values is non-zero
    // rather than always translating
    // @see https://jsperf.com/translate-or-if-statement/2
    if (this.x || this.y) {
      context.translate(this.x, this.y);
    }

    // @ifdef GAMEOBJECT_ROTATION
    // 2) rotate around the anchor
    //
    // it's faster to only rotate when set rather than always rotating
    // @see https://jsperf.com/rotate-or-if-statement/2
    if (this.rotation) {
      context.rotate(this.rotation);
    }
    // @endif

    // @ifdef GAMEOBJECT_CAMERA
    // 3) translate to the camera position after rotation so camera
    // values are in the direction of the rotation rather than always
    // along the x/y axis
    if (this.sx || this.sy) {
      context.translate(-this.sx, -this.sy);
    }
    // @endif

    // @ifdef GAMEOBJECT_SCALE
    // 4) scale after translation to position so object can be
    // scaled in place (rather than scaling position as well).
    //
    // it's faster to only scale if one of the values is not 1
    // rather than always scaling
    // @see https://jsperf.com/scale-or-if-statement/4
    if (this.scaleX != 1 || this.scaleY != 1) {
      context.scale(this.scaleX, this.scaleY);
    }
    // @endif

    // @ifdef GAMEOBJECT_ANCHOR
    // 5) translate to the anchor so (0,0) is the top left corner
    // for the render function
    let anchorX = -this.width * this.anchor.x;
    let anchorY = -this.height * this.anchor.y;

    if (anchorX || anchorY) {
      context.translate(anchorX, anchorY);
    }
    // @endif

    // @ifdef GAMEOBJECT_OPACITY
    // it's not really any faster to gate the global alpha
    // @see https://jsperf.com/global-alpha-or-if-statement/1
    this.context.globalAlpha = this.opacity;
    // @endif

    this._rf();

    // @ifdef GAMEOBJECT_ANCHOR
    // 7) translate back to the anchor so children use the correct
    // x/y value from the anchor
    if (anchorX || anchorY) {
      context.translate(-anchorX, -anchorY);
    }
    // @endif

    // @ifdef GAMEOBJECT_GROUP
    // perform all transforms on the parent before rendering the children
    let children = this.children;
    if (filterObjects) {
      children = children.filter(filterObjects);
    }
    children.map(child => child.render && child.render());
    // @endif

    context.restore();
  }

  /**
   * Draw the game object at its X and Y position, taking into account rotation, scale, and anchor.
   *
   * Do note that the canvas has been rotated and translated to the objects position (taking into account anchor), so {0,0} will be the top-left corner of the game object when drawing.
   *
   * If you override the game objects `render()` function with your own render function, you can call this function to draw the game object normally.
   *
   * ```js
   * let { GameObject } = kontra;
   *
   * let gameObject = GameObject({
   *  x: 290,
   *  y: 80,
   *  width: 20,
   *  height: 40,
   *
   *  render: function() {
   *    // draw the game object normally (perform rotation and other transforms)
   *    this.draw();
   *
   *    // outline the game object
   *    this.context.strokeStyle = 'yellow';
   *    this.context.lineWidth = 2;
   *    this.context.strokeRect(0, 0, this.width, this.height);
   *  }
   * });
   *
   * gameObject.render();
   * ```
   * @memberof GameObject
   * @function draw
   */
  draw() {}

  /**
   * Sync property changes from the parent to the child
   */
  _pc(prop, value) {
    this._uw();

    // @ifdef GAMEOBJECT_GROUP
    this.children.map(child => child._pc());
    // @endif
  }

  /**
   * X coordinate of the position vector.
   * @memberof GameObject
   * @property {Number} x
   */
  get x() {
    return this.position.x;
  }

  /**
   * Y coordinate of the position vector.
   * @memberof GameObject
   * @property {Number} y
   */
  get y() {
    return this.position.y;
  }

  set x(value) {
    this.position.x = value;

    // pc = property changed
    this._pc();
  }

  set y(value) {
    this.position.y = value;
    this._pc();
  }

  get width() {
    // w = width
    return this._w;
  }

  set width(value) {
    this._w = value;
    this._pc();
  }

  get height() {
    // h = height
    return this._h;
  }

  set height(value) {
    this._h = value;
    this._pc();
  }

  /**
   * Update world properties
   */
  _uw() {
    // don't update world properties until after the init has finished
    if (!this._di) return;

    // @ifdef GAMEOBJECT_GROUP||GAMEOBJECT_OPACITY||GAMEOBJECT_ROTATION||GAMEOBJECT_SCALE
    let {
      _wx = 0,
      _wy = 0,

      // @ifdef GAMEOBJECT_OPACITY
      _wo = 1,
      // @endif

      // @ifdef GAMEOBJECT_ROTATION
      _wr = 0,
      // @endif

      // @ifdef GAMEOBJECT_SCALE
      _wsx = 1,
      _wsy = 1
      // @endif
    } = (this.parent || {});
    // @endif

    // wx = world x, wy = world y
    this._wx = this.x;
    this._wy = this.y;

    // ww = world width, wh = world height
    this._ww = this.width;
    this._wh = this.height;

    // @ifdef GAMEOBJECT_OPACITY
    // wo = world opacity
    this._wo = _wo * this.opacity;
    // @endif

    // @ifdef GAMEOBJECT_ROTATION
    // wr = world rotation
    this._wr = _wr + this.rotation;

    let {x, y} = rotatePoint({x: this.x, y: this.y}, _wr);
    this._wx = x;
    this._wy = y;
    // @endif

    // @ifdef GAMEOBJECT_SCALE
    // wsx = world scale x, wsy = world scale y
    this._wsx = _wsx * this.scaleX;
    this._wsy = _wsy * this.scaleY;

    this._wx = this.x * _wsx;
    this._wy = this.y * _wsy;
    this._ww = this.width * this._wsx;
    this._wh = this.height * this._wsy;
    // @endif

    // @ifdef GAMEOBJECT_GROUP
    this._wx += _wx;
    this._wy += _wy;
    // @endif
  }

  /**
   * The world position, width, height, opacity, rotation, and scale. The world property is the true position, width, height, etc. of the object, taking into account all parents.
   *
   * The world property does not adjust for anchor or scale, so if you set a negative scale the world width or height could be negative. Use [getWorldRect](/api/helpers#getWorldRect) to get the world position and size adjusted for anchor and scale.
   * @property {{x: number, y: number, width: number, height: number, opacity: number, rotation: number, scaleX: number, scaleY: number}} world
   * @memberof GameObject
   */
  get world() {
    return {
      x: this._wx,
      y: this._wy,
      width: this._ww,
      height: this._wh,

      // @ifdef GAMEOBJECT_OPACITY
      opacity: this._wo,
      // @endif

      // @ifdef GAMEOBJECT_ROTATION
      rotation: this._wr,
      // @endif

      // @ifdef GAMEOBJECT_SCALE
      scaleX: this._wsx,
      scaleY: this._wsy
      // @endif
    }
  }

  // --------------------------------------------------
  // group
  // --------------------------------------------------

  // @ifdef GAMEOBJECT_GROUP
  /**
   * Add an object as a child to this object. The childs [world](api/gameObject#world) property will be updated to take into account this object and all of its parents.
   * @memberof GameObject
   * @function addChild
   *
   * @param {GameObject} child - Object to add as a child.
   *
   * @example
   * // exclude-code:start
   * let { GameObject } = kontra;
   * // exclude-code:end
   * // exclude-script:start
   * import { GameObject } from 'kontra';
   * // exclude-script:end
   *
   * function createObject(x, y, color, size = 1) {
   *   return GameObject({
   *     x,
   *     y,
   *     width: 50 / size,
   *     height: 50 / size,
   *     anchor: {x: 0.5, y: 0.5},
   *     color,
   *     // exclude-code:start
   *     context: context,
   *     // exclude-code:end
   *     render: function() {
   *       this.context.fillStyle = this.color;
   *       this.context.fillRect(0, 0, this.height, this.width);
   *     }
   *   });
   * }
   *
   * let parent = createObject(300, 100, 'red');
   * let child = createObject(25, 25, 'yellow', 2);
   *
   * parent.addChild(child);
   *
   * parent.render();
   */
  addChild(child, { absolute = false } = {}) {
    this.children.push(child);
    child.parent = this;
    child._pc = child._pc || noop;
    child._pc();
  }

  /**
   * Remove an object as a child of this object. The removed objects [world](api/gameObject#world) property will be updated to not take into account this object and all of its parents.
   * @memberof GameObject
   * @function removeChild
   *
   * @param {GameObject} child - Object to remove as a child.
   */
  removeChild(child) {
    let index = this.children.indexOf(child);
    if (index !== -1) {
      this.children.splice(index, 1);
      child.parent = null;
      child._pc();
    }
  }
  // @endif

  // --------------------------------------------------
  // opacity
  // --------------------------------------------------

  // @ifdef GAMEOBJECT_OPACITY
  get opacity() {
    return this._opa;
  }

  set opacity(value) {
    this._opa = value;
    this._pc();
  }
  // @endif

  // --------------------------------------------------
  // rotation
  // --------------------------------------------------

  // @ifdef GAMEOBJECT_ROTATION
  get rotation() {
    return this._rot;
  }

  set rotation(value) {
    this._rot = value;
    this._pc();
  }
  // @endif

  // --------------------------------------------------
  // scale
  // --------------------------------------------------

  // @ifdef GAMEOBJECT_SCALE
  /**
   * Set the x and y scale of the object. If only one value is passed, both are set to the same value.
   * @memberof GameObject
   * @function setScale
   *
   * @param {Number} x - X scale value.
   * @param {Number} [y=x] - Y scale value.
   */
  setScale(x, y = x) {
    this.scaleX = x;
    this.scaleY = y;
  }

  get scaleX() {
    return this._scx;
  }

  set scaleX(value) {
    this._scx = value;
    this._pc();
  }

  get scaleY() {
    return this._scy;
  }

  set scaleY(value) {
    this._scy = value;
    this._pc();
  }
  // @endif
}

function factory$2() {
  return new GameObject(...arguments);
}
factory$2.prototype = GameObject.prototype;
factory$2.class = GameObject;

/**
 * A versatile way to update and draw your sprites. It can handle simple rectangles, images, and sprite sheet animations. It can be used for your main player object as well as tiny particles in a particle engine.
 * @class Sprite
 * @extends GameObject
 *
 * @param {Object} [properties] - Properties of the sprite.
 * @param {String} [properties.color] - Fill color for the game object if no image or animation is provided.
 * @param {HTMLImageElement|HTMLCanvasElement} [properties.image] - Use an image to draw the sprite.
 * @param {{[name: string] : Animation}} [properties.animations] - An object of [Animations](api/animation) from a [Spritesheet](api/spriteSheet) to animate the sprite.
 */
class Sprite extends factory$2.class {
  /**
   * @docs docs/api_docs/sprite.js
   */

  init({
    /**
     * The color of the game object if it was passed as an argument.
     * @memberof Sprite
     * @property {String} color
     */

    // @ifdef SPRITE_IMAGE
    /**
     * The image the sprite will use when drawn if passed as an argument.
     * @memberof Sprite
     * @property {HTMLImageElement|HTMLCanvasElement} image
     */
    image,

    /**
     * The width of the sprite. If the sprite is a [rectangle sprite](api/sprite#rectangle-sprite), it uses the passed in value. For an [image sprite](api/sprite#image-sprite) it is the width of the image. And for an [animation sprite](api/sprite#animation-sprite) it is the width of a single frame of the animation.
     * @memberof Sprite
     * @property {Number} width
     */
    width = image ? image.width : undefined,

    /**
     * The height of the sprite. If the sprite is a [rectangle sprite](api/sprite#rectangle-sprite), it uses the passed in value. For an [image sprite](api/sprite#image-sprite) it is the height of the image. And for an [animation sprite](api/sprite#animation-sprite) it is the height of a single frame of the animation.
     * @memberof Sprite
     * @property {Number} height
     */
    height = image ? image.height : undefined,
    // @endif

    ...props
  } = {}) {
    super.init({
      // @ifdef SPRITE_IMAGE
      image,
      width,
      height,
      // @endif
      ...props
    });
  }

  // @ifdef SPRITE_ANIMATION
  /**
   * An object of [Animations](api/animation) from a [SpriteSheet](api/spriteSheet) to animate the sprite. Each animation is named so that it can can be used by name for the sprites [playAnimation()](api/sprite#playAnimation) function.
   *
   * ```js
   * import { Sprite, SpriteSheet } from 'kontra';
   *
   * let spriteSheet = SpriteSheet({
   *   // ...
   *   animations: {
   *     idle: {
   *       frames: 1,
   *       loop: false,
   *     },
   *     walk: {
   *       frames: [1,2,3]
   *     }
   *   }
   * });
   *
   * let sprite = Sprite({
   *   x: 100,
   *   y: 200,
   *   animations: spriteSheet.animations
   * });
   *
   * sprite.playAnimation('idle');
   * ```
   * @memberof Sprite
   * @property {{[name: string] : Animation}} animations
   */
  get animations() {
    return this._a;
  }

  set animations(value) {
    let prop, firstAnimation;
    // a = animations
    this._a = {};

    // clone each animation so no sprite shares an animation
    for (prop in value) {
      this._a[prop] = value[prop].clone();

      // default the current animation to the first one in the list
      firstAnimation = firstAnimation || this._a[prop];
    }

    /**
     * The currently playing Animation object if `animations` was passed as an argument.
     * @memberof Sprite
     * @property {Animation} currentAnimation
     */
    this.currentAnimation = firstAnimation;
    this.width = this.width || firstAnimation.width;
    this.height = this.height || firstAnimation.height;
  }

  /**
   * Set the currently playing animation of an animation sprite.
   *
   * ```js
   * import { Sprite, SpriteSheet } from 'kontra';
   *
   * let spriteSheet = SpriteSheet({
   *   // ...
   *   animations: {
   *     idle: {
   *       frames: 1
   *     },
   *     walk: {
   *       frames: [1,2,3]
   *     }
   *   }
   * });
   *
   * let sprite = Sprite({
   *   x: 100,
   *   y: 200,
   *   animations: spriteSheet.animations
   * });
   *
   * sprite.playAnimation('idle');
   * ```
   * @memberof Sprite
   * @function playAnimation
   *
   * @param {String} name - Name of the animation to play.
   */
  playAnimation(name) {
    this.currentAnimation = this.animations[name];

    if (!this.currentAnimation.loop) {
      this.currentAnimation.reset();
    }
  }

  advance(dt) {
    super.advance(dt);

    if (this.currentAnimation) {
      this.currentAnimation.update(dt);
    }
  }
  // @endif

  draw() {
    // @ifdef SPRITE_IMAGE
    if (this.image) {
      this.context.drawImage(
        this.image,
        0, 0, this.image.width, this.image.height
      );
    }
    // @endif

    // @ifdef SPRITE_ANIMATION
    if (this.currentAnimation) {
      this.currentAnimation.render({
        x: 0,
        y: 0,
        width: this.width,
        height: this.height,
        context: this.context
      });
    }
    // @endif

    if (this.color) {
      this.context.fillStyle = this.color;
      this.context.fillRect(0, 0, this.width, this.height);
    }
  }
}

function factory$3() {
  return new Sprite(...arguments);
}
factory$3.prototype = Sprite.prototype;
factory$3.class = Sprite;

let fontSizeRegex = /(\d+)(\w+)/;

function parseFont(font) {
  let match = font.match(fontSizeRegex);

  // coerce string to number
  // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types
  let size = +match[1];
  let unit = match[2];
  let computed = size;

  // compute font size
  // switch(unit) {
  //   // px defaults to the size

  //   // em uses the size of the canvas when declared (but won't keep in sync with
  //   // changes to the canvas font-size)
  //   case 'em': {
  //     let fontSize = window.getComputedStyle(getCanvas()).fontSize;
  //     let parsedSize = parseFont(fontSize).size;
  //     computed = size * parsedSize;
  //   }

  //   // rem uses the size of the HTML element when declared (but won't keep in
  //   // sync with changes to the HTML element font-size)
  //   case 'rem': {
  //     let fontSize = window.getComputedStyle(document.documentElement).fontSize;
  //     let parsedSize = parseFont(fontSize).size;
  //     computed = size * parsedSize;
  //   }
  // }

  return {
    size,
    unit,
    computed
  };
}

/**
 * An object for drawing text to the screen. Supports newline characters as well as automatic new lines when setting the `width` property.
 *
 * You can also display RTL languages by setting the attribute `dir="rtl"` on the main canvas element. Due to the limited browser support for individual text to have RTL settings, it must be set globally for the entire game.
 *
 * @example
 * // exclude-code:start
 * let { Text } = kontra;
 * // exclude-code:end
 * // exclude-script:start
 * import { Text } from 'kontra';
 * // exclude-script:end
 *
 * let text = Text({
 *   text: 'Hello World!\nI can even be multiline!',
 *   font: '32px Arial',
 *   color: 'white',
 *   x: 300,
 *   y: 100,
 *   anchor: {x: 0.5, y: 0.5},
 *   textAlign: 'center'
 * });
 * // exclude-code:start
 * text.context = context;
 * // exclude-code:end
 *
 * text.render();
 * @class Text
 * @extends GameObject
 *
 * @param {Object} properties - Properties of the text.
 * @param {String} properties.text - The text to display.
 * @param {String} [properties.font] - The [font](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font) style. Defaults to the main context font.
 * @param {String} [properties.color] - Fill color for the text. Defaults to the main context fillStyle.
 * @param {Number} [properties.width] - Set a fixed width for the text. If set, the text will automatically be split into new lines that will fit the size when possible.
 * @param {String} [properties.textAlign='left'] - The [textAlign](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textAlign) for the context. If the `dir` attribute is set to `rtl` on the main canvas, the text will automatically be aligned to the right, but you can override that by setting this property.
 * @param {Number} [properties.lineHeight=1] - The distance between two lines of text.
 */
class Text extends factory$2.class {

  init({

    // --------------------------------------------------
    // defaults
    // --------------------------------------------------

    /**
     * The string of text. Use newline characters to create multi-line strings.
     * @memberof Text
     * @property {String} text
     */
    text = '',

    /**
     * The text alignment.
     * @memberof Text
     * @property {String} textAlign
     */
    textAlign = '',

    /**
     * The distance between two lines of text. The value is multiplied by the texts font size.
     * @memberof Text
     * @property {Number} lineHeight
     */
    lineHeight = 1,

   /**
    * The font style.
    * @memberof Text
    * @property {String} font
    */
    font = getContext().font,

    /**
     * The color of the text.
     * @memberof Text
     * @property {String} color
     */

     ...props
  } = {}) {
    // cast to string
    text = '' + text;

    super.init({
      text,
      textAlign,
      lineHeight,
      font,
      ...props
    });

    // p = prerender
    this._p();
  }

  // keep width and height getters/settings so we can set _w and _h and not
  // trigger infinite call loops
  get width() {
    // w = width
    return this._w;
  }

  set width(value) {
    // d = dirty
    this._d = true;
    this._w = value;

    // fw = fixed width
    this._fw = value;
  }

  get text() {
    return this._t;
  }

  set text(value) {
    this._d = true;
    this._t = value;
  }

  get font() {
    return this._f;
  }

  set font(value) {
    this._d = true;
    this._f = value;
    this._fs = parseFont(value).computed;
  }

  get lineHeight() {
    // lh = line height
    return this._lh;
  }

  set lineHeight(value) {
    this._d = true;
    this._lh = value;
  }

  render() {
    if (this._d) {
      this._p();
    }
    super.render();
  }

  /**
   * Calculate the font width, height, and text strings before rendering.
   */
  _p() {
    // s = strings
    this._s = [];
    this._d = false;
    let context = this.context;

    context.font = this.font;

    // @ifdef TEXT_AUTONEWLINE
    if (!this._s.length && this._fw) {
      let parts = this.text.split(' ');
      let start = 0;
      let i = 2;

      // split the string into lines that all fit within the fixed width
      for (; i <= parts.length; i++) {
        let str = parts.slice(start, i).join(' ');
        let width = context.measureText(str).width;

        if (width > this._fw) {
          this._s.push(parts.slice(start, i - 1).join(' '));
          start = i - 1;
        }
      }

      this._s.push(parts.slice(start, i).join(' '));
    }
    // @endif

    // @ifdef TEXT_NEWLINE
    if (!this._s.length && this.text.includes('\n')) {
      let width = 0;
      this.text.split('\n').map(str => {
        this._s.push(str);
        width = Math.max(width, context.measureText(str).width);
      });

      this._w = this._fw || width;
    }
    // @endif

    if (!this._s.length) {
      this._s.push(this.text);
      this._w = this._fw || context.measureText(this.text).width;
    }

    this.height = this._fs + ((this._s.length - 1) * this._fs * this.lineHeight);
    this._uw();
  }

  draw() {
    let alignX = 0;
    let textAlign = this.textAlign;
    let context = this.context;

    // @ifdef TEXT_RTL
    textAlign = this.textAlign || (context.canvas.dir === 'rtl' ? 'right' : 'left');
    // @endif

    // @ifdef TEXT_ALIGN||TEXT_RTL
    alignX = textAlign === 'right'
      ? this.width
      : textAlign === 'center'
        ? this.width / 2 | 0
        : 0;
    // @endif

    this._s.map((str, index) => {
      context.textBaseline = 'top';
      context.textAlign = textAlign;
      context.fillStyle = this.color;
      context.font = this.font;
      context.fillText(str, alignX, this._fs * this.lineHeight * index);
    });
  }
}

function factory$4() {
  return new Text(...arguments);
}
factory$4.prototype = Text.prototype;
factory$4.class = Text;

/**
 * A simple pointer API. You can use it move the main sprite or respond to a pointer event. Works with both mouse and touch events.
 *
 * Pointer events can be added on a global level or on individual sprites or objects. Before an object can receive pointer events, you must tell the pointer which objects to track and the object must haven been rendered to the canvas using `object.render()`.
 *
 * After an object is tracked and rendered, you can assign it an `onDown()`, `onUp()`, `onOver()`, or `onOut()` functions which will be called whenever a pointer down, up, over, or out event happens on the object.
 *
 * ```js
 * import { initPointer, track, Sprite } from 'kontra';
 *
 * // this function must be called first before pointer
 * // functions will work
 * initPointer();
 *
 * let sprite = Sprite({
 *   onDown: function() {
 *     // handle on down events on the sprite
 *   },
 *   onUp: function() {
 *     // handle on up events on the sprite
 *   },
 *   onOver: function() {
 *     // handle on over events on the sprite
 *   },
 *   onOut: function() {
 *     // handle on out events on the sprite
 *   }
 * });
 *
 * track(sprite);
 * sprite.render();
 * ```
 *
 * By default, the pointer is treated as a circle and will check for collisions against objects assuming they are rectangular (have a width and height property).
 *
 * If you need to perform a different type of collision detection, assign the object a `collidesWithPointer()` function and it will be called instead. The function is passed the pointer object. Use this function to determine how the pointer circle should collide with the object.
 *
 * ```js
 * import { Sprite } from 'kontra';

 * let sprite = Srite({
 *   x: 10,
 *   y: 10,
 *   radius: 10
 *   collidesWithPointer: function(pointer) {
 *     // perform a circle v circle collision test
 *     let dx = pointer.x - this.x;
 *     let dy = pointer.y - this.y;
 *     return Math.sqrt(dx * dx + dy * dy) < this.radius;
 *   }
 * });
 * ```
 * @sectionName Pointer
 */

// save each object as they are rendered to determine which object
// is on top when multiple objects are the target of an event.
// we'll always use the last frame's object order so we know
// the finalized order of all objects, otherwise an object could ask
// if it's being hovered when it's rendered first even if other objects
// would block it later in the render order
let pointers = new WeakMap();
let callbacks$1 = {};
let pressedButtons = {};

/**
 * Below is a list of buttons that you can use.
 *
 * - left, middle, right
 * @sectionName Available Buttons
 */
let buttonMap = {
  0: 'left',
  1: 'middle',
  2: 'right'
};

/**
 * Get the pointer object which contains the `radius`, current `x` and `y` position of the pointer relative to the top-left corner of the canvas, and which `canvas` the pointer applies to.
 *
 * ```js
 * import { initPointer, getPointer } from 'kontra';
 *
 * initPointer();
 *
 * console.log(getPointer());  //=> { x: 100, y: 200, radius: 5, canvas: <canvas> };
 * ```
 *
 * @function getPointer
 *
 * @param {HTMLCanvasElement} [canvas] - The canvas which maintains the pointer. Defaults to [core.getCanvas()](api/core#getCanvas).
 *
 * @returns {{x: Number, y: Number, radius: Number, canvas: HTMLCanvasElement, touches: Object}} pointer with properties `x`, `y`, and `radius`. If using touch events, also has a `touches` object with keys of the touch identifier and the x/y position of the touch as the value.
 */
function getPointer(canvas = getCanvas()) {
  return pointers.get(canvas);
}

/**
 * Detection collision between a rectangle and a circle.
 * @see https://yal.cc/rectangle-circle-intersection-test/
 *
 * @param {Object} object - Object to check collision against.
 */
function circleRectCollision(object, pointer) {
  let { x, y, width, height } = getWorldRect(object);

  // account for camera
  do {
    x -= object.sx || 0;
    y -= object.sy || 0;
  } while ((object = object.parent));

  let dx = pointer.x - Math.max(x, Math.min(pointer.x, x + width));
  let dy = pointer.y - Math.max(y, Math.min(pointer.y, y + height));
  return (dx * dx + dy * dy) < (pointer.radius * pointer.radius);
}

/**
 * Get the first on top object that the pointer collides with.
 *
 * @param {Object} pointer - The pointer object
 *
 * @returns {Object} First object to collide with the pointer.
 */
function getCurrentObject(pointer) {

  // if pointer events are required on the very first frame or
  // without a game loop, use the current frame
  let renderedObjects = pointer._lf.length ?
    pointer._lf :
    pointer._cf;

  for (let i = renderedObjects.length - 1; i >= 0; i--) {
    let object = renderedObjects[i];
    let collides = object.collidesWithPointer ?
      object.collidesWithPointer(pointer) :
      circleRectCollision(object, pointer);

    if (collides) {
      return object;
    }
  }
}

/**
 * Get the style property value.
 */
function getPropValue(style, value) {
  return parseFloat(style.getPropertyValue(value)) || 0;
}

/**
 * Calculate the canvas size, scale, and offset.
 *
 * @param {Object} The pointer object
 *
 * @returns {Object} The scale and offset of the canvas
 */
function getCanvasOffset(pointer) {
  // we need to account for CSS scale, transform, border, padding,
  // and margin in order to get the correct scale and offset of the
  // canvas
  let { canvas, _s } = pointer;
  let rect = canvas.getBoundingClientRect();

  // @see https://stackoverflow.com/a/53405390/2124254
  let transform = _s.transform !== 'none'
    ? _s.transform.replace('matrix(', '').split(',')
    : [1,1,1,1];
  let transformScaleX = parseFloat(transform[0]);
  let transformScaleY = parseFloat(transform[3]);

  // scale transform applies to the border and padding of the element
  let borderWidth = (getPropValue(_s, 'border-left-width') + getPropValue(_s, 'border-right-width')) * transformScaleX;
  let borderHeight = (getPropValue(_s, 'border-top-width') + getPropValue(_s, 'border-bottom-width')) * transformScaleY;

  let paddingWidth = (getPropValue(_s, 'padding-left') + getPropValue(_s, 'padding-right')) * transformScaleX;
  let paddingHeight = (getPropValue(_s, 'padding-top') + getPropValue(_s, 'padding-bottom')) * transformScaleY;

  return {
    scaleX: (rect.width - borderWidth - paddingWidth) / canvas.width,
    scaleY: (rect.height - borderHeight - paddingHeight) / canvas.height,
    offsetX: rect.left + (getPropValue(_s, 'border-left-width') + getPropValue(_s, 'padding-left')) * transformScaleX,
    offsetY: rect.top + (getPropValue(_s, 'border-top-width') + getPropValue(_s, 'padding-top')) * transformScaleY
  };
}

/**
 * Execute the onDown callback for an object.
 *
 * @param {MouseEvent|TouchEvent} evt
 */
function pointerDownHandler(evt) {

  // touchstart should be treated like a left mouse button
  let button = evt.button !== undefined ? buttonMap[evt.button] : 'left';
  pressedButtons[button] = true;
  pointerHandler(evt, 'onDown');
}

/**
 * Execute the onUp callback for an object.
 *
 * @param {MouseEvent|TouchEvent} evt
 */
function pointerUpHandler(evt) {
  let button = evt.button !== undefined ? buttonMap[evt.button] : 'left';
  pressedButtons[button] = false;
  pointerHandler(evt, 'onUp');
}

/**
 * Track the position of the mousevt.
 *
 * @param {MouseEvent|TouchEvent} evt
 */
function mouseMoveHandler(evt) {
  pointerHandler(evt, 'onOver');
}

/**
 * Reset pressed buttons.
 *
 * @param {MouseEvent|TouchEvent} evt
 */
function blurEventHandler(evt) {
  let pointer = pointers.get(evt.target);
  pointer._oo = null;
  pressedButtons = {};
}

/**
 * Find the first object for the event and execute it's callback function
 *
 * @param {MouseEvent|TouchEvent} evt
 * @param {string} eventName - Which event was called.
 */
function pointerHandler(evt, eventName) {
  evt.preventDefault();

  let canvas = evt.target;
  let pointer = pointers.get(canvas);
  let {
    scaleX,
    scaleY,
    offsetX,
    offsetY
  } = getCanvasOffset(pointer);

  let isTouchEvent = ['touchstart', 'touchmove', 'touchend'].indexOf(evt.type) !== -1;

  if (isTouchEvent) {

    // update pointer.touches
    pointer.touches = {};
    for (var i = 0; i < evt.touches.length; i++) {
      pointer.touches[evt.touches[i].identifier] = {
        id: evt.touches[i].identifier,
        x: (evt.touches[i].clientX - offsetX) / scaleX,
        y: (evt.touches[i].clientY - offsetY) / scaleY,
        changed: false
      };
    }

    // handle all touches
    for (var i = evt.changedTouches.length; i--;) {
      const id = evt.changedTouches[i].identifier;
      if (typeof pointer.touches[id] !== "undefined") {
        pointer.touches[id].changed = true;
      }

      let clientX = evt.changedTouches[i].clientX;
      let clientY = evt.changedTouches[i].clientY;
      pointer.x = (clientX - offsetX) / scaleX;
      pointer.y = (clientY - offsetY) / scaleY;

      // Trigger events
      let object = getCurrentObject(pointer);
      if (object && object[eventName]) {
        object[eventName](evt);
      }

      if (callbacks$1[eventName]) {
        callbacks$1[eventName](evt, object);
      }
    }
  }
  else {

    // translate the scaled size back as if the canvas was at a
    // 1:1 scale
    pointer.x = (evt.clientX - offsetX) / scaleX;
    pointer.y = (evt.clientY - offsetY) / scaleY;

    let object = getCurrentObject(pointer);
    if (object && object[eventName]) {
      object[eventName](evt);
    }

    if (callbacks$1[eventName]) {
      callbacks$1[eventName](evt, object);
    }

    // handle onOut events
    if (eventName == 'onOver') {
      if (object != pointer._oo && pointer._oo && pointer._oo.onOut) {
        pointer._oo.onOut(evt);
      }

      pointer._oo = object;
    }
  }
}

/**
 * Initialize pointer event listeners. This function must be called before using other pointer functions.
 *
 * If you need to use multiple canvas, you'll have to initialize the pointer for each one individually as each canvas maintains its own pointer object.
 * @function initPointer
 *
 * @param {Object} [options] - Pointer options.
 * @param {Number} [options.radius=5] - Radius of the pointer.
 * @param {HTMLCanvasElement} [options.canvas] - The canvas that event listeners will be attached to. Defaults to [core.getCanvas()](api/core#getCanvas).
 *
 * @returns {{x: Number, y: Number, radius: Number, canvas: HTMLCanvasElement, touches: Object}} The pointer object for the canvas.
 */
function initPointer({radius = 5, canvas = getCanvas()} = {}) {
  let pointer = pointers.get(canvas);
  if (!pointer) {
    let style = window.getComputedStyle(canvas);

    pointer = {
      x: 0,
      y: 0,
      radius,
      touches: {},
      canvas,

      // cf = current frame, lf = last frame, o = objects,
      // oo = over object, _s = style
      _cf: [],
      _lf: [],
      _o: [],
      _oo: null,
      _s: style
    };
    pointers.set(canvas, pointer);
  }

  // if this function is called multiple times, the same event
  // won't be added multiple times
  // @see https://stackoverflow.com/questions/28056716/check-if-an-element-has-event-listener-on-it-no-jquery/41137585#41137585
  canvas.addEventListener('mousedown', pointerDownHandler);
  canvas.addEventListener('touchstart', pointerDownHandler);
  canvas.addEventListener('mouseup', pointerUpHandler);
  canvas.addEventListener('touchend', pointerUpHandler);
  canvas.addEventListener('touchcancel', pointerUpHandler);
  canvas.addEventListener('blur', blurEventHandler);
  canvas.addEventListener('mousemove', mouseMoveHandler);
  canvas.addEventListener('touchmove', mouseMoveHandler);

  // however, the tick event should only be registered once
  // otherwise it completely destroys pointer events
  if (!pointer._t) {
    pointer._t = true;

    // reset object render order on every new frame
    on('tick', () => {
      pointer._lf.length = 0;

      pointer._cf.map(object => {
        pointer._lf.push(object);
      });

      pointer._cf.length = 0;
    });
  }

  return pointer;
}

/**
 * Begin tracking pointer events for a set of objects. Takes a single object or an array of objects.
 *
 * ```js
 * import { initPointer, track } from 'kontra';
 *
 * initPointer();
 *
 * track(obj);
 * track(obj1, obj2);
 * ```
 * @function track
 *
 * @param {...Object[]} objects - Objects to track.
 */
function track(...objects) {
  objects.map(object => {
    let canvas = object.context ? object.context.canvas : getCanvas();
    let pointer = pointers.get(canvas);

    // @ifdef DEBUG
    if (!pointer) {
      throw new ReferenceError('Pointer events not initialized for the objects canvas');
    }    // @endif

    // override the objects render function to keep track of render
    // order
    if (!object._r) {
      object._r = object.render;

      object.render = function() {
        pointer._cf.push(this);
        this._r();
      };

      pointer._o.push(object);
    }
  });
}

/**
* Remove the callback function for a bound set of objects.
 *
 * ```js
 * import { untrack } from 'kontra';
 *
 * untrack(obj);
 * untrack(obj1, obj2);
 * ```
 * @function untrack
 *
 * @param {...Object[]} objects - Object or objects to stop tracking.
 */
function untrack(...objects) {
  objects.map(object => {
    let canvas = object.context ? object.context.canvas : getCanvas();
    let pointer = pointers.get(canvas);

    // @ifdef DEBUG
    if (!pointer) {
      throw new ReferenceError('Pointer events not initialized for the objects canvas');
    }    // @endif

    // restore original render function to no longer track render order
    object.render = object._r;
    object._r = 0;  // 0 is the shortest falsy value

    let index = pointer._o.indexOf(object);
    if (index !== -1) {
      pointer._o.splice(index, 1);
    }
  });
}

/**
 * Check to see if the pointer is currently over the object. Since multiple objects may be rendered on top of one another, only the top most object under the pointer will return true.
 *
 * ```js
 * import { initPointer, track, pointer, pointerOver, Sprite } from 'kontra';
 *
 * initPointer();
 *
 * let sprite1 = Sprite({
 *   x: 10,
 *   y: 10,
 *   width: 10,
 *   height: 10
 * });
 * let sprite2 = Sprite({
 *   x: 15,
 *   y: 10,
 *   width: 10,
 *   height: 10
 * });
 *
 * track(sprite1, sprite2);
 *
 * sprite1.render();
 * sprite2.render();
 *
 * pointer.x = 14;
 * pointer.y = 15;
 *
 * console.log(pointerOver(sprite1));  //=> false
 * console.log(pointerOver(sprite2));  //=> true
 * ```
 * @function pointerOver
 *
 * @param {Object} object - The object to check if the pointer is over.
 *
 * @returns {Boolean} `true` if the pointer is currently over the object, `false` otherwise.
 */
function pointerOver(object) {
  let canvas = object.context ? object.context.canvas : getCanvas();
  let pointer = pointers.get(canvas);

  // @ifdef DEBUG
  if (!pointer) {
    throw new ReferenceError('Pointer events not initialized for the objects canvas');
  }  // @endif

  return pointer._o.includes(object) && getCurrentObject(pointer) === object;
}

/**
 * Register a function to be called on all pointer down events. Is passed the original Event and the target object (if there is one).
 *
 * ```js
 * import { initPointer, onPointerDown } from 'kontra';
 *
 * initPointer();
 *
 * onPointerDown(function(e, object) {
 *   // handle pointer down
 * })
 * ```
 * @function onPointerDown
 *
 * @param {(evt: MouseEvent|TouchEvent, object?: Object) => void} callback - Function to call on pointer down.
 */
function onPointerDown(callback) {
  callbacks$1.onDown = callback;
}

/**
* Register a function to be called on all pointer up events. Is passed the original Event and the target object (if there is one).
 *
 * ```js
 * import { initPointer, onPointerUp } from 'kontra';
 *
 * initPointer();
 *
 * onPointerUp(function(e, object) {
 *   // handle pointer up
 * })
 * ```
 * @function onPointerUp
 *
 * @param {(evt: MouseEvent|TouchEvent, object?: Object) => void} callback - Function to call on pointer up.
 */
function onPointerUp(callback) {
  callbacks$1.onUp = callback;
}

/**
 * Check if a button is currently pressed. Use during an `update()` function to perform actions each frame.
 *
 * ```js
 * import { initPointer, pointerPressed } from 'kontra';
 *
 * initPointer();
 *
 * Sprite({
 *   update: function() {
 *     if (pointerPressed('left')){
 *       // left mouse button pressed
 *     }
 *     else if (pointerPressed('right')) {
 *       // right mouse button pressed
 *     }
 *   }
 * });
 * ```
 * @function pointerPressed
 *
 * @param {String} button - Button to check for pressed state.
 *
 * @returns {Boolean} `true` if the button is pressed, `false` otherwise.
 */
function pointerPressed(button) {
  return !!pressedButtons[button]
}

/**
 * An accessible button. Supports screen readers and keyboard navigation using the <kbd>Tab</kbd> key. The button is automatically [tracked](api/pointer#track) by the pointer and accepts all pointer functions, but you will still need to call [initPointer](api/pointer#initPointer) to have pointer events enabled.
 * @class Button
 * @extends Sprite
 *
 * @param {Object} [properties] - Properties of the button (in addition to all Sprite properties).
 * @param {Object} [properties.text] - Properties of [Text](api/text) which are used to create the [textNode](api/button#textNode).
 * @param {Number} [properties.padX=0] - The horizontal padding.
 * @param {Number} [properties.padY=0] - The vertical padding.
 * @param {Function} [properties.onEnable] - Function called when the button is enabled.
 * @param {Function} [properties.onDisable] - Function called when the button is disabled.
 * @param {Function} [properties.onFocus] - Function called when the button is focused by the keyboard.
 * @param {Function} [properties.onBlur] - Function called when the button losses focus either by the pointer or keyboard.
 */
class Button extends factory$3.class {
  /**
   * @docs docs/api_docs/button.js
   */

  init({
    /**
     * The horizontal padding. This will be added to the width to give the final width of the button.
     * @memberof Button
     * @property {Number} padX
     */
    padX = 0,

    /**
     * The vertical padding. This will be added to the height to give the final height of the button.
     * @memberof Button
     * @property {Number} padY
     */
    padY = 0,

    text,
    onDown,
    onUp,
    ...props
  } = {}) {
    super.init({
      padX,
      padY,
      ...props
    });

    /**
     * Each Button creates a Text object and adds it as a child. The `text` of the Text object is used as the accessible name of the HTMLButtonElement.
     * @memberof Button
     * @property {Text} textNode
     */
    this.textNode = factory$4({
      ...text,

      // ensure the text uses the same context as the button
      context: this.context
    });

    // if the user didn't set a width/height or use an image
    // default to the textNode dimensions
    if (!this.width) {
      this.width = this.textNode.width;
      this.height = this.textNode.height;
    }

    track(this);
    this.addChild(this.textNode);

    // od = on down
    this._od = onDown || noop;

    // ou = on up
    this._ou = onUp || noop;

    // create an accessible DOM node for screen readers
    // dn = dom node
    const button = this._dn = document.createElement('button');
    button.style = srOnlyStyle;
    button.textContent = this.text;

    // sync events between the button element and the class
    button.addEventListener('focus', () => this.focus());
    button.addEventListener('blur', () => this.blur());
    button.addEventListener('keydown', (evt) => this._kd(evt));
    button.addEventListener('keyup', (evt) => this._ku(evt));

    addToDom(button, this.context.canvas);

    this._uw();
    this._p();
  }

  /**
   * The text property of the Text object.
   * @memberof Button
   * @property {String} text
   */
  get text() {
    return this.textNode.text;
  }

  set text(value) {
    // d = dirty
    this._d = true;
    this.textNode.text = value;
  }

  /**
   * Clean up the button by removing the HTMLButtonElement from the DOM.
   * @memberof Button
   * @function destroy
   */
  destroy() {
    this._dn.remove();
  }

  _p() {
    // update DOM node text if it has changed
    if (this.text !== this._dn.textContent) {
      this._dn.textContent = this.text;
    }

    // update width and height (need to prerender the button
    // first)
    this.textNode._p();

    let width = this.textNode.width + this.padX * 2;
    let height = this.textNode.height + this.padY * 2;

    this.width = Math.max(width, this.width);
    this.height = Math.max(height, this.height);
    this._uw();
  }

  render() {
    if (this._d) {
      this._p();
    }

    super.render();
  }

  /**
   * Enable the button. Calls [onEnable](api/button#onEnable) if passed.
   * @memberof Button
   * @function enable
   */
  enable() {

    /**
     * If the button is disabled.
     * @memberof Button
     * @property {Boolean} disabled
     */
    this.disabled = this._dn.disabled = false;
    this.onEnable();
  }

  /**
   * Disable the button. A disabled button will not longer render nor respond to pointer and keyboard events. Calls [onDisable](api/button#onDisable) if passed.
   * @memberof Button
   * @function disable
   */
  disable() {
    this.disabled = this._dn.disabled = true;
    this.onDisable();
  }

  /**
   * Focus the button. Calls [onFocus](api/button#onFocus) if passed.
   * @memberof Button
   * @function focus
   */
  focus() {
    if (!this.disabled) {

      /**
       * If the button is focused.
       * @memberof Button
       * @property {Boolean} focused
       */
      this.focused = true;
      // prevent infinite loop
      if (document.activeElement != this._dn) this._dn.focus();

      this.onFocus();
    }
  }

  /**
   * Blur the button. Calls [onBlur](api/button#onBlur) if passed.
   * @memberof Button
   * @function blur
   */
  blur() {
    this.focused = false;
    // prevent infinite loop
    if (document.activeElement == this._dn) this._dn.blur();

    this.onBlur();
  }

  onOver() {
    if (!this.disabled) {

      /**
       * If the button is hovered.
       * @memberof Button
       * @property {Boolean} hovered
       */
      this.hovered = true;
    }
  }

  onOut() {
    this.hovered = false;
  }

  /**
   * Function called when then button is enabled. Override this function to have the button do something when enabled.
   * @memberof Button
   * @function onEnable
   */
  onEnable() {}

  /**
   * Function called when then button is disabled. Override this function to have the button do something when disabled.
   * @memberof Button
   * @function onDisable
   */
  onDisable() {}

  /**
   * Function called when then button is focused. Override this function to have the button do something when focused.
   * @memberof Button
   * @function onFocus
   */
  onFocus() {}

  /**
   * Function called when then button is blurred. Override this function to have the button do something when blurred.
   * @memberof Button
   * @function onBlur
   */
  onBlur() {}

  onDown() {
    if (!this.disabled) {

      /**
       * If the button is pressed.
       * @memberof Button
       * @property {Boolean} pressed
       */
      this.pressed = true;
      this._od();
    }
  }

  onUp() {
    if (!this.disabled) {
      this.pressed = false;
      this._ou();
    }
  }

  // kd = keydown
  _kd(evt) {
    // activate button on enter or space
    if (evt.code == 'Enter' || evt.code == 'Space') {
      this.onDown();
    }
  }

  // kd = keydown
  _ku(evt) {
    // activate button on enter or space
    if (evt.code == 'Enter' || evt.code == 'Space') {
      this.onUp();
    }
  }
}

function factory$5() {
  return new Button(...arguments);
}
factory$5.prototype = Button.prototype;
factory$5.class = Button;

/**
 * Clear the canvas.
 */
function clear(context) {
  let canvas = context.canvas;
  context.clearRect(0, 0, canvas.width, canvas.height);
}

/**
 * The game loop updates and renders the game every frame. The game loop is stopped by default and will not start until the loops `start()` function is called.
 *
 * The game loop uses a time-based animation with a fixed `dt` to [avoid frame rate issues](http://blog.sklambert.com/using-time-based-animation-implement/). Each update call is guaranteed to equal 1/60 of a second.
 *
 * This means that you can avoid having to do time based calculations in your update functions and instead do fixed updates.
 *
 * ```js
 * import { Sprite, GameLoop } from 'kontra';
 *
 * let sprite = Sprite({
 *   x: 100,
 *   y: 200,
 *   width: 20,
 *   height: 40,
 *   color: 'red'
 * });
 *
 * let loop = GameLoop({
 *   update: function(dt) {
 *     // no need to determine how many pixels you want to
 *     // move every second and multiple by dt
 *     // sprite.x += 180 * dt;
 *
 *     // instead just update by how many pixels you want
 *     // to move every frame and the loop will ensure 60FPS
 *     sprite.x += 3;
 *   },
 *   render: function() {
 *     sprite.render();
 *   }
 * });
 *
 * loop.start();
 * ```
 * @class GameLoop
 *
 * @param {Object} properties - Properties of the game loop.
 * @param {(dt: Number) => void} [properties.update] - Function called every frame to update the game. Is passed the fixed `dt` as a parameter.
 * @param {Function} properties.render - Function called every frame to render the game.
 * @param {Number}   [properties.fps=60] - Desired frame rate.
 * @param {Boolean}  [properties.clearCanvas=true] - Clear the canvas every frame before the `render()` function is called.
 * @param {CanvasRenderingContext2D} [properties.context] - The context that should be cleared each frame if `clearContext` is not set to `false`. Defaults to [core.getContext()](api/core#getContext).
 * @param {Boolean} [properties.blur=false] - If the loop should still update and render if the page does not have focus.
 */
function GameLoop({
  fps = 60,
  clearCanvas = true,
  update = noop,
  render,
  context = getContext(),
  blur = false
} = {}) {
  // check for required functions
  // @ifdef DEBUG
  if (!render) {
    throw Error('You must provide a render() function');
  }
  // @endif

  // animation variables
  let accumulator = 0;
  let delta = 1E3 / fps;  // delta between performance.now timings (in ms)
  let step = 1 / fps;
  let clearFn = clearCanvas ? clear : noop;
  let last, rAF, now, dt, loop;
  let focused = true;

  if (!blur) {
    window.addEventListener('focus', () => { focused = true; });
    window.addEventListener('blur', () => { focused = false; });
  }

  /**
   * Called every frame of the game loop.
   */
  function frame() {
    rAF = requestAnimationFrame(frame);

    // don't update the frame if tab isn't focused
    if (!focused) return;

    now = performance.now();
    dt = now - last;
    last = now;

    // prevent updating the game with a very large dt if the game were to lose focus
    // and then regain focus later
    if (dt > 1E3) {
      return;
    }

    emit('tick');
    accumulator += dt;

    while (accumulator >= delta) {
      loop.update(step);

      accumulator -= delta;
    }

    clearFn(context);
    loop.render();
  }

  // game loop object
  loop = {
    /**
     * Called every frame to update the game. Put all of your games update logic here.
     * @memberof GameLoop
     * @function update
     *
     * @param {Number} [dt] - The fixed dt time of 1/60 of a frame.
     */
    update,

    /**
     * Called every frame to render the game. Put all of your games render logic here.
     * @memberof GameLoop
     * @function render
     */
    render,

    /**
     * If the game loop is currently stopped.
     *
     * ```js
     * import { GameLoop } from 'kontra';
     *
     * let loop = GameLoop({
     *   // ...
     * });
     * console.log(loop.isStopped);  //=> true
     *
     * loop.start();
     * console.log(loop.isStopped);  //=> false
     *
     * loop.stop();
     * console.log(loop.isStopped);  //=> true
     * ```
     * @memberof GameLoop
     * @property {Boolean} isStopped
     */
    isStopped: true,

    /**
     * Start the game loop.
     * @memberof GameLoop
     * @function start
     */
    start() {
      last = performance.now();
      this.isStopped = false;
      requestAnimationFrame(frame);
    },

    /**
     * Stop the game loop.
     * @memberof GameLoop
     * @function stop
     */
    stop() {
      this.isStopped = true;
      cancelAnimationFrame(rAF);
    },

    // expose properties for testing
    // @ifdef DEBUG
    _frame: frame,
    set _last(value) {
      last = value;
    }
    // @endif
  };

  return loop;
}

let handler = {
  set(obj, prop, value) {

    // don't set dirty for private properties
    if (!prop.startsWith('_')) {
      obj._d = true;
    }

    return Reflect.set(obj, prop, value);
  }
};

let alignment = {
  start(rtl) {
    return rtl ? 1 : 0;
  },
  center() {
    return 0.5;
  },
  end(rtl) {
    return rtl ? 0 : 1;
  }
};

/**
 * Quickly and easily organize your UI elements into a grid. Works great for auto placing menu options without having to figure out the position for each one. Based on the concept of CSS Grid Layout.
 * @class Grid
 * @extends GameObject
 *
 * @param {Object} [properties] - Properties of the grid manager.
 * @param {String} [properties.flow='column'] - The flow of the grid.
 * @param {String} [properties.align='start'] - The vertical alignment of the grid.
 * @param {String} [properties.justify='start'] - The horizontal alignment of the grid.
 * @param {Number|Number[]} [properties.colGap=0] - The horizontal gap between each column in the grid.
 * @param {Number|Number[]} [properties.rowGap=0] - The vertical gap between each row in the grid.
 * @param {Number} [properties.numCols=1] - The number of columns in the grid. Only applies if the `flow` property is set to `grid`.
 * @param {String} [properties.dir=''] - The direction of the grid.
 * @param {{metric: Function, callback: Function}[]} [properties.breakpoints=[]] - How the grid should change based on different metrics.
 */
class Grid extends factory$2.class {
  /**
   * @docs docs/api_docs/grid.js
   */

  init({
    /**
     * How to organize all objects in the grid. Valid values are:
     *
     * - `column` - organize into a single column
     * - `row` - organize into a single row
     * - `grid` - organize into a grid with [numCols](api/grid#numCols) number of columns
     * @memberof Grid
     * @property {String} flow
     */
    flow = 'column',

    /**
     * The vertical alignment of the grid. Valid values are:
     *
     * - `start` - align to the top of row
     * - `center` - align to the center of the row
     * - `end` - align to the the bottom of the row
     *
     * Additionally, each child of the grid can use the `alignSelf` property to change it's alignment in the grid.
     * @memberof Grid
     * @property {String} align
     */
    align = 'start',

    /**
     * The horizontal alignment of the grid. Valid values are:
     *
     * - `start` - align to the left of column
     * - `center` - align to the center of the column
     * - `end` - align to the the right of the column
     *
     * If the [dir](api/grid#dir) property is set to `rtl`, then `start` and `end` are reversed.
     *
     * Additionally, each child of the grid can use the `justifySelf` property to change it's alignment in the grid.
     * @memberof Grid
     * @property {String} justify
     */
    justify = 'start',

    /**
     * The horizontal gap between each column in the grid.
     *
     * An array of numbers means the grid will set the gap between columns using the order of the array. For example, if the gap is set to be `[10, 5]`, then every odd column gap with use 10 and every even column gap will use 5.
     * @memberof Grid
     * @property {Number|Number[]} colGap
     */
    colGap = 0,

     /**
     * The vertical gap between each row in the grid.
     *
     * An array of numbers means the grid will set the gap between rows using the order of the array. For example, if the gap is set to be `[10, 5]`, then every odd row gap with use 10 and every even row gap will use 5.
     * @memberof Grid
     * @property {Number|Number[]} rowGap
     */
    rowGap = 0,

    /**
     * The number of columns in the grid. Only applies if the [flow](api/grid#flow) property is set to `grid`.
     * @memberof Grid
     * @property {Number} numCols
     */
    numCols = 1,

    /**
     * The direction of the grid. Defaults to organizing the grid objects left-to-right, but if set to `rtl` then the grid is organized right-to-left.
     *
     * When determining the direction of the grid, the canvas `dir` attribute is also taken into account. Setting the attribute to `rtl` is equivalent to setting the `dir` property to `rtl`. The `dir` property is used instead of the canvas attribute if both are set.
     * @memberof Grid
     * @property {String} dir
     */
    dir = '',

    /**
     * How the grid should change based on different metrics. Based on the concept of CSS Media Queries so you can update how the grid organizes the objects when things change (such as the scale).
     *
     * Each object in the array uses the `metric()` function to determine when the breakpoint applies and the `callback()` function is called to change any properties of the grid.
     *
     * ```js
     * let { Grid } = kontra;
     *
     * let grid = Grid({
     *   breakpoints: [{
     *     metric() {
     *       return this.scaleX < 1
     *     },
     *     callback() {
     *       this.numCols = 1;
     *     }
     *   },
     *   {
     *     metric() {
     *       return this.scaleX >= 1
     *     },
     *     callback() {
     *       this.numCols = 2;
     *     }
     *   }]
     * });
     * ```
     * @memberof Grid
     * @property {{metric: Function, callback: Function}[]} breakpoints
     */
    breakpoints = [],

    ...props
  } = {}) {
    super.init({
      flow,
      align,
      justify,
      colGap,
      rowGap,
      numCols,
      dir,
      breakpoints,
      ...props
    });

    this._p();
    return new Proxy(this, handler);
  }

  addChild(child) {
    this._d = true;
    super.addChild(child);
  }

  removeChild(child) {
    this._d = true;
    super.removeChild(child);
  }

  render() {
    if (this._d) {
      this._p();
    }
    super.render();
  }

  /**
   * Call `destroy()` on all children.
   * @memberof Grid
   * @function destroy
   */
  destroy() {
    this.children.map(child => child.destroy && child.destroy());
  }

  /**
   * Build the grid and calculate its width and height
   */
  _p() {
    this._d = false;

    this.breakpoints.map(breakpoint => {
      // b = breakpoint
      if (breakpoint.metric.call(this) && this._b !== breakpoint) {
        this._b = breakpoint;
        breakpoint.callback.call(this);
      }
    });

    // g = grid, cw = colWidths, rh = rowHeights
    let grid = this._g = [];
    let colWidths = this._cw = [];
    let rowHeights = this._rh = [];
    let children = this.children;

    // nc = numCols
    let numCols = this._nc = this.flow === 'column'
      ? 1
      : this.flow === 'row'
        ? children.length
        : this.numCols;

    let row = 0;
    let col = 0;
    for (let i = 0, child; child = children[i]; i++) {
      grid[row] = grid[row] || [];

      // prerender child to get current width/height
      if (child._p) {
        child._p();
      }

      rowHeights[row] = Math.max(rowHeights[row] || 0, child.height);

      let spans = child.colSpan || 1;
      let colSpan = spans;
      do {
        colWidths[col] = Math.max(colWidths[col] || 0, child.width / colSpan);
        grid[row][col] = child;
      } while (colSpan + col++ <= numCols && --spans);

      if (col >= numCols) {
        col = 0;
        row++;
      }
    }

    // fill remaining row
    while (col > 0 && col < numCols) {
      // add empty array item so we can reverse a row even when it
      // contains less items than another row
      grid[row][col++] = false;
    }
    let numRows = grid.length;

    let colGap = [].concat(this.colGap);
    let rowGap = [].concat(this.rowGap);

    this._w = colWidths.reduce((acc, width) => acc += width, 0);
    for (let i = 0; i < numCols - 1; i++) {
      this._w += colGap[i % colGap.length];
    }

    this._h = rowHeights.reduce((acc, height) => acc += height, 0);
    for (let i = 0; i < numRows - 1; i++) {
      this._h += rowGap[i % rowGap.length];
    }

    this._uw();

    // reverse columns. direction property overrides canvas dir
    let dir = this.context.canvas.dir;
    let rtl = (dir === 'rtl' && !this.dir) || this.dir === 'rtl';
    this._rtl = rtl;
    if (rtl) {
      this._g = grid.map(row => row.reverse());
      this._cw = colWidths.reverse();
      colGap = colGap.reverse();
    }

    let topLeftY = -this.anchor.y * this.height;
    let rendered = [];

    this._g.map((gridRow, row) => {
      let topLeftX = -this.anchor.x * this.width;

      gridRow.map((child, col) => {
        // don't render the same child multiple times if it uses colSpan
        if (child && !rendered.includes(child)) {
          rendered.push(child);

          let justify = alignment[child.justifySelf || this.justify](this._rtl);
          let align = alignment[child.alignSelf || this.align]();

          let colSpan = child.colSpan || 1;
          let colWidth = colWidths[col];
          if (colSpan > 1 && col + colSpan <= this._nc) {
            for (let i = 1; i < colSpan; i++) {
              colWidth += colWidths[col + i] + colGap[(col + i) % colGap.length];
            }
          }

          let pointX = colWidth * justify;
          let pointY = rowHeights[row] * align;
          let anchorX = 0;
          let anchorY = 0;
          let { width, height } = child;

          if (child.anchor) {
            anchorX = child.anchor.x;
            anchorY = child.anchor.y;
          }

          // calculate the x position based on the alignment and
          // anchor of the object
          if (justify === 0) {
            pointX = pointX + width * anchorX;
          }
          else if (justify === 0.5) {
            let sign = anchorX < 0.5 ? -1 : anchorX === 0.5 ? 0 : 1;
            pointX = pointX + sign * width * justify;
          }
          else {
            pointX = pointX - (width * (1 - anchorX));
          }

          // calculate the y position based on the justification and
          // anchor of the object
          if (align === 0) {
            pointY = pointY + height * anchorY;
          }
          else if (align === 0.5) {
            let sign = anchorY < 0.5 ? -1 : anchorY === 0.5 ? 0 : 1;
            pointY = pointY + sign * height * align;
          }
          else {
            pointY = pointY - (height * (1 - anchorY));
          }

          child.x = topLeftX + pointX;
          child.y = topLeftY + pointY;
        }

        topLeftX += colWidths[col] + colGap[col % colGap.length];
      });

      topLeftY += rowHeights[row] + rowGap[row % rowGap.length];
    });
  }
}

function factory$6() {
  return new Grid(...arguments);
}
factory$6.prototype = Grid.prototype;
factory$6.class = Grid;

/**
 * A minimalistic keyboard API. You can use it move the main sprite or respond to a key press.
 *
 * ```js
 * import { initKeys, keyPressed } from 'kontra';
 *
 * // this function must be called first before keyboard
 * // functions will work
 * initKeys();
 *
 * function update() {
 *   if (keyPressed('left')) {
 *     // move left
 *   }
 * }
 * ```
 * @sectionName Keyboard
 */

/**
 * Below is a list of keys that are provided by default. If you need to extend this list, you can use the [keyMap](api/keyboard#keyMap) property.
 *
 * - a-z
 * - 0-9
 * - enter, esc, space, left, up, right, down
 * @sectionName Available Keys
 */

let keydownCallbacks = {};
let keyupCallbacks = {};
let pressedKeys = {};

/**
 * A map of [KeyboardEvent code values](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values) to key names. Add to this object to expand the list of [available keys](api/keyboard#available-keys).
 *
 * ```js
 * import { keyMap, bindKeys } from 'kontra';
 *
 * keyMap['ControlRight'] = 'ctrl';
 *
 * bindKeys('ctrl', function(e) {
 *   // handle ctrl key
 * });
 * ```
 * @property {{[key in (String|Number)]: string}} keyMap
 */
let keyMap = {
  // named keys
  'Enter': 'enter',
  'Escape': 'esc',
  'Space': 'space',
  'ArrowLeft': 'left',
  'ArrowUp': 'up',
  'ArrowRight': 'right',
  'ArrowDown': 'down'
};

/**
 * Call the callback handler of an event.
 * @param {Function} callback
 * @param {KeyboardEvent} evt
 */
function call(callback = noop, evt) {
  if (callback._pd) {
    evt.preventDefault();
  }
  callback(evt);
}

/**
 * Execute a function that corresponds to a keyboard key.
 *
 * @param {KeyboardEvent} evt
 */
function keydownEventHandler(evt) {
  let key = keyMap[evt.code];
  let callback = keydownCallbacks[key];
  pressedKeys[key] = true;
  call(callback, evt);
}

/**
 * Set the released key to not being pressed.
 *
 * @param {KeyboardEvent} evt
 */
function keyupEventHandler(evt) {
  let key = keyMap[evt.code];
  let callback = keyupCallbacks[key];
  pressedKeys[key] = false;
  call(callback, evt);
}

/**
 * Reset pressed keys.
 */
function blurEventHandler$1() {
  pressedKeys = {};
}

/**
 * Initialize keyboard event listeners. This function must be called before using other keyboard functions.
 * @function initKeys
 */
function initKeys() {
  let i;

  // alpha keys
  // @see https://stackoverflow.com/a/43095772/2124254
  for (i = 0; i < 26; i++) {
    // rollupjs considers this a side-effect (for now), so we'll do it in the
    // initKeys function
    keyMap[i + 65] = keyMap['Key' + String.fromCharCode(i + 65)] = String.fromCharCode(i + 97);
  }

  // numeric keys
  for (i = 0; i < 10; i++) {
    keyMap[48+i] = keyMap['Digit'+i] = ''+i;
  }

  window.addEventListener('keydown', keydownEventHandler);
  window.addEventListener('keyup', keyupEventHandler);
  window.addEventListener('blur', blurEventHandler$1);
}

/**
 * Bind a set of keys that will call the callback function when they are pressed. Takes a single key or an array of keys. Is passed the original KeyboardEvent as a parameter.
 *
 * By default, the default action will be prevented for any bound key. To not do this, pass the `preventDefault` option.
 *
 * ```js
 * import { initKeys, bindKeys } from 'kontra';
 *
 * initKeys();
 *
 * bindKeys('p', function(e) {
 *   // pause the game
 * }, 'keyup');
 * bindKeys(['enter', 'space'], function(e) {
 *   // fire gun
 * });
 * ```
 * @function bindKeys
 *
 * @param {String|String[]} keys - Key or keys to bind.
 * @param {(evt: KeyboardEvent) => void} callback - The function to be called when the key is pressed.
 * @param {Object} [options] - Bind options.
 * @param {'keydown'|'keyup'} [options.handler=keydown] - Whether to bind to keydown or keyup events.
 * @param {Boolean} [options.preventDefault=true] - Call `event. preventDefault()` when the key is activated.
 */
function bindKeys(keys, callback, {
  handler = 'keydown',
  preventDefault = true
} = {}) {
  const callbacks = handler == 'keydown' ? keydownCallbacks : keyupCallbacks;
  // pd = preventDefault
  callback._pd = preventDefault;
  // smaller than doing `Array.isArray(keys) ? keys : [keys]`
  [].concat(keys).map(key => callbacks[key] = callback);
}

/**
 * Remove the callback function for a bound set of keys. Takes a single key or an array of keys.
 *
 * ```js
 * import { unbindKeys } from 'kontra';
 *
 * unbindKeys('left');
 * unbindKeys(['enter', 'space']);
 * ```
 * @function unbindKeys
 *
 * @param {String|String[]} keys - Key or keys to unbind.
 * @param {Object} [options] - Unbind options.
 * @param {'keydown'|'keyup'} [options.handler=keydown] - Whether to unbind from keydown or keyup events.
 */
function unbindKeys(keys, {
  handler = 'keydown'
} = {}) {
  const callbacks = handler == 'keydown' ? keydownCallbacks : keyupCallbacks;
  // 0 is the smallest falsy value
  [].concat(keys).map(key => callbacks[key] = 0);
}

/**
 * Check if a key is currently pressed. Use during an `update()` function to perform actions each frame.
 *
 * ```js
 * import { Sprite, initKeys, keyPressed } from 'kontra';
 *
 * initKeys();
 *
 * let sprite = Sprite({
 *   update: function() {
 *     if (keyPressed('left')){
 *       // left arrow pressed
 *     }
 *     else if (keyPressed('right')) {
 *       // right arrow pressed
 *     }
 *
 *     if (keyPressed('up')) {
 *       // up arrow pressed
 *     }
 *     else if (keyPressed('down')) {
 *       // down arrow pressed
 *     }
 *   }
 * });
 * ```
 * @function keyPressed
 *
 * @param {String} key - Key to check for pressed state.
 *
 * @returns {Boolean} `true` if the key is pressed, `false` otherwise.
 */
function keyPressed(key) {
  return !!pressedKeys[key];
}

/**
 * A plugin system based on the [interceptor pattern](https://en.wikipedia.org/wiki/Interceptor_pattern), designed to share reusable code such as more advance collision detection or a 2D physics engine.
 *
 * ```js
 * import { registerPlugin, Sprite } from 'kontra';
 * import loggingPlugin from 'path/to/plugin/code.js'
 *
 * // register a plugin that adds logging to all Sprites
 * registerPlugin(Sprite, loggingPlugin);
 * ```
 * @sectionName Plugin
 */

/**
 * @docs docs/api_docs/plugin.js
 */

/**
 * Get the kontra object method name from the plugin.
 *
 * @param {String} methodName - Before/After function name
 *
 * @returns {String}
 */
function getMethod(methodName) {
  let methodTitle = methodName.substr( methodName.search(/[A-Z]/) );
  return methodTitle[0].toLowerCase() + methodTitle.substr(1);
}

/**
 * Remove an interceptor.
 *
 * @param {function[]} interceptors - Before/After interceptor list
 * @param {function} fn - Interceptor function
 */
function removeInterceptor(interceptors, fn) {
  let index = interceptors.indexOf(fn);
  if (index !== -1) {
    interceptors.splice(index, 1);
  }
}

/**
 * Register a plugin to run a set of functions before or after the Kontra object functions.
 * @function registerPlugin
 *
 * @param {Object} kontraObj - Kontra object to attach the plugin to.
 * @param {Object} pluginObj - Plugin object with before and after intercept functions.
 */
function registerPlugin(kontraObj, pluginObj) {
  let objectProto = kontraObj.prototype;

  if (!objectProto) return;

  // create interceptor list and functions
  if (!objectProto._inc) {
    objectProto._inc = {};
    objectProto._bInc = function beforePlugins(context, method, ...args) {
      return this._inc[method].before.reduce((acc, fn) => {
        let newArgs = fn(context, ...acc);
        return newArgs ? newArgs : acc;
      }, args);
    };
    objectProto._aInc = function afterPlugins(context, method, result, ...args) {
      return this._inc[method].after.reduce((acc, fn) => {
        let newResult = fn(context, acc, ...args);
        return newResult ? newResult : acc;
      }, result);
    };
  }

  // add plugin to interceptors
  Object.getOwnPropertyNames(pluginObj).forEach(methodName => {
    let method = getMethod(methodName);

    if (!objectProto[method]) return;

    // override original method
    if (!objectProto['_o' + method]) {
      objectProto['_o' + method] = objectProto[method];

      objectProto[method] = function interceptedFn(...args) {

        // call before interceptors
        let alteredArgs = this._bInc(this, method, ...args);

        let result = objectProto['_o' + method].call(this, ...alteredArgs);

        // call after interceptors
        return this._aInc(this, method, result, ...args);
      };
    }

    // create interceptors for the method
    if (!objectProto._inc[method]) {
      objectProto._inc[method] = {
        before: [],
        after: []
      };
    }

    if (methodName.startsWith('before')) {
      objectProto._inc[method].before.push(pluginObj[methodName]);
    }
    else if (methodName.startsWith('after')) {
      objectProto._inc[method].after.push(pluginObj[methodName]);
    }
  });
}

/**
 * Unregister a plugin from a Kontra object.
 * @function unregisterPlugin
 *
 * @param {Object} kontraObj - Kontra object to detach plugin from.
 * @param {Object} pluginObj - The plugin object that was passed during registration.
 */
function unregisterPlugin(kontraObj, pluginObj) {
  let objectProto = kontraObj.prototype;

  if (!objectProto || !objectProto._inc) return;

  // remove plugin from interceptors
  Object.getOwnPropertyNames(pluginObj).forEach(methodName => {
    let method = getMethod(methodName);

    if (methodName.startsWith('before')) {
      removeInterceptor(objectProto._inc[method].before, pluginObj[methodName]);
    }
    else if (methodName.startsWith('after')) {
      removeInterceptor(objectProto._inc[method].after, pluginObj[methodName]);
    }
  });
}

/**
 * Safely extend the functionality of a Kontra object. Any properties that already exist on the Kontra object will not be added.
 *
 * ```js
 * import { extendObject, Vector } from 'kontra';
 *
 * // add a subtract function to all Vectors
 * extendObject(Vector, {
 *   subtract(vec) {
 *     return Vector(this.x - vec.x, this.y - vec.y);
 *   }
 * });
 * ```
 * @function extendObject
 *
 * @param {Object} kontraObj - Kontra object to extend
 * @param {Object} properties - Properties to add.
 */
function extendObject(kontraObj, properties) {
  let objectProto = kontraObj.prototype;

  if (!objectProto) return;

  Object.getOwnPropertyNames(properties).forEach(prop => {
    if (!objectProto[prop]) {
      objectProto[prop] = properties[prop];
    }
  });
}

/**
 * A fast and memory efficient [object pool](https://gameprogrammingpatterns.com/object-pool.html) for sprite reuse. Perfect for particle systems or SHUMPs. The pool starts out with just one object, but will grow in size to accommodate as many objects as are needed.
 *
 * <canvas width="600" height="200" id="pool-example"></canvas>
 * <script src="assets/js/pool.js"></script>
 * @class Pool
 *
 * @param {Object} properties - Properties of the pool.
 * @param {() => {update: (dt?: number) => void, render: Function, init: (properties?: object) => void, isAlive: () => boolean}} properties.create - Function that returns a new object to be added to the pool when there are no more alive objects.
 * @param {Number} [properties.maxSize=1024] - The maximum number of objects allowed in the pool. The pool will never grow beyond this size.
 */
class Pool {
  /**
   * @docs docs/api_docs/pool.js
   */

  constructor({create, maxSize = 1024} = {}) {

    // check for the correct structure of the objects added to pools so we know that the
    // rest of the pool code will work without errors
    // @ifdef DEBUG
    let obj;
    if (!create ||
        ( !( obj = create() ) ||
          !( obj.update && obj.init &&
             obj.isAlive && obj.render)
       )) {
      throw Error('Must provide create() function which returns an object with init(), update(), render(), and isAlive() functions');
    }
    // @endif

    // c = create
    this._c = create;

    /**
     * All objects currently in the pool, both alive and not alive.
     * @memberof Pool
     * @property {Object[]} objects
     */
    this.objects = [create()]; // start the pool with an object

    /**
     * The number of alive objects.
     * @memberof Pool
     * @property {Number} size
     */
    this.size = 0;

    /**
     * The maximum number of objects allowed in the pool. The pool will never grow beyond this size.
     * @memberof Pool
     * @property {Number} maxSize
     */
    this.maxSize = maxSize;
  }

  /**
   * Get and return an object from the pool. The properties parameter will be passed directly to the objects `init()` function. If you're using a [Sprite](api/sprite), you should also pass the `ttl` property to designate how many frames you want the object to be alive for.
   *
   * If you want to control when the sprite is ready for reuse, pass `Infinity` for `ttl`. You'll need to set the sprites `ttl` to `0` when you're ready for the sprite to be reused.
   *
   * ```js
   * // exclude-tablist
   * let sprite = pool.get({
   *   // the object will get these properties and values
   *   x: 100,
   *   y: 200,
   *   width: 20,
   *   height: 40,
   *   color: 'red',
   *
   *   // pass Infinity for ttl to prevent the object from being reused
   *   // until you set it back to 0
   *   ttl: Infinity
   * });
   * ```
   * @memberof Pool
   * @function get
   *
   * @param {Object} [properties] - Properties to pass to the objects `init()` function.
   *
   * @returns {Object} The newly initialized object.
   */
  get(properties = {}) {
    // the pool is out of objects if the first object is in use and it can't grow
    if (this.size === this.objects.length) {
      if (this.size === this.maxSize) {
        return;
      }
      // double the size of the array by adding twice as many new objects to the end
      else {
        for (let i = 0; i < this.size && this.objects.length < this.maxSize; i++) {
          this.objects.push(this._c());
        }
      }
    }

    // save off first object in pool to reassign to last object after unshift
    let obj = this.objects[this.size];
    this.size++;
    obj.init(properties);
    return obj;
  }

  /**
   * Returns an array of all alive objects. Useful if you need to do special processing on all alive objects outside of the pool, such as to add all alive objects to a [Quadtree](api/quadtree).
   * @memberof Pool
   * @function getAliveObjects
   *
   * @returns {Object[]} An Array of all alive objects.
   */
  getAliveObjects() {
    return this.objects.slice(0, this.size);
  }

  /**
   * Clear the object pool. Removes all objects from the pool and resets its [size](api/pool#size) to 1.
   * @memberof Pool
   * @function clear
   */
  clear() {
    this.size = this.objects.length = 0;
    this.objects.push(this._c());
  }

  /**
   * Update all alive objects in the pool by calling the objects `update()` function. This function also manages when each object should be recycled, so it is recommended that you do not call the objects `update()` function outside of this function.
   * @memberof Pool
   * @function update
   *
   * @param {Number} [dt] - Time since last update.
   */
  update(dt) {
    let obj;
    let doSort = false;
    for (let i = this.size; i--; ) {
      obj = this.objects[i];

      obj.update(dt);

      if (!obj.isAlive()) {
        doSort = true;
        this.size--;
      }
    }
    // sort all dead elements to the end of the pool
    if (doSort) {
      this.objects.sort((a, b) => b.isAlive() - a.isAlive());
    }
  }

  /**
   * Render all alive objects in the pool by calling the objects `render()` function.
   * @memberof Pool
   * @function render
   */
  render() {
    for (let i = this.size; i--; ) {
      this.objects[i].render();
    }
  }
}

function factory$7() {
  return new Pool(...arguments);
}
factory$7.prototype = Pool.prototype;
factory$7.class = Pool;

/**
 * Determine which subnodes the object intersects with
 *
 * @param {Object} object - Object to check.
 * @param {{x: number, y: number, width: number, height: number}} bounds - Bounds of the quadtree.
 *
 * @returns {Number[]} List of all subnodes object intersects.
 */
function getIndices(object, bounds) {
  let indices = [];

  let verticalMidpoint = bounds.x + bounds.width / 2;
  let horizontalMidpoint = bounds.y + bounds.height / 2;

  let { x, y, width, height } = getWorldRect(object);

  // save off quadrant checks for reuse
  let intersectsTopQuadrants = object.y < horizontalMidpoint;
  let intersectsBottomQuadrants = object.y + object.height >= horizontalMidpoint;

  // object intersects with the left quadrants
  if (object.x < verticalMidpoint) {
    if (intersectsTopQuadrants) {  // top left
      indices.push(0);
    }

    if (intersectsBottomQuadrants) {  // bottom left
      indices.push(2);
    }
  }

  // object intersects with the right quadrants
  if (object.x + object.width >= verticalMidpoint) {
    if (intersectsTopQuadrants) {  // top right
      indices.push(1);
    }

    if (intersectsBottomQuadrants) {  // bottom right
      indices.push(3);
    }
  }

  return indices;
}

/*
The quadtree acts like an object pool in that it will create subnodes as objects are needed but it won't clean up the subnodes when it collapses to avoid garbage collection.

The quadrant indices are numbered as follows (following a z-order curve):
     |
  0  |  1
 ----+----
  2  |  3
     |
*/


/**
 * A 2D [spatial partitioning](https://gameprogrammingpatterns.com/spatial-partition.html) data structure. Use it to quickly group objects by their position for faster access and collision checking.
 *
 * <canvas width="600" height="200" id="quadtree-example"></canvas>
 * <script src="assets/js/quadtree.js"></script>
 * @class Quadtree
 *
 * @param {Object} [properties] - Properties of the quadtree.
 * @param {Number} [properties.maxDepth=3] - Maximum node depth of the quadtree.
 * @param {Number} [properties.maxObjects=25] - Maximum number of objects a node can have before splitting.
 * @param {{x: Number, y: Number, width: Number, height: Number}} [properties.bounds] - The 2D space (x, y, width, height) the quadtree occupies. Defaults to the entire canvas width and height.
 */
class Quadtree {
  /**
   * @docs docs/api_docs/quadtree.js
   */

  constructor({maxDepth = 3, maxObjects = 25, bounds} = {}) {

    /**
     * Maximum node depth of the quadtree.
     * @memberof Quadtree
     * @property {Number} maxDepth
     */
    this.maxDepth = maxDepth;

    /**
     * Maximum number of objects a node can have before splitting.
     * @memberof Quadtree
     * @property {Number} maxObjects
     */
    this.maxObjects = maxObjects;

    /**
     * The 2D space (x, y, width, height) the quadtree occupies.
     * @memberof Quadtree
     * @property {{x: Number, y: Number, width: Number, height: Number}} bounds
     */
    let canvas = getCanvas();
    this.bounds = bounds || {
      x: 0,
      y: 0,
      width: canvas.width,
      height: canvas.height
    };

    // since we won't clean up any subnodes, we need to keep track of which nodes are
    // currently the leaf node so we know which nodes to add objects to
    // b = branch, d = depth, o = objects, s = subnodes, p = parent
    this._b = false;
    this._d = 0;
    this._o = [];
    this._s = [];
    this._p = null;
  }

  /**
   * Removes all objects from the quadtree. You should clear the quadtree every frame before adding all objects back into it.
   * @memberof Quadtree
   * @function clear
   */
  clear() {
    this._s.map(function(subnode) {
      subnode.clear();
    });

    this._b = false;
    this._o.length = 0;
  }

  /**
   * Get an array of all objects that belong to the same node as the passed in object.
   *
   * **Note:** if the passed in object is also part of the quadtree, it will not be returned in the results.
   *
   * ```js
   * import { Sprite, Quadtree } from 'kontra';
   *
   * let quadtree = Quadtree();
   * let player = Sprite({
   *   // ...
   * });
   * let enemy1 = Sprite({
   *   // ...
   * });
   * let enemy2 = Sprite({
   *   // ...
   * });
   *
   * quadtree.add(player, enemy1, enemy2);
   * quadtree.get(player);  //=> [enemy1]
   * ```
   * @memberof Quadtree
   * @function get
   *
   * @param {{x: Number, y: Number, width: Number, height: Number}} object - Object to use for finding other objects. The object must have the properties `x`, `y`, `width`, and `height` so that its position in the quadtree can be calculated.
   *
   * @returns {Object[]} A list of objects in the same node as the object, not including the object itself.
   */
  get(object) {
    // since an object can belong to multiple nodes we should not add it multiple times
    let objects = new Set();

    // traverse the tree until we get to a leaf node
    while (this._s.length && this._b) {
      getIndices(object, this.bounds).map(index => {
        this._s[index].get(object).map(obj => objects.add(obj));
      });

      return Array.from(objects);
    }

    // don't add the object to the return list
    return this._o.filter(obj => obj !== object);
  }

  /**
   * Add objects to the quadtree and group them by their position. Can take a single object, a list of objects, and an array of objects.
   *
   * ```js
   * import { Quadtree, Sprite, Pool, GameLoop } from 'kontra';
   *
   * let quadtree = Quadtree();
   * let bulletPool = Pool({
   *   create: Sprite
   * });
   *
   * let player = Sprite({
   *   // ...
   * });
   * let enemy = Sprite({
   *   // ...
   * });
   *
   * // create some bullets
   * for (let i = 0; i < 100; i++) {
   *   bulletPool.get({
   *     // ...
   *   });
   * }
   *
   * let loop = GameLoop({
   *   update: function() {
   *     quadtree.clear();
   *     quadtree.add(player, enemy, bulletPool.getAliveObjects());
   *   }
   * });
   * ```
   * @memberof Quadtree
   * @function add
   *
   * @param {...Object[]} objects - Objects to add to the quadtree.
   */
  add(...objects) {
    objects.map(object => {
      // add a group of objects separately
      if (Array.isArray(object)) {
        this.add.apply(this, object);
        return;
      }

      // current node has subnodes, so we need to add this object into a subnode
      if (this._b) {
        this._a(object);
        return;
      }

      // this node is a leaf node so add the object to it
      this._o.push(object);

      // split the node if there are too many objects
      if (this._o.length > this.maxObjects && this._d < this.maxDepth) {
        this._sp();

        // move all objects to their corresponding subnodes
        this._o.map(obj => this._a(obj));
        this._o.length = 0;
      }
    });
  }

  /**
   * Add an object to a subnode.
   *
   * @param {Object} object - Object to add into a subnode
   */
  _a(object) {
    // add the object to all subnodes it intersects
    getIndices(object, this.bounds).map(index => {
      this._s[index].add(object);
    });
  }

  /**
   * Split the node into four subnodes.
   */
  // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#use-placeholder-arguments-instead-of-var
  _sp(subWidth, subHeight, i) {
    this._b = true;

    // only split if we haven't split before
    if (this._s.length) {
      return;
    }

    subWidth = this.bounds.width / 2 | 0;
    subHeight = this.bounds.height / 2 | 0;

    for (i = 0; i < 4; i++) {
      this._s[i] = new Quadtree({
        bounds: {
          x: this.bounds.x + (i % 2 === 1 ? subWidth : 0),  // nodes 1 and 3
          y: this.bounds.y + (i >= 2 ? subHeight : 0),      // nodes 2 and 3
          width: subWidth,
          height: subHeight
        },
        maxDepth: this.maxDepth,
        maxObjects: this.maxObjects,
      });

      // d = depth, p = parent
      this._s[i]._d = this._d+1;
      /* @ifdef VISUAL_DEBUG */
      this._s[i]._p = this;
      /* @endif */
    }
  }

  /**
   * Draw the quadtree. Useful for visual debugging.
   */
   /* @ifdef VISUAL_DEBUG **
   render() {
     // don't draw empty leaf nodes, always draw branch nodes and the first node
     if (this._o.length || this._d === 0 ||
         (this._p && this._p._b)) {

       context.strokeStyle = 'red';
       context.strokeRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);

       if (this._s.length) {
         for (let i = 0; i < 4; i++) {
           this._s[i].render();
         }
       }
     }
   }
   /* @endif */
}

function factory$8() {
  return new Quadtree(...arguments);
}
factory$8.prototype = Quadtree.prototype;
factory$8.class = Quadtree;

function getAllNodes(object) {
  let nodes = [];

  if (object._dn) {
    nodes.push(object._dn);
  }
  else if (object.children) {
    object.children.map(child => {
      nodes = nodes.concat(getAllNodes(child));
    });
  }

  return nodes;
}

/**
 * A scene object for organizing a group of objects that will update and render together.
 *
 * ```js
 * import { Scene, Sprite } from 'kontra';
 *
 * sprite = Sprite({
 *   x: 100,
 *   y: 200,
 *   width: 20,
 *   height: 40,
 *   color: 'red'
 * });
 *
 * scene = Scene({
 *   id: 'game',
 *   children: [sprite]
 * });
 *
 * scene.render();
 * ```
 *
 * @class Scene
 * @extends GameObject
 *
 * @param {Object} properties - Properties of the scene.
 * @param {String} properties.id - The id of the scene.
 * @param {String} [properties.name=properties.id] - The name of the scene. Used by screen readers to identify each scene. Use this property to give the scene a human friendly name.
 * @param {Boolean} [properties.cullObjects=true] - If the scene should not render objects outside the camera bounds.
 * @param {Function} [properties.cullFunction] - The function used to filter objects to render. Defaults to [helpers.collides](api/helpers#collides).
 * @param {Function} [properties.onShow] - Function called when the scene is shown.
 * @param {Function} [properties.onHide] - Function called when the scene is hidden.
 */
class Scene extends factory$2.class {

  init({
    /**
     * The id of the scene.
     * @memberof Scene
     * @property {String} id
     */
    id,

    /**
     * The name of the scene. Used by screen readers to identify each scene. Use this property to give the scene a human friendly name.
     * @memberof Scene
     * @property {String} name
     */
     name = id,

    /**
     * If the camera should cull objects outside the camera bounds. Not rendering objects which can't be seen greatly improves the performance.
     * @memberof Scene
     * @property {Boolean} cullObjects
     */
    cullObjects = true,

     /**
     * Camera culling function which prevents objects outside the camera screen from rendering. Is passed as the `filterFunction` to the [render](api/gameObject#render) function.
     * @memberof Scene
     * @property {Function} cullFunction
     */
    cullFunction = collides,

    ...props
  }) {
    // create an accessible DOM node for screen readers (do this first
    // so we can move DOM nodes in addChild)
    // dn = dom node
    const section = this._dn = document.createElement('section');
    section.tabIndex = -1;
    section.style = srOnlyStyle;
    section.id = id;
    section.setAttribute('aria-label', name);

    super.init({
      id,
      name,
      cullObjects,
      cullFunction,
      ...props
    });

    addToDom(section, this.context.canvas);

    let canvas = this.context.canvas;

    /**
     * The camera object which is used as the focal point for the scene. The scene will not render objects that are outside the bounds of the camera.
     *
     * Additionally, the camera can be used to [lookAt](api/scene#lookAt) an object which will center the camera to that object. This allows you to zoom the scene in and out while the camera remains centered on the object.
     * @memberof Scene
     * @property {GameObject} camera
     */
    this.camera = factory$2({
      x: canvas.width / 2,
      y: canvas.height / 2,
      width: canvas.width,
      height: canvas.height,
      anchor: { x: 0.5, y: 0.5 }
    });

    // can call super here only by using lexical scope
    this.camera._pc = () => {
      super._pc.call(this.camera);

      // only set the cameras position based on scale
      // but not the width/height
      let canvas = this.context.canvas;
      this.camera._wx = this.camera.x * this.scaleX;
      this.camera._wy = this.camera.y * this.scaleY;
    };
  }

  /**
   * Show the scene and resume update and render. Calls [onShow](api/scene#onShow) if passed.
   * @memberof Scene
   * @function show
   */
  show() {

    /**
     * If the scene is hidden.
     * @memberof Scene
     * @property {Boolean} hidden
     */
    this.hidden = this._dn.hidden = false;

    // find first focusable child
    let focusableChild = this.children.find(child => child.focus);
    if (focusableChild) {
      focusableChild.focus();
    }
    else {
      this._dn.focus();
    }

    this.onShow();
  }

  /**
   * Hide the scene. A hidden scene will not update or render. Calls [onHide](api/scene#onHide) if passed.
   * @memberof Scene
   * @function hide
   */
  hide() {
    this.hidden = this._dn.hidden = true;
    this.onHide();
  }

  addChild(object, options) {
    super.addChild(object, options);

    // move all children to be in the scenes DOM node so we can
    // hide and show the DOM node and thus hide and show all the
    // children
    getAllNodes(object).map(node => {
      this._dn.appendChild(node);
    });
  }

  removeChild(object) {
    super.removeChild(object);

    getAllNodes(object).map(node => {
      addToDom(node, this.context.canvas);
    });
  }

  /**
   * Clean up the scene and call `destroy()` on all children.
   * @memberof Scene
   * @function destroy
   */
  destroy() {
    this._dn.remove();
    this.children.map(child => child.destroy && child.destroy());
  }

  update(dt) {
    if (!this.hidden) {
      super.update(dt);
    }
  }

  /**
   * Focus the camera to the object or x/y position. As the scene is scaled the focal point will keep to the position.
   * @memberof Scene
   * @function lookAt
   *
   * @param {{x: number, y: number}} object - Object with x/y properties.
   */
  lookAt(object) {

    // don't call getWorldRect so we can ignore the objects anchor
    object = object.world || object;
    let x = object.x;
    let y = object.y;

    if (object.scaleX) {
      x /= object.scaleX;
      y /= object.scaleY;
    }

    this.camera.x = x;
    this.camera.y = y;
    this._pc();
  }

  _pc() {
    super._pc();

    // this can be called before the camera is initialized so we
    // need to guard it
    this.camera && this.camera._pc();
  }

  render() {
    let { x, y, width, height } = this.camera;

    this.sx = x * this.scaleX - width / 2;
    this.sy = y * this.scaleY - height / 2;

    if (!this.hidden) {
      super.render(child => this.cullObjects ? this.cullFunction(child, this.camera) : true);
    }
  }

  /**
   * Function called when the scene is shown. Override this function to have the scene do something when shown.
   * @memberof Scene
   * @function onShow
   */
  onShow() {}

  /**
   * Function called when the scene is hidden. Override this function to have the scene do something when hidden.
   * @memberof Scene
   * @function onHide
   */
  onHide() {}
}

function factory$9() {
  return new Scene(...arguments);
}
factory$9.prototype = Scene.prototype;
factory$9.class = Scene;

/**
 * Parse a string of consecutive frames.
 *
 * @param {Number|String} frames - Start and end frame.
 *
 * @returns {Number|Number[]} List of frames.
 */
function parseFrames(consecutiveFrames) {
  // return a single number frame
  // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types
  if (+consecutiveFrames === consecutiveFrames) {
    return consecutiveFrames;
  }

  let sequence = [];
  let frames = consecutiveFrames.split('..');

  // coerce string to number
  // @see https://github.com/jed/140bytes/wiki/Byte-saving-techniques#coercion-to-test-for-types
  let start = +frames[0];
  let end = +frames[1];
  let i = start;

  // ascending frame order
  if (start < end) {
    for (; i <= end; i++) {
      sequence.push(i);
    }
  }
  // descending order
  else {
    for (; i >= end; i--) {
      sequence.push(i);
    }
  }

  return sequence;
}

/**
 * A sprite sheet to animate a sequence of images. Used to create [animation sprites](api/sprite#animation-sprite).
 *
 * <figure>
 *   <a href="assets/imgs/character_walk_sheet.png">
 *     <img src="assets/imgs/character_walk_sheet.png" width="266" height="512" alt="11 frames of a walking pill-like alien wearing a space helmet.">
 *   </a>
 *   <figcaption>Sprite sheet image courtesy of <a href="https://kenney.nl/assets">Kenney</a>.</figcaption>
 * </figure>
 *
 * Typically you create a sprite sheet just to create animations and then use the animations for your sprite.
 *
 * ```js
 * import { Sprite, SpriteSheet } from 'kontra';
 *
 * let image = new Image();
 * image.src = 'assets/imgs/character_walk_sheet.png';
 * image.onload = function() {
 *   let spriteSheet = SpriteSheet({
 *     image: image,
 *     frameWidth: 72,
 *     frameHeight: 97,
 *     animations: {
 *       // create a named animation: walk
 *       walk: {
 *         frames: '0..9',  // frames 0 through 9
 *         frameRate: 30
 *       }
 *     }
 *   });
 *
 *   let sprite = Sprite({
 *     x: 200,
 *     y: 100,
 *
 *     // use the sprite sheet animations for the sprite
 *     animations: spriteSheet.animations
 *   });
 * };
 * ```
 * @class SpriteSheet
 *
 * @param {Object} properties - Properties of the sprite sheet.
 * @param {HTMLImageElement|HTMLCanvasElement} properties.image - The sprite sheet image.
 * @param {Number} properties.frameWidth - The width of a single frame.
 * @param {Number} properties.frameHeight - The height of a single frame.
 * @param {Number} [properties.frameMargin=0] - The amount of whitespace between each frame.
 * @param {Object} [properties.animations] - Animations to create from the sprite sheet using [Animation](api/animation). Passed directly into the sprite sheets [createAnimations()](api/spriteSheet#createAnimations) function.
 */
class SpriteSheet {
  constructor({image, frameWidth, frameHeight, frameMargin, animations} = {}) {
    // @ifdef DEBUG
    if (!image) {
      throw Error('You must provide an Image for the SpriteSheet');
    }
    // @endif

    /**
     * An object of named [Animation](api/animation) objects. Typically you pass this object into [Sprite](api/sprite) to create an [animation sprites](api/spriteSheet#animation-sprite).
     * @memberof SpriteSheet
     * @property {{[name: string] : Animation}} animations
     */
    this.animations = {};

    /**
     * The sprite sheet image.
     * @memberof SpriteSheet
     * @property {HTMLImageElement|HTMLCanvasElement} image
     */
    this.image = image;

    /**
     * An object that defines properties of a single frame in the sprite sheet. It has properties of `width`, `height`, and `margin`.
     *
     * `width` and `height` are the width of a single frame, while `margin` defines the amount of whitespace between each frame.
     * @memberof SpriteSheet
     * @property {{width: number, height: number, margin: number}} frame
     */
    this.frame = {
      width: frameWidth,
      height: frameHeight,
      margin: frameMargin
    };

    // f = framesPerRow
    this._f = image.width / frameWidth | 0;

    this.createAnimations(animations);
  }

  /**
   * Create named animations from the sprite sheet. Called from the constructor if the `animations` argument is passed.
   *
   * This function populates the sprite sheets `animations` property with [Animation](api/animation) objects. Each animation is accessible by its name.
   *
   * ```js
   * import { Sprite, SpriteSheet } from 'kontra';
   *
   * let image = new Image();
   * image.src = 'assets/imgs/character_walk_sheet.png';
   * image.onload = function() {
   *
   *   let spriteSheet = SpriteSheet({
   *     image: image,
   *     frameWidth: 72,
   *     frameHeight: 97,
   *
   *     // this will also call createAnimations()
   *     animations: {
   *       // create 1 animation: idle
   *       idle: {
   *         // a single frame
   *         frames: 1
   *       }
   *     }
   *   });
   *
   *   spriteSheet.createAnimations({
   *     // create 4 animations: jump, walk, moonWalk, attack
   *     jump: {
   *       // sequence of frames (can be non-consecutive)
   *       frames: [1, 10, 1],
   *       frameRate: 10,
   *       loop: false,
   *     },
   *     walk: {
   *       // ascending consecutive frame animation (frames 2-6, inclusive)
   *       frames: '2..6',
   *       frameRate: 20
   *     },
   *     moonWalk: {
   *       // descending consecutive frame animation (frames 6-2, inclusive)
   *       frames: '6..2',
   *       frameRate: 20
   *     },
   *     attack: {
   *       // you can also mix and match, in this case frames [8,9,10,13,10,9,8]
   *       frames: ['8..10', 13, '10..8'],
   *       frameRate: 10,
   *       loop: false,
   *     }
   *   });
   * };
   * ```
   * @memberof SpriteSheet
   * @function createAnimations
   *
   * @param {Object} animations - Object of named animations to create from the sprite sheet.
   * @param {Number|String|Number[]|String[]} animations.<name>.frames - The sequence of frames to use from the sprite sheet. It can either be a single frame (`1`), a sequence of frames (`[1,2,3,4]`), or a consecutive frame notation (`'1..4'`). Sprite sheet frames are `0` indexed.
   * @param {Number} animations.<name>.frameRate - The number frames to display per second.
   * @param {Boolean} [animations.<name>.loop=true] - If the animation should loop back to the beginning once completed.
   */
  createAnimations(animations) {
    let sequence, name;

    for (name in animations) {
      let { frames, frameRate, loop } = animations[name];

      // array that holds the order of the animation
      sequence = [];

      // @ifdef DEBUG
      if (frames === undefined) {
        throw Error('Animation ' + name + ' must provide a frames property');
      }
      // @endif

      // add new frames to the end of the array
      [].concat(frames).map(frame => {
        sequence = sequence.concat(parseFrames(frame));
      });

      this.animations[name] = factory({
        spriteSheet: this,
        frames: sequence,
        frameRate,
        loop
      });
    }
  }
}

function factory$a() {
  return new SpriteSheet(...arguments);
}
factory$a.prototype = SpriteSheet.prototype;
factory$a.class = SpriteSheet;

/**
 * A tile engine for managing and drawing tilesets.
 *
 * <figure>
 *   <a href="assets/imgs/mapPack_tilesheet.png">
 *     <img src="assets/imgs/mapPack_tilesheet.png" width="1088" height="768" alt="Tileset to create an overworld map in various seasons.">
 *   </a>
 *   <figcaption>Tileset image courtesy of <a href="https://kenney.nl/assets">Kenney</a>.</figcaption>
 * </figure>
 * @class TileEngine
 *
 * @param {Object} properties - Properties of the tile engine.
 * @param {Number} properties.width - Width of the tile map (in number of tiles).
 * @param {Number} properties.height - Height of the tile map (in number of tiles).
 * @param {Number} properties.tilewidth - Width of a single tile (in pixels).
 * @param {Number} properties.tileheight - Height of a single tile (in pixels).
 * @param {CanvasRenderingContext2D} [properties.context] - The context the tile engine should draw to. Defaults to [core.getContext()](api/core#getContext)
 *
 * @param {Object[]} properties.tilesets - Array of tileset objects.
 * @param {Number} properties.tilesetN.firstgid - First tile index of the tileset. The first tileset will have a firstgid of 1 as 0 represents an empty tile.
 * @param {String|HTMLImageElement} properties.tilesetN.image - Relative path to the HTMLImageElement or an HTMLImageElement. If passing a relative path, the image file must have been [loaded](api/assets#load) first.
 * @param {Number} [properties.tilesetN.margin=0] - The amount of whitespace between each tile (in pixels).
 * @param {Number} [properties.tilesetN.tilewidth] - Width of the tileset (in pixels). Defaults to properties.tilewidth.
 * @param {Number} [properties.tilesetN.tileheight] - Height of the tileset (in pixels). Defaults to properties.tileheight.
 * @param {String} [properties.tilesetN.source] - Relative path to the source JSON file. The source JSON file must have been [loaded](api/assets#load) first.
 * @param {Number} [properties.tilesetN.columns] - Number of columns in the tileset image.
 *
 * @param {Object[]} properties.layers - Array of layer objects.
 * @param {String} properties.layerN.name - Unique name of the layer.
 * @param {Number[]} properties.layerN.data - 1D array of tile indices.
 * @param {Boolean} [properties.layerN.visible=true] - If the layer should be drawn or not.
 * @param {Number} [properties.layerN.opacity=1] - Percent opacity of the layer.
 */

/**
 * @docs docs/api_docs/tileEngine.js
 */

function TileEngine(properties) {
  let {
    width,
    height,
    tilewidth,
    tileheight,
    context = getContext(),
    tilesets,
    layers
  } = properties;

  let mapwidth = width * tilewidth;
  let mapheight = height * tileheight;

  // create an off-screen canvas for pre-rendering the map
  // @see http://jsperf.com/render-vs-prerender
  let offscreenCanvas = document.createElement('canvas');
  let offscreenContext = offscreenCanvas.getContext('2d');
  offscreenCanvas.width = mapwidth;
  offscreenCanvas.height = mapheight;

  // map layer names to data
  let layerMap = {};
  let layerCanvases = {};

  // objects added to tile engine to sync with the camera
  let objects = [];

  /**
   * The width of tile map (in tiles).
   * @memberof TileEngine
   * @property {Number} width
   */

  /**
   * The height of tile map (in tiles).
   * @memberof TileEngine
   * @property {Number} height
   */

  /**
   * The width a tile (in pixels).
   * @memberof TileEngine
   * @property {Number} tilewidth
   */

  /**
   * The height of a tile (in pixels).
   * @memberof TileEngine
   * @property {Number} tileheight
   */

  /**
   * Array of all layers of the tile engine.
   * @memberof TileEngine
   * @property {Object[]} layers
   */

  /**
   * Array of all tilesets of the tile engine.
   * @memberof TileEngine
   * @property {Object[]} tilesets
   */

  let tileEngine = Object.assign({

    /**
     * The context the tile engine will draw to.
     * @memberof TileEngine
     * @property {CanvasRenderingContext2D} context
     */
    context: context,

    /**
     * The width of the tile map (in pixels).
     * @memberof TileEngine
     * @property {Number} mapwidth
     */
    mapwidth: mapwidth,

    /**
     * The height of the tile map (in pixels).
     * @memberof TileEngine
     * @property {Number} mapheight
     */
    mapheight: mapheight,
    _sx: 0,
    _sy: 0,

    // d = dirty
    _d: false,

    /**
     * X coordinate of the tile map camera.
     * @memberof TileEngine
     * @property {Number} sx
     */
    get sx() {
      return this._sx;
    },

    /**
     * Y coordinate of the tile map camera.
     * @memberof TileEngine
     * @property {Number} sy
     */
    get sy() {
      return this._sy;
    },

    // when clipping an image, sx and sy must within the image region, otherwise
    // Firefox and Safari won't draw it.
    // @see http://stackoverflow.com/questions/19338032/canvas-indexsizeerror-index-or-size-is-negative-or-greater-than-the-allowed-a
    set sx(value) {
      this._sx = clamp(0, mapwidth - getCanvas().width, value);
      objects.forEach(obj => obj.sx = this._sx);
    },

    set sy(value) {
      this._sy = clamp(0, mapheight - getCanvas().height, value);
      objects.forEach(obj => obj.sy = this._sy);
    },

    /**
     * Render all visible layers.
     * @memberof TileEngine
     * @function render
     */
    render() {
      if (this._d) {
        this._d = false;
        this._p();
      }

      render(offscreenCanvas);
    },

    /**
     * Render a specific layer by name.
     * @memberof TileEngine
     * @function renderLayer
     *
     * @param {String} name - Name of the layer to render.
     */
    renderLayer(name) {
      let canvas = layerCanvases[name];
      let layer = layerMap[name];

      if (!canvas) {
        // cache the rendered layer so we can render it again without redrawing
        // all tiles
        canvas = document.createElement('canvas');
        canvas.width = mapwidth;
        canvas.height = mapheight;

        layerCanvases[name] = canvas;
        tileEngine._r(layer, canvas.getContext('2d'));
      }

      if (layer._d) {
        layer._d = false;
        canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
        tileEngine._r(layer, canvas.getContext('2d'));
      }

      render(canvas);
    },

    /**
     * Check if the object collides with the layer (shares a gird coordinate with any positive tile index in layers data). The object being checked must have the properties `x`, `y`, `width`, and `height` so that its position in the grid can be calculated. [Sprite](api/sprite) defines these properties for you.
     *
     * ```js
     * import { TileEngine, Sprite } from 'kontra';
     *
     * let tileEngine = TileEngine({
     *   tilewidth: 32,
     *   tileheight: 32,
     *   width: 4,
     *   height: 4,
     *   tilesets: [{
     *     // ...
     *   }],
     *   layers: [{
     *     name: 'collision',
     *     data: [ 0,0,0,0,
     *             0,1,4,0,
     *             0,2,5,0,
     *             0,0,0,0 ]
     *   }]
     * });
     *
     * let sprite = Sprite({
     *   x: 50,
     *   y: 20,
     *   width: 5,
     *   height: 5
     * });
     *
     * tileEngine.layerCollidesWith('collision', sprite);  //=> false
     *
     * sprite.y = 28;
     *
     * tileEngine.layerCollidesWith('collision', sprite);  //=> true
     * ```
     * @memberof TileEngine
     * @function layerCollidesWith
     *
     * @param {String} name - The name of the layer to check for collision.
     * @param {Object} object - Object to check collision against.
     *
     * @returns {boolean} `true` if the object collides with a tile, `false` otherwise.
     */
    layerCollidesWith(name, object) {
      let { x, y, width, height } = getWorldRect(object);

      let row = getRow(y);
      let col = getCol(x);
      let endRow = getRow(y + height);
      let endCol = getCol(x + width);

      let layer = layerMap[name];

      // check all tiles
      for (let r = row; r <= endRow; r++) {
        for (let c = col; c <= endCol; c++) {
          if (layer.data[c + r * this.width]) {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * Get the tile at the specified layer using either x and y coordinates or row and column coordinates.
     *
     * ```js
     * import { TileEngine } from 'kontra';
     *
     * let tileEngine = TileEngine({
     *   tilewidth: 32,
     *   tileheight: 32,
     *   width: 4,
     *   height: 4,
     *   tilesets: [{
     *     // ...
     *   }],
     *   layers: [{
     *     name: 'collision',
     *     data: [ 0,0,0,0,
     *             0,1,4,0,
     *             0,2,5,0,
     *             0,0,0,0 ]
     *   }]
     * });
     *
     * tileEngine.tileAtLayer('collision', {x: 50, y: 50});  //=> 1
     * tileEngine.tileAtLayer('collision', {row: 2, col: 1});  //=> 2
     * ```
     * @memberof TileEngine
     * @function tileAtLayer
     *
     * @param {String} name - Name of the layer.
     * @param {{x: Number, y: Number}|{row: Number, col: Number}} position - Position of the tile in either {x, y} or {row, col} coordinates.
     *
     * @returns {Number} The tile index. Will return `-1` if no layer exists by the provided name.
     */
    tileAtLayer(name, position) {
      let row = position.row || getRow(position.y);
      let col = position.col || getCol(position.x);

      if (layerMap[name]) {
        return layerMap[name].data[col + row * tileEngine.width];
      }

      return -1;
    },

    /**
     * Set the tile at the specified layer using either x and y coordinates or row and column coordinates.
     *
     * ```js
     * import { TileEngine } from 'kontra';
     *
     * let tileEngine = TileEngine({
     *   tilewidth: 32,
     *   tileheight: 32,
     *   width: 4,
     *   height: 4,
     *   tilesets: [{
     *     // ...
     *   }],
     *   layers: [{
     *     name: 'collision',
     *     data: [ 0,0,0,0,
     *             0,1,4,0,
     *             0,2,5,0,
     *             0,0,0,0 ]
     *   }]
     * });
     *
     * tileEngine.setTileAtLayer('collision', {row: 2, col: 1}, 10);
     * tileEngine.tileAtLayer('collision', {row: 2, col: 1});  //=> 10
     * ```
     * @memberof TileEngine
     * @function setTileAtLayer
     *
     * @param {String} name - Name of the layer.
     * @param {{x: Number, y: Number}|{row: Number, col: Number}} position - Position of the tile in either {x, y} or {row, col} coordinates.
     * @param {Number} tile - Tile index to set.
     */
    setTileAtLayer(name, position, tile) {
      let row = position.row || getRow(position.y);
      let col = position.col || getCol(position.x);

      if (layerMap[name]) {
        this._d = true;
        layerMap[name]._d = true;
        layerMap[name].data[col + row * tileEngine.width] = tile;
      }
    },

    /**
    *Setthedataatthespecifiedlayer.
    *
    *```js
    *import{TileEngine}from'kontra';
    *
    *lettileEngine=TileEngine({
    *tilewidth:32,
    *tileheight:32,
    *width:2,
    *height:2,
    *tilesets:[{
    *//...
    *}],
    *layers:[{
    *name:'collision',
    *data:[0,1,
    *2,3]
    *}]
    *});
    *
    *tileEngine.setLayer('collision',[4,5,6,7]);
    *tileEngine.tileAtLayer('collision',{row:0,col:0});//=>4
    *tileEngine.tileAtLayer('collision',{row:0,col:1});//=>5
    *tileEngine.tileAtLayer('collision',{row:1,col:0});//=>6
    *tileEngine.tileAtLayer('collision',{row:1,col:1});//=>7
    *```
    *
    *@memberofTileEngine
    *@functionsetLayer
    *
    * @param {String} name - Name of the layer.
    *@param {Number[]}data-1Darrayoftileindices.
    */
    setLayer(name, data) {
      if (layerMap[name]) {
        this._d = true;
        layerMap[name]._d = true;
        layerMap[name].data = data;
      }
    },

    /**
     * Add an object to the tile engine. The tile engine will set the objects camera position (`sx`, `sy`) to be in sync with the tile engine camera. [Sprite](api/sprite) uses this information to draw the sprite to the correct position on the canvas.
     * @memberof TileEngine
     * @function addObject
     *
     * @param {Object} object - Object to add to the tile engine.
     */
    addObject(object) {
      objects.push(object);
      object.sx = this._sx;
      object.sy = this._sy;
    },

    /**
     * Remove an object from the tile engine.
     * @memberof TileEngine
     * @function removeObject
     *
     * @param {Object} object - Object to remove from the tile engine.
     */
    removeObject(object) {
      let index = objects.indexOf(object);
      if (index !== -1) {
        objects.splice(index, 1);
        object.sx = object.sy = 0;
      }
    },

    // expose for testing
    _r: renderLayer,
    _p: prerender,

    // @ifdef DEBUG
    layerCanvases: layerCanvases,
    layerMap: layerMap
    // @endif
  }, properties);

  // resolve linked files (source, image)
  tileEngine.tilesets.map(tileset => {
    // get the url of the Tiled JSON object (in this case, the properties object)
    let url = (window.__k ? window.__k.dm.get(properties) : '') || window.location.href;

    if (tileset.source) {
      // @ifdef DEBUG
      if (!window.__k) {
        throw Error(`You must use "load" or "loadData" to resolve tileset.source`);
      }
      // @endif

      let source = window.__k.d[window.__k.u(tileset.source, url)];

      // @ifdef DEBUG
      if (!source) {
        throw Error(`You must load the tileset source "${tileset.source}" before loading the tileset`);
      }
      // @endif

      Object.keys(source).map(key => {
        tileset[key] = source[key];
      });
    }

    if (''+tileset.image === tileset.image) {
      // @ifdef DEBUG
      if (!window.__k) {
        throw Error(`You must use "load" or "loadImage" to resolve tileset.image`);
      }
      // @endif

      let image = window.__k.i[window.__k.u(tileset.image, url)];

      // @ifdef DEBUG
      if (!image) {
        throw Error(`You must load the image "${tileset.image}" before loading the tileset`);
      }
      // @endif

      tileset.image = image;
    }
  });

  /**
   * Get the row from the y coordinate.
   * @private
   *
   * @param {Number} y - Y coordinate.
   *
   * @return {Number}
   */
  function getRow(y) {
    return y / tileEngine.tileheight | 0;
  }

  /**
   * Get the col from the x coordinate.
   * @private
   *
   * @param {Number} x - X coordinate.
   *
   * @return {Number}
   */
  function getCol(x) {
    return x / tileEngine.tilewidth | 0;
  }

  /**
   * Render a layer.
   * @private
   *
   * @param {Object} layer - Layer data.
   * @param {Context} context - Context to draw layer to.
   */
  function renderLayer(layer, context) {
    context.save();
    context.globalAlpha = layer.opacity;

    (layer.data || []).map((tile, index) => {

      // skip empty tiles (0)
      if (!tile) return;

      // find the tileset the tile belongs to
      // assume tilesets are ordered by firstgid
      let tileset;
      for (let i = tileEngine.tilesets.length-1; i >= 0; i--) {
        tileset = tileEngine.tilesets[i];

        if (tile / tileset.firstgid >= 1) {
          break;
        }
      }

      let tilewidth = tileset.tilewidth || tileEngine.tilewidth;
      let tileheight = tileset.tileheight || tileEngine.tileheight;
      let margin = tileset.margin || 0;

      let image = tileset.image;

      let offset = tile - tileset.firstgid;
      let cols = tileset.columns ||
        image.width / (tilewidth + margin) | 0;

      let x = (index % tileEngine.width) * tilewidth;
      let y = (index / tileEngine.width | 0) * tileheight;
      let sx = (offset % cols) * (tilewidth + margin);
      let sy = (offset / cols | 0) * (tileheight + margin);

      context.drawImage(
        image,
        sx, sy, tilewidth, tileheight,
        x, y, tilewidth, tileheight
      );
    });

    context.restore();
  }

  /**
   * Pre-render the tiles to make drawing fast.
   * @private
   */
  function prerender() {
    if (tileEngine.layers) {
      tileEngine.layers.map(layer => {
        layer._d = false;
        layerMap[layer.name] = layer;

        if (layer.data && layer.visible !== false) {
          tileEngine._r(layer, offscreenContext);
        }
      });
    }
  }

  /**
   * Render a tile engine canvas.
   * @private
   *
   * @param {HTMLCanvasElement} canvas - Tile engine canvas to draw.
   */
  function render(canvas) {
    const { width, height } = getCanvas();
    const sWidth = Math.min(canvas.width, width);
    const sHeight = Math.min(canvas.height, height);

    tileEngine.context.drawImage(
      canvas,
      tileEngine.sx, tileEngine.sy, sWidth, sHeight,
      0, 0, sWidth, sHeight
    );
  }

  prerender();
  return tileEngine;
}

let kontra = {
  Animation: factory,

  imageAssets,
  audioAssets,
  dataAssets,
  setImagePath,
  setAudioPath,
  setDataPath,
  loadImage,
  loadAudio,
  loadData,
  load,

  Button: factory$5,

  init,
  getCanvas,
  getContext,

  on,
  off,
  emit,

  GameLoop,
  GameObject: factory$2,
  Grid: factory$6,

  degToRad,
  radToDeg,
  angleToTarget,
  rotatePoint,
  randInt,
  seedRand,
  lerp,
  inverseLerp,
  clamp,
  setStoreItem,
  getStoreItem,
  collides,
  getWorldRect,

  keyMap,
  initKeys,
  bindKeys,
  unbindKeys,
  keyPressed,

  registerPlugin,
  unregisterPlugin,
  extendObject,

  initPointer,
  getPointer,
  track,
  untrack,
  pointerOver,
  onPointerDown,
  onPointerUp,
  pointerPressed,

  Pool: factory$7,
  Quadtree: factory$8,
  Scene: factory$9,
  Sprite: factory$3,
  SpriteSheet: factory$a,

  Text: factory$4,
  TileEngine,
  Vector: factory$1
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (kontra);



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var kontra__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! kontra */ "../node_modules/kontra/kontra.mjs");
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./Entity.js");
/* harmony import */ var colyseus_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! colyseus.js */ "../../node_modules/colyseus.js/dist/colyseus.js");
/* harmony import */ var colyseus_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(colyseus_js__WEBPACK_IMPORTED_MODULE_1__);




let room;
//create the canvas
let { canvas } = (0,kontra__WEBPACK_IMPORTED_MODULE_2__.init)();

const client = new colyseus_js__WEBPACK_IMPORTED_MODULE_1__.Client('ws://localhost:2567');


//So... we wrap everything with the game loop in this, I guess?
client.joinOrCreate("my_room").then(room_instance => {
  room = room_instance

  let entities = {}

  //Add entities to the deal
  room.state.entities.onAdd = function (ent, key) {
    const colors = ['blue', 'green', 'red', 'orange', 'black'];
    new _Entity__WEBPACK_IMPORTED_MODULE_0__.default({
      x: ent.x,
      y: ent.y,
      name: ent.name,
      color: colors[Math.floor(Math.random() * colors.length)],
      height: 20,
      width: 20
    })

    //Track changes to state
    ent.onChange = (changes) => {
      let chosenEnt = _Entity__WEBPACK_IMPORTED_MODULE_0__.default.entities.find(en => en.name === ent.name);
      changes.forEach(change => {
        chosenEnt[change.field] = change.value;
      })
    }
  }

  //Remove entities from the deal
  room.state.entities.onRemove = function (ent, key) {
    _Entity__WEBPACK_IMPORTED_MODULE_0__.default.entities = _Entity__WEBPACK_IMPORTED_MODULE_0__.default.entities.filter(x => x.name != ent.name)
  }

});

(0,kontra__WEBPACK_IMPORTED_MODULE_2__.initKeys)();

const handleInput = () => {
  let dirX = (0,kontra__WEBPACK_IMPORTED_MODULE_2__.keyPressed)("d") - (0,kontra__WEBPACK_IMPORTED_MODULE_2__.keyPressed)("a");
  let dirY = (0,kontra__WEBPACK_IMPORTED_MODULE_2__.keyPressed)("s") - (0,kontra__WEBPACK_IMPORTED_MODULE_2__.keyPressed)("w");

  if((dirX || dirY) && room) {
    room.send("move", {
      x: dirX,
      y: dirY
    });
  }
}

let loop = (0,kontra__WEBPACK_IMPORTED_MODULE_2__.GameLoop)({  // create the main game loop
  update: function () { // update the game state
    handleInput();
    _Entity__WEBPACK_IMPORTED_MODULE_0__.default.entities.forEach(ent => ent.update());
  },
  render: function () { // render the game state
    _Entity__WEBPACK_IMPORTED_MODULE_0__.default.entities.forEach(ent => ent.render());
  }
});

loop.start();    // start the game

})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*******************!*\
  !*** ./main.scss ***!
  \*******************/
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscURBQXFEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtEQUFrRDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscURBQXFEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw2Q0FBNkM7QUFDeEYsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUMsc0NBQXNDO0FBQ3RDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLG1CQUFtQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsd0NBQXdDO0FBQ3hDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUTtBQUNqRTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvREFBb0Q7QUFDdkc7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLFVBQVUsV0FBVyxnQkFBZ0I7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUgsS0FBSztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxNQUFNLGVBQWUscUJBQXFCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUhBQXlIO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG9DQUFvQztBQUMvQyxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0NBQW9DO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsY0FBYyxtRkFBbUY7QUFDakc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFFBQVEsc0JBQXNCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsY0FBYyxtRkFBbUY7QUFDakc7QUFDQSxzQkFBc0Isa0NBQWtDLElBQUk7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFtRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUF1RDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBdUQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RCw0Q0FBNEMsa0JBQWtCO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxxQ0FBcUMsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQSxtQkFBbUIscUNBQXFDLElBQUk7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyw4QkFBOEI7QUFDekMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU8sK0dBQStHO0FBQ2pJLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsd0JBQXdCLElBQUk7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQXFEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxzREFBc0Q7QUFDbEU7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUSxzQkFBc0I7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxzREFBc0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHVDQUF1QyxJQUFJOztBQUUxRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFzRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1DQUFtQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxzQkFBc0I7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFD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Q3ZCLHdCQUF3QjtBQUN4QjtBQUNBLElBQUksNkRBQXVCO0FBQzNCLEdBQUc7QUFDSCx3QkFBd0I7QUFDeEIsSUFBSSw2REFBdUI7QUFDM0I7QUFDQSxDQUFDOztBQUVELGlCQUFpQjs7Ozs7Ozs7Ozs7QUNyRWpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vRW50aXR5LmpzIiwid2VicGFjazovLy8uLi8uLi9ub2RlX21vZHVsZXMvY29seXNldXMuanMvZGlzdC9jb2x5c2V1cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2tvbnRyYS9rb250cmEubWpzIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vLi9tYWluLmpzIiwid2VicGFjazovLy8uL21haW4uc2NzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTcHJpdGUgfSBmcm9tIFwia29udHJhXCI7XG5cbmNsYXNzIEVudGl0eSB7XG4gIHN0YXRpYyBlbnRpdGllcyA9IFtdO1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIEVudGl0eS5lbnRpdGllcy5wdXNoKFNwcml0ZShwcm9wcykpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRW50aXR5OyIsIi8vIGNvbHlzZXVzLmpzQDAuMTQuMTMgKEBjb2x5c2V1cy9zY2hlbWEgMS4wLjI1KVxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ2NvbHlzZXVzLmpzJywgWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5Db2x5c2V1cyA9IHt9KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvL1xuICAgIC8vIFBvbHlmaWxscyBmb3IgbGVnYWN5IGVudmlyb25tZW50c1xuICAgIC8vXG4gICAgLypcbiAgICAgKiBTdXBwb3J0IEFuZHJvaWQgNC40LnhcbiAgICAgKi9cbiAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldykge1xuICAgICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEgIT09IG51bGwgJiYgdHlwZW9mIChhKSA9PT0gJ29iamVjdCcgJiYgYS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gRGVmaW5lIGdsb2JhbFRoaXMgaWYgbm90IGF2YWlsYWJsZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29seXNldXMvY29seXNldXMuanMvaXNzdWVzLzg2XG4gICAgaWYgKHR5cGVvZiAoZ2xvYmFsVGhpcykgPT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mICh3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgd2luZG93WydnbG9iYWxUaGlzJ10gPSB3aW5kb3c7XG4gICAgfVxuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcbiAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcbiAgICBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG4gICAgTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4gICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHkoc3JjLCB0YXIpIHtcbiAgICBcdHRhci5oZWFkZXJzID0gc3JjLmhlYWRlcnMgfHwge307XG4gICAgXHR0YXIuc3RhdHVzTWVzc2FnZSA9IHNyYy5zdGF0dXNUZXh0O1xuICAgIFx0dGFyLnN0YXR1c0NvZGUgPSBzcmMuc3RhdHVzO1xuICAgIFx0dGFyLmRhdGEgPSBzcmMucmVzcG9uc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VuZChtZXRob2QsIHVyaSwgb3B0cykge1xuICAgIFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgIFx0XHRvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBcdFx0dmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdDtcbiAgICBcdFx0dmFyIGssIHRtcCwgYXJyLCBzdHI9b3B0cy5ib2R5O1xuICAgIFx0XHR2YXIgaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcblxuICAgIFx0XHQvLyBJRSBjb21wYXRpYmxlXG4gICAgXHRcdGlmIChvcHRzLnRpbWVvdXQpIHJlcS50aW1lb3V0ID0gb3B0cy50aW1lb3V0O1xuICAgIFx0XHRyZXEub250aW1lb3V0ID0gcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgXHRcdFx0ZXJyLnRpbWVvdXQgPSBlcnIudHlwZSA9PSAndGltZW91dCc7XG4gICAgXHRcdFx0cmVqKGVycik7XG4gICAgXHRcdH07XG5cbiAgICBcdFx0cmVxLm9wZW4obWV0aG9kLCB1cmkuaHJlZiB8fCB1cmkpO1xuXG4gICAgXHRcdHJlcS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0YXJyID0gcmVxLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rLyk7XG4gICAgXHRcdFx0YXBwbHkocmVxLCByZXEpOyAvLz0+IHJlcS5oZWFkZXJzXG5cbiAgICBcdFx0XHR3aGlsZSAodG1wID0gYXJyLnNoaWZ0KCkpIHtcbiAgICBcdFx0XHRcdHRtcCA9IHRtcC5zcGxpdCgnOiAnKTtcbiAgICBcdFx0XHRcdHJlcS5oZWFkZXJzW3RtcC5zaGlmdCgpLnRvTG93ZXJDYXNlKCldID0gdG1wLmpvaW4oJzogJyk7XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dG1wID0gcmVxLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgIFx0XHRcdGlmICh0bXAgJiYgISF+dG1wLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgIFx0XHRcdFx0dHJ5IHtcbiAgICBcdFx0XHRcdFx0cmVxLmRhdGEgPSBKU09OLnBhcnNlKHJlcS5kYXRhLCBvcHRzLnJldml2ZXIpO1xuICAgIFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG4gICAgXHRcdFx0XHRcdGFwcGx5KHJlcSwgZXJyKTtcbiAgICBcdFx0XHRcdFx0cmV0dXJuIHJlaihlcnIpO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdChyZXEuc3RhdHVzID49IDQwMCA/IHJlaiA6IHJlcykocmVxKTtcbiAgICBcdFx0fTtcblxuICAgIFx0XHRpZiAodHlwZW9mIEZvcm1EYXRhIDwgJ3UnICYmIHN0ciBpbnN0YW5jZW9mIEZvcm1EYXRhKSA7IGVsc2UgaWYgKHN0ciAmJiB0eXBlb2Ygc3RyID09ICdvYmplY3QnKSB7XG4gICAgXHRcdFx0aGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgXHRcdFx0c3RyID0gSlNPTi5zdHJpbmdpZnkoc3RyKTtcbiAgICBcdFx0fVxuXG4gICAgXHRcdHJlcS53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdHMud2l0aENyZWRlbnRpYWxzO1xuXG4gICAgXHRcdGZvciAoayBpbiBoZWFkZXJzKSB7XG4gICAgXHRcdFx0cmVxLnNldFJlcXVlc3RIZWFkZXIoaywgaGVhZGVyc1trXSk7XG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXEuc2VuZChzdHIpO1xuICAgIFx0fSk7XG4gICAgfVxuXG4gICAgdmFyIGdldCA9IC8qI19fUFVSRV9fKi8gc2VuZC5iaW5kKHNlbmQsICdHRVQnKTtcbiAgICB2YXIgcG9zdCA9IC8qI19fUFVSRV9fKi8gc2VuZC5iaW5kKHNlbmQsICdQT1NUJyk7XG4gICAgdmFyIHBhdGNoID0gLyojX19QVVJFX18qLyBzZW5kLmJpbmQoc2VuZCwgJ1BBVENIJyk7XG4gICAgdmFyIGRlbCA9IC8qI19fUFVSRV9fKi8gc2VuZC5iaW5kKHNlbmQsICdERUxFVEUnKTtcbiAgICB2YXIgcHV0ID0gLyojX19QVVJFX18qLyBzZW5kLmJpbmQoc2VuZCwgJ1BVVCcpO1xuXG4gICAgdmFyIGRlbF8xID0gZGVsO1xuICAgIHZhciBnZXRfMSA9IGdldDtcbiAgICB2YXIgcGF0Y2hfMSA9IHBhdGNoO1xuICAgIHZhciBwb3N0XzEgPSBwb3N0O1xuICAgIHZhciBwdXRfMSA9IHB1dDtcbiAgICB2YXIgc2VuZF8xID0gc2VuZDtcblxuICAgIHZhciB4aHIgPSB7XG4gICAgXHRkZWw6IGRlbF8xLFxuICAgIFx0Z2V0OiBnZXRfMSxcbiAgICBcdHBhdGNoOiBwYXRjaF8xLFxuICAgIFx0cG9zdDogcG9zdF8xLFxuICAgIFx0cHV0OiBwdXRfMSxcbiAgICBcdHNlbmQ6IHNlbmRfMVxuICAgIH07XG5cbiAgICB2YXIgaHR0cCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKC8qI19fUFVSRV9fKi9PYmplY3QuYXNzaWduKC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpLCB4aHIsIHtcbiAgICAgICAgJ2RlZmF1bHQnOiB4aHIsXG4gICAgICAgIGRlbDogZGVsXzEsXG4gICAgICAgIGdldDogZ2V0XzEsXG4gICAgICAgIHBhdGNoOiBwYXRjaF8xLFxuICAgICAgICBwb3N0OiBwb3N0XzEsXG4gICAgICAgIHB1dDogcHV0XzEsXG4gICAgICAgIHNlbmQ6IHNlbmRfMVxuICAgIH0pKTtcblxuICAgIHZhciBTZXJ2ZXJFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFNlcnZlckVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTZXJ2ZXJFcnJvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMubmFtZSA9IFwiU2VydmVyRXJyb3JcIjtcbiAgICAgICAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTZXJ2ZXJFcnJvcjtcbiAgICB9KEVycm9yKSk7XG5cbiAgICAvKipcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTQgSW9uIERyaXZlIFNvZnR3YXJlIEx0ZC5cbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZGFycmFjaGVxdWVzbmUvbm90ZXBhY2svXG4gICAgICpcbiAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgICAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgICAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gICAgICpcbiAgICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgICAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgKiBTT0ZUV0FSRS5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQYXRjaCBmb3IgQ29seXNldXM6XG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICogYWRkZWQgYG9mZnNldGAgb24gRGVjb2RlciBjb25zdHJ1Y3RvciwgZm9yIG1lc3NhZ2VzIGFycml2aW5nIHdpdGggYSBjb2RlXG4gICAgICogYmVmb3JlIGFjdHVhbCBtc2dwYWNrIGRhdGFcbiAgICAgKi9cbiAgICAvLyBcbiAgICAvLyBERUNPREVSXG4gICAgLy8gXG4gICAgZnVuY3Rpb24gRGVjb2RlcihidWZmZXIsIG9mZnNldCkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5fdmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLl9idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBidWZmZXIuYnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5fdmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLl9idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1dGY4UmVhZCQxKHZpZXcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJywgY2hyID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBieXRlID0gdmlldy5nZXRVaW50OChpKTtcbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIDB4ODApID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZSAmIDB4MWYpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlICYgMHgwZikgPDwgMTIpIHxcbiAgICAgICAgICAgICAgICAgICAgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCA2KSB8XG4gICAgICAgICAgICAgICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMCkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChieXRlICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgICAgICBjaHIgPSAoKGJ5dGUgJiAweDA3KSA8PCAxOCkgfFxuICAgICAgICAgICAgICAgICAgICAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDEyKSB8XG4gICAgICAgICAgICAgICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDApO1xuICAgICAgICAgICAgICAgIGlmIChjaHIgPj0gMHgwMTAwMDApIHsgLy8gc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgY2hyIC09IDB4MDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY2hyID4+PiAxMCkgKyAweEQ4MDAsIChjaHIgJiAweDNGRikgKyAweERDMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSAnICsgYnl0ZS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICAgIERlY29kZXIucHJvdG90eXBlLl9hcnJheSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlW2ldID0gdGhpcy5fcGFyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5fbWFwID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gJycsIHZhbHVlID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IHRoaXMuX3BhcnNlKCk7XG4gICAgICAgICAgICB2YWx1ZVtrZXldID0gdGhpcy5fcGFyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5fc3RyID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB1dGY4UmVhZCQxKHRoaXMuX3ZpZXcsIHRoaXMuX29mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgRGVjb2Rlci5wcm90b3R5cGUuX2JpbiA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fYnVmZmVyLnNsaWNlKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgRGVjb2Rlci5wcm90b3R5cGUuX3BhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5fdmlldy5nZXRVaW50OCh0aGlzLl9vZmZzZXQrKyk7XG4gICAgICAgIHZhciB2YWx1ZSwgbGVuZ3RoID0gMCwgdHlwZSA9IDAsIGhpID0gMCwgbG8gPSAwO1xuICAgICAgICBpZiAocHJlZml4IDwgMHhjMCkge1xuICAgICAgICAgICAgLy8gcG9zaXRpdmUgZml4aW50XG4gICAgICAgICAgICBpZiAocHJlZml4IDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaXhtYXBcbiAgICAgICAgICAgIGlmIChwcmVmaXggPCAweDkwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcChwcmVmaXggJiAweDBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpeGFycmF5XG4gICAgICAgICAgICBpZiAocHJlZml4IDwgMHhhMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcnJheShwcmVmaXggJiAweDBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpeHN0clxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0cihwcmVmaXggJiAweDFmKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWdhdGl2ZSBmaXhpbnRcbiAgICAgICAgaWYgKHByZWZpeCA+IDB4ZGYpIHtcbiAgICAgICAgICAgIHJldHVybiAoMHhmZiAtIHByZWZpeCArIDEpICogLTE7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwcmVmaXgpIHtcbiAgICAgICAgICAgIC8vIG5pbFxuICAgICAgICAgICAgY2FzZSAweGMwOlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgLy8gZmFsc2VcbiAgICAgICAgICAgIGNhc2UgMHhjMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyB0cnVlXG4gICAgICAgICAgICBjYXNlIDB4YzM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyBiaW5cbiAgICAgICAgICAgIGNhc2UgMHhjNDpcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0aGlzLl92aWV3LmdldFVpbnQ4KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbihsZW5ndGgpO1xuICAgICAgICAgICAgY2FzZSAweGM1OlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDE2KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbihsZW5ndGgpO1xuICAgICAgICAgICAgY2FzZSAweGM2OlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDMyKHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbihsZW5ndGgpO1xuICAgICAgICAgICAgLy8gZXh0XG4gICAgICAgICAgICBjYXNlIDB4Yzc6XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fdmlldy5nZXRVaW50OCh0aGlzLl9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSB0aGlzLl92aWV3LmdldEludDgodGhpcy5fb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0eXBlLCB0aGlzLl9iaW4obGVuZ3RoKV07XG4gICAgICAgICAgICBjYXNlIDB4Yzg6XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fdmlldy5nZXRVaW50MTYodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0eXBlID0gdGhpcy5fdmlldy5nZXRJbnQ4KHRoaXMuX29mZnNldCArIDIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdHlwZSwgdGhpcy5fYmluKGxlbmd0aCldO1xuICAgICAgICAgICAgY2FzZSAweGM5OlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDMyKHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuX3ZpZXcuZ2V0SW50OCh0aGlzLl9vZmZzZXQgKyA0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3R5cGUsIHRoaXMuX2JpbihsZW5ndGgpXTtcbiAgICAgICAgICAgIC8vIGZsb2F0XG4gICAgICAgICAgICBjYXNlIDB4Y2E6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl92aWV3LmdldEZsb2F0MzIodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIDB4Y2I6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl92aWV3LmdldEZsb2F0NjQodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyB1aW50XG4gICAgICAgICAgICBjYXNlIDB4Y2M6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl92aWV3LmdldFVpbnQ4KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAweGNkOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdmlldy5nZXRVaW50MTYodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIDB4Y2U6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl92aWV3LmdldFVpbnQzMih0aGlzLl9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgMHhjZjpcbiAgICAgICAgICAgICAgICBoaSA9IHRoaXMuX3ZpZXcuZ2V0VWludDMyKHRoaXMuX29mZnNldCkgKiBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICAgICAgbG8gPSB0aGlzLl92aWV3LmdldFVpbnQzMih0aGlzLl9vZmZzZXQgKyA0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGkgKyBsbztcbiAgICAgICAgICAgIC8vIGludFxuICAgICAgICAgICAgY2FzZSAweGQwOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdmlldy5nZXRJbnQ4KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAweGQxOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdmlldy5nZXRJbnQxNih0aGlzLl9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgMHhkMjpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3ZpZXcuZ2V0SW50MzIodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIDB4ZDM6XG4gICAgICAgICAgICAgICAgaGkgPSB0aGlzLl92aWV3LmdldEludDMyKHRoaXMuX29mZnNldCkgKiBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICAgICAgbG8gPSB0aGlzLl92aWV3LmdldFVpbnQzMih0aGlzLl9vZmZzZXQgKyA0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGkgKyBsbztcbiAgICAgICAgICAgIC8vIGZpeGV4dFxuICAgICAgICAgICAgY2FzZSAweGQ0OlxuICAgICAgICAgICAgICAgIHR5cGUgPSB0aGlzLl92aWV3LmdldEludDgodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0eXBlLCB0aGlzLl9iaW4oMSldO1xuICAgICAgICAgICAgY2FzZSAweGQ1OlxuICAgICAgICAgICAgICAgIHR5cGUgPSB0aGlzLl92aWV3LmdldEludDgodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3R5cGUsIHRoaXMuX2JpbigyKV07XG4gICAgICAgICAgICBjYXNlIDB4ZDY6XG4gICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuX3ZpZXcuZ2V0SW50OCh0aGlzLl9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdHlwZSwgdGhpcy5fYmluKDQpXTtcbiAgICAgICAgICAgIGNhc2UgMHhkNzpcbiAgICAgICAgICAgICAgICB0eXBlID0gdGhpcy5fdmlldy5nZXRJbnQ4KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGkgPSB0aGlzLl92aWV3LmdldEludDMyKHRoaXMuX29mZnNldCkgKiBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICAgICAgICAgIGxvID0gdGhpcy5fdmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0ICsgNCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCArPSA4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoaGkgKyBsbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHlwZSwgdGhpcy5fYmluKDgpXTtcbiAgICAgICAgICAgIGNhc2UgMHhkODpcbiAgICAgICAgICAgICAgICB0eXBlID0gdGhpcy5fdmlldy5nZXRJbnQ4KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0eXBlLCB0aGlzLl9iaW4oMTYpXTtcbiAgICAgICAgICAgIC8vIHN0clxuICAgICAgICAgICAgY2FzZSAweGQ5OlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDgodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4ZGE6XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fdmlldy5nZXRVaW50MTYodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4ZGI6XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fdmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICAvLyBhcnJheVxuICAgICAgICAgICAgY2FzZSAweGRjOlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDE2KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDB4ZGQ6XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5fdmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICAgICAgY2FzZSAweGRlOlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDE2KHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcChsZW5ndGgpO1xuICAgICAgICAgICAgY2FzZSAweGRmOlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3ZpZXcuZ2V0VWludDMyKHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcChsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHBhcnNlJyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICAgICAgdmFyIGRlY29kZXIgPSBuZXcgRGVjb2RlcihidWZmZXIsIG9mZnNldCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRlY29kZXIuX3BhcnNlKCk7XG4gICAgICAgIGlmIChkZWNvZGVyLl9vZmZzZXQgIT09IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGJ1ZmZlci5ieXRlTGVuZ3RoIC0gZGVjb2Rlci5fb2Zmc2V0KSArICcgdHJhaWxpbmcgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8vIFxuICAgIC8vIEVOQ09ERVJcbiAgICAvLyBcbiAgICBmdW5jdGlvbiB1dGY4V3JpdGUodmlldywgb2Zmc2V0LCBzdHIpIHtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMHhjMCB8IChjID4+IDYpKTtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMHhlMCB8IChjID4+IDEyKSk7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMHg4MCB8IChjID4+IDYpICYgMHgzZik7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMHg4MCB8IChjICYgMHgzZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKCgoYyAmIDB4M2ZmKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpO1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDB4ZjAgfCAoYyA+PiAxOCkpO1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDB4ODAgfCAoYyA+PiAxMikgJiAweDNmKTtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAweDgwIHwgKGMgPj4gNikgJiAweDNmKTtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXRmOExlbmd0aCQxKHN0cikge1xuICAgICAgICB2YXIgYyA9IDAsIGxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGUwMDApIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZW5jb2RlKGJ5dGVzLCBkZWZlcnMsIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLCBpID0gMCwgbCA9IDAsIGhpID0gMCwgbG8gPSAwLCBsZW5ndGggPSAwLCBzaXplID0gMDtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZW5ndGggPSB1dGY4TGVuZ3RoJDEodmFsdWUpO1xuICAgICAgICAgICAgLy8gZml4c3RyXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgMHgyMCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2gobGVuZ3RoIHwgMHhhMCk7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdHIgOFxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDApIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZDksIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdHIgMTZcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZGEsIGxlbmd0aCA+PiA4LCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIHNpemUgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RyIDMyXG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkYiwgbGVuZ3RoID4+IDI0LCBsZW5ndGggPj4gMTYsIGxlbmd0aCA+PiA4LCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIHNpemUgPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdG9vIGxvbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycy5wdXNoKHsgX3N0cjogdmFsdWUsIF9sZW5ndGg6IGxlbmd0aCwgX29mZnNldDogYnl0ZXMubGVuZ3RoIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNpemUgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBlbmNvZGUgdG8gZmxvYXQgMzI/XG4gICAgICAgICAgICAvLyBmbG9hdCA2NFxuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGNiKTtcbiAgICAgICAgICAgICAgICBkZWZlcnMucHVzaCh7IF9mbG9hdDogdmFsdWUsIF9sZW5ndGg6IDgsIF9vZmZzZXQ6IGJ5dGVzLmxlbmd0aCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpdmUgZml4bnVtXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgOFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhjYywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCAxNlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGNkLCB2YWx1ZSA+PiA4LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1aW50IDMyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGNlLCB2YWx1ZSA+PiAyNCwgdmFsdWUgPj4gMTYsIHZhbHVlID4+IDgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgNjRcbiAgICAgICAgICAgICAgICBoaSA9ICh2YWx1ZSAvIE1hdGgucG93KDIsIDMyKSkgPj4gMDtcbiAgICAgICAgICAgICAgICBsbyA9IHZhbHVlID4+PiAwO1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhjZiwgaGkgPj4gMjQsIGhpID4+IDE2LCBoaSA+PiA4LCBoaSwgbG8gPj4gMjQsIGxvID4+IDE2LCBsbyA+PiA4LCBsbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuZWdhdGl2ZSBmaXhudW1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gLTB4MjApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnQgOFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZDAsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludCAxNlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkMSwgdmFsdWUgPj4gOCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW50IDMyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IC0weDgwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkMiwgdmFsdWUgPj4gMjQsIHZhbHVlID4+IDE2LCB2YWx1ZSA+PiA4LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnQgNjRcbiAgICAgICAgICAgICAgICBoaSA9IE1hdGguZmxvb3IodmFsdWUgLyBNYXRoLnBvdygyLCAzMikpO1xuICAgICAgICAgICAgICAgIGxvID0gdmFsdWUgPj4+IDA7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGQzLCBoaSA+PiAyNCwgaGkgPj4gMTYsIGhpID4+IDgsIGhpLCBsbyA+PiAyNCwgbG8gPj4gMTYsIGxvID4+IDgsIGxvKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIG5pbFxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGMwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBmaXhhcnJheVxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAweDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2gobGVuZ3RoIHwgMHg5MCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhcnJheSAxNlxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGRjLCBsZW5ndGggPj4gOCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFycmF5IDMyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGRkLCBsZW5ndGggPj4gMjQsIGxlbmd0aCA+PiAxNiwgbGVuZ3RoID4+IDgsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSA1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgKz0gX2VuY29kZShieXRlcywgZGVmZXJzLCB2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZml4ZXh0IDggLyBEYXRlXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWUgPSB2YWx1ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgaGkgPSBNYXRoLmZsb29yKHRpbWUgLyBNYXRoLnBvdygyLCAzMikpO1xuICAgICAgICAgICAgICAgIGxvID0gdGltZSA+Pj4gMDtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZDcsIDAsIGhpID4+IDI0LCBoaSA+PiAxNiwgaGkgPj4gOCwgaGksIGxvID4+IDI0LCBsbyA+PiAxNiwgbG8gPj4gOCwgbG8pO1xuICAgICAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBiaW4gOFxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAweDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4YzQsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAgICAgIC8vIGJpbiAxNlxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhjNSwgbGVuZ3RoID4+IDgsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAgICAgIC8vIGJpbiAzMlxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4YzYsIGxlbmd0aCA+PiAyNCwgbGVuZ3RoID4+IDE2LCBsZW5ndGggPj4gOCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlciB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmZXJzLnB1c2goeyBfYmluOiB2YWx1ZSwgX2xlbmd0aDogbGVuZ3RoLCBfb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemUgKyBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZW5jb2RlKGJ5dGVzLCBkZWZlcnMsIHZhbHVlLnRvSlNPTigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrZXlzID0gW10sIGtleSA9ICcnO1xuICAgICAgICAgICAgdmFyIGFsbEtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gYWxsS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBhbGxLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGZpeG1hcFxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDB4MTApIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKGxlbmd0aCB8IDB4ODApO1xuICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFwIDE2XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGRlLCBsZW5ndGggPj4gOCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzaXplID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1hcCAzMlxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZGYsIGxlbmd0aCA+PiAyNCwgbGVuZ3RoID4+IDE2LCBsZW5ndGggPj4gOCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzaXplID0gNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBzaXplICs9IF9lbmNvZGUoYnl0ZXMsIGRlZmVycywga2V5KTtcbiAgICAgICAgICAgICAgICBzaXplICs9IF9lbmNvZGUoYnl0ZXMsIGRlZmVycywgdmFsdWVba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxzZS90cnVlXG4gICAgICAgIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2godmFsdWUgPyAweGMzIDogMHhjMik7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaXhleHQgMSAvIHVuZGVmaW5lZFxuICAgICAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkNCwgMCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBlbmNvZGUnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHZhciBieXRlcyA9IFtdO1xuICAgICAgICB2YXIgZGVmZXJzID0gW107XG4gICAgICAgIHZhciBzaXplID0gX2VuY29kZShieXRlcywgZGVmZXJzLCB2YWx1ZSk7XG4gICAgICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSk7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zik7XG4gICAgICAgIHZhciBkZWZlckluZGV4ID0gMDtcbiAgICAgICAgdmFyIGRlZmVyV3JpdHRlbiA9IDA7XG4gICAgICAgIHZhciBuZXh0T2Zmc2V0ID0gLTE7XG4gICAgICAgIGlmIChkZWZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV4dE9mZnNldCA9IGRlZmVyc1swXS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZlciwgZGVmZXJMZW5ndGggPSAwLCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ5dGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChkZWZlcldyaXR0ZW4gKyBpLCBieXRlc1tpXSk7XG4gICAgICAgICAgICBpZiAoaSArIDEgIT09IG5leHRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVyID0gZGVmZXJzW2RlZmVySW5kZXhdO1xuICAgICAgICAgICAgZGVmZXJMZW5ndGggPSBkZWZlci5fbGVuZ3RoO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZGVmZXJXcml0dGVuICsgbmV4dE9mZnNldDtcbiAgICAgICAgICAgIGlmIChkZWZlci5fYmluKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpbiA9IG5ldyBVaW50OEFycmF5KGRlZmVyLl9iaW4pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVmZXJMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIGosIGJpbltqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmZXIuX3N0cikge1xuICAgICAgICAgICAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQsIGRlZmVyLl9zdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmZXIuX2Zsb2F0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldEZsb2F0NjQob2Zmc2V0LCBkZWZlci5fZmxvYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJJbmRleCsrO1xuICAgICAgICAgICAgZGVmZXJXcml0dGVuICs9IGRlZmVyTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGRlZmVyc1tkZWZlckluZGV4XSkge1xuICAgICAgICAgICAgICAgIG5leHRPZmZzZXQgPSBkZWZlcnNbZGVmZXJJbmRleF0uX29mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHZhciBicm93c2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnd3MgZG9lcyBub3Qgd29yayBpbiB0aGUgYnJvd3Nlci4gQnJvd3NlciBjbGllbnRzIG11c3QgdXNlIHRoZSBuYXRpdmUgJyArXG4gICAgICAgICAgJ1dlYlNvY2tldCBvYmplY3QnXG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgV2ViU29ja2V0ID0gZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfHwgYnJvd3NlcjtcbiAgICB2YXIgV2ViU29ja2V0VHJhbnNwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQoZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICAgICAgfVxuICAgICAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndzLnNlbmQoKG5ldyBVaW50OEFycmF5KGRhdGEpKS5idWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldCh1cmwsIHRoaXMucHJvdG9jb2xzKTtcbiAgICAgICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICB0aGlzLndzLm9ub3BlbiA9IHRoaXMuZXZlbnRzLm9ub3BlbjtcbiAgICAgICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5ldmVudHMub25tZXNzYWdlO1xuICAgICAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gdGhpcy5ldmVudHMub25jbG9zZTtcbiAgICAgICAgICAgIHRoaXMud3Mub25lcnJvciA9IHRoaXMuZXZlbnRzLm9uZXJyb3I7XG4gICAgICAgIH07XG4gICAgICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY29kZSwgcmVhc29uKSB7XG4gICAgICAgICAgICB0aGlzLndzLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBXZWJTb2NrZXRUcmFuc3BvcnQ7XG4gICAgfSgpKTtcblxuICAgIHZhciBDb25uZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb25uZWN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3IFdlYlNvY2tldFRyYW5zcG9ydCh0aGlzLmV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY29ubmVjdCh1cmwpO1xuICAgICAgICB9O1xuICAgICAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb25uZWN0aW9uO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgc2VyaWFsaXplcnMgPSB7fTtcbiAgICBmdW5jdGlvbiByZWdpc3RlclNlcmlhbGl6ZXIoaWQsIHNlcmlhbGl6ZXIpIHtcbiAgICAgICAgc2VyaWFsaXplcnNbaWRdID0gc2VyaWFsaXplcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U2VyaWFsaXplcihpZCkge1xuICAgICAgICB2YXIgc2VyaWFsaXplciA9IHNlcmlhbGl6ZXJzW2lkXTtcbiAgICAgICAgaWYgKCFzZXJpYWxpemVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNlcmlhbGl6ZXI6IFwiICsgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyO1xuICAgIH1cblxuICAgIC8vIFVzZSBjb2RlcyBiZXR3ZWVuIDB+MTI3IGZvciBsZXNzZXIgdGhyb3VnaHB1dCAoMSBieXRlKVxuICAgIGV4cG9ydHMuUHJvdG9jb2wgPSB2b2lkIDA7XG4gICAgKGZ1bmN0aW9uIChQcm90b2NvbCkge1xuICAgICAgICAvLyBSb29tLXJlbGF0ZWQgKDEwfjE5KVxuICAgICAgICBQcm90b2NvbFtQcm90b2NvbFtcIkhBTkRTSEFLRVwiXSA9IDldID0gXCJIQU5EU0hBS0VcIjtcbiAgICAgICAgUHJvdG9jb2xbUHJvdG9jb2xbXCJKT0lOX1JPT01cIl0gPSAxMF0gPSBcIkpPSU5fUk9PTVwiO1xuICAgICAgICBQcm90b2NvbFtQcm90b2NvbFtcIkVSUk9SXCJdID0gMTFdID0gXCJFUlJPUlwiO1xuICAgICAgICBQcm90b2NvbFtQcm90b2NvbFtcIkxFQVZFX1JPT01cIl0gPSAxMl0gPSBcIkxFQVZFX1JPT01cIjtcbiAgICAgICAgUHJvdG9jb2xbUHJvdG9jb2xbXCJST09NX0RBVEFcIl0gPSAxM10gPSBcIlJPT01fREFUQVwiO1xuICAgICAgICBQcm90b2NvbFtQcm90b2NvbFtcIlJPT01fU1RBVEVcIl0gPSAxNF0gPSBcIlJPT01fU1RBVEVcIjtcbiAgICAgICAgUHJvdG9jb2xbUHJvdG9jb2xbXCJST09NX1NUQVRFX1BBVENIXCJdID0gMTVdID0gXCJST09NX1NUQVRFX1BBVENIXCI7XG4gICAgICAgIFByb3RvY29sW1Byb3RvY29sW1wiUk9PTV9EQVRBX1NDSEVNQVwiXSA9IDE2XSA9IFwiUk9PTV9EQVRBX1NDSEVNQVwiO1xuICAgIH0pKGV4cG9ydHMuUHJvdG9jb2wgfHwgKGV4cG9ydHMuUHJvdG9jb2wgPSB7fSkpO1xuICAgIGV4cG9ydHMuRXJyb3JDb2RlID0gdm9pZCAwO1xuICAgIChmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJNQVRDSE1BS0VfTk9fSEFORExFUlwiXSA9IDQyMTBdID0gXCJNQVRDSE1BS0VfTk9fSEFORExFUlwiO1xuICAgICAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTUFUQ0hNQUtFX0lOVkFMSURfQ1JJVEVSSUFcIl0gPSA0MjExXSA9IFwiTUFUQ0hNQUtFX0lOVkFMSURfQ1JJVEVSSUFcIjtcbiAgICAgICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIk1BVENITUFLRV9JTlZBTElEX1JPT01fSURcIl0gPSA0MjEyXSA9IFwiTUFUQ0hNQUtFX0lOVkFMSURfUk9PTV9JRFwiO1xuICAgICAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTUFUQ0hNQUtFX1VOSEFORExFRFwiXSA9IDQyMTNdID0gXCJNQVRDSE1BS0VfVU5IQU5ETEVEXCI7XG4gICAgICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJNQVRDSE1BS0VfRVhQSVJFRFwiXSA9IDQyMTRdID0gXCJNQVRDSE1BS0VfRVhQSVJFRFwiO1xuICAgICAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQVVUSF9GQUlMRURcIl0gPSA0MjE1XSA9IFwiQVVUSF9GQUlMRURcIjtcbiAgICAgICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkFQUExJQ0FUSU9OX0VSUk9SXCJdID0gNDIxNl0gPSBcIkFQUExJQ0FUSU9OX0VSUk9SXCI7XG4gICAgfSkoZXhwb3J0cy5FcnJvckNvZGUgfHwgKGV4cG9ydHMuRXJyb3JDb2RlID0ge30pKTtcbiAgICBmdW5jdGlvbiB1dGY4UmVhZCh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZpZXdbb2Zmc2V0KytdO1xuICAgICAgICB2YXIgc3RyaW5nID0gJycsIGNociA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZSA9IHZpZXdbaV07XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiAweDgwKSA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChieXRlICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGUgJiAweDFmKSA8PCA2KSB8XG4gICAgICAgICAgICAgICAgICAgICh2aWV3WysraV0gJiAweDNmKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZSAmIDB4MGYpIDw8IDEyKSB8XG4gICAgICAgICAgICAgICAgICAgICgodmlld1srK2ldICYgMHgzZikgPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAoKHZpZXdbKytpXSAmIDB4M2YpIDw8IDApKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gKChieXRlICYgMHgwNykgPDwgMTgpIHxcbiAgICAgICAgICAgICAgICAgICAgKCh2aWV3WysraV0gJiAweDNmKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICAgICAoKHZpZXdbKytpXSAmIDB4M2YpIDw8IDYpIHxcbiAgICAgICAgICAgICAgICAgICAgKCh2aWV3WysraV0gJiAweDNmKSA8PCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hyID49IDB4MDEwMDAwKSB7IC8vIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICAgICAgICAgIGNociAtPSAweDAxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNociA+Pj4gMTApICsgMHhEODAwLCAoY2hyICYgMHgzRkYpICsgMHhEQzAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgJyArIGJ5dGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cbiAgICAvLyBGYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgdGhhbiBCdWZmZXIuYnl0ZUxlbmd0aFxuICAgIGZ1bmN0aW9uIHV0ZjhMZW5ndGgoc3RyKSB7XG4gICAgICAgIGlmIChzdHIgPT09IHZvaWQgMCkgeyBzdHIgPSAnJzsgfVxuICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aCArIDE7XG4gICAgfVxuXG4gICAgbGV0IGNyZWF0ZU5hbm9FdmVudHMgPSAoKSA9PiAoe1xuICAgICAgZXZlbnRzOiB7fSxcbiAgICAgIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAodGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdKS5mb3JFYWNoKGkgPT4gaSguLi5hcmdzKSk7XG4gICAgICB9LFxuICAgICAgb24oZXZlbnQsIGNiKSB7XG4gICAgKHRoaXMuZXZlbnRzW2V2ZW50XSA9IHRoaXMuZXZlbnRzW2V2ZW50XSB8fCBbXSkucHVzaChjYik7XG4gICAgICAgIHJldHVybiAoKSA9PlxuICAgICAgICAgICh0aGlzLmV2ZW50c1tldmVudF0gPSAodGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdKS5maWx0ZXIoaSA9PiBpICE9PSBjYikpXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgRXZlbnRFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChjYiwgb25jZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGNiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGhhbmRsZXIuYXBwbHkoX3RoaXMsIGFyZ3MpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5pbnZva2VBc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGhhbmRsZXIuYXBwbHkoX3RoaXMsIGFyZ3MpOyB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmhhbmRsZXJzLmluZGV4T2YoY2IpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyc1tpbmRleF0gPSB0aGlzLmhhbmRsZXJzW3RoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzLnBvcCgpO1xuICAgICAgICB9O1xuICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gY3JlYXRlU2lnbmFsKCkge1xuICAgICAgICB2YXIgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXIoY2IpIHtcbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyLnJlZ2lzdGVyKGNiLCB0aGlzID09PSBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3Rlci5vbmNlID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbWl0dGVyLnJlZ2lzdGVyKGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVnaXN0ZXIucmVtb3ZlID0gZnVuY3Rpb24gKGNiKSB7IHJldHVybiBlbWl0dGVyLnJlbW92ZShjYik7IH07XG4gICAgICAgIHJlZ2lzdGVyLmludm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyLmludm9rZS5hcHBseShlbWl0dGVyLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVnaXN0ZXIuaW52b2tlQXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW1pdHRlci5pbnZva2VBc3luYy5hcHBseShlbWl0dGVyLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVnaXN0ZXIuY2xlYXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBlbWl0dGVyLmNsZWFyKCk7IH07XG4gICAgICAgIHJldHVybiByZWdpc3RlcjtcbiAgICB9XG5cbiAgICB2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuKSB7XG4gICAgICB2YXIgbW9kdWxlID0geyBleHBvcnRzOiB7fSB9O1xuICAgIFx0cmV0dXJuIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbiAgICB9XG5cbiAgICB2YXIgdW1kID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIChmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgICAgIGZhY3RvcnkoZXhwb3J0cykgO1xuICAgIH0oY29tbW9uanNHbG9iYWwsIChmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcbiAgICAgICAgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbiAgICAgICAgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuICAgICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcbiAgICAgICAgUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbiAgICAgICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG4gICAgICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG4gICAgICAgIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbiAgICAgICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG4gICAgICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbiAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuICAgICAgICAvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuICAgICAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgICAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20pIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXHJcbiAgICAgICAgICAgICAgICB0b1tqXSA9IGZyb21baV07XHJcbiAgICAgICAgICAgIHJldHVybiB0bztcclxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXhwb3J0IGNvbnN0IFNXSVRDSF9UT19TVFJVQ1RVUkUgPSAxOTM7IChlYXNpbHkgY29sbGlkZXMgd2l0aCBERUxFVEVfQU5EX0FERCArIGZpZWxkSW5kZXggPSAyKVxuICAgICAgICB2YXIgU1dJVENIX1RPX1NUUlVDVFVSRSA9IDI1NTsgLy8gKGRlY29kaW5nIGNvbGxpZGVzIHdpdGggREVMRVRFX0FORF9BREQgKyBmaWVsZEluZGV4ID0gNjMpXG4gICAgICAgIHZhciBUWVBFX0lEID0gMjEzO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RpbmcgU2NoZW1hIGZpZWxkIG9wZXJhdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBleHBvcnRzLk9QRVJBVElPTiA9IHZvaWQgMDtcbiAgICAgICAgKGZ1bmN0aW9uIChPUEVSQVRJT04pIHtcbiAgICAgICAgICAgIC8vIGFkZCBuZXcgc3RydWN0dXJlL3ByaW1pdGl2ZVxuICAgICAgICAgICAgT1BFUkFUSU9OW09QRVJBVElPTltcIkFERFwiXSA9IDEyOF0gPSBcIkFERFwiO1xuICAgICAgICAgICAgLy8gcmVwbGFjZSBzdHJ1Y3R1cmUvcHJpbWl0aXZlXG4gICAgICAgICAgICBPUEVSQVRJT05bT1BFUkFUSU9OW1wiUkVQTEFDRVwiXSA9IDBdID0gXCJSRVBMQUNFXCI7XG4gICAgICAgICAgICAvLyBkZWxldGUgZmllbGRcbiAgICAgICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJERUxFVEVcIl0gPSA2NF0gPSBcIkRFTEVURVwiO1xuICAgICAgICAgICAgLy8gREVMRVRFIGZpZWxkLCBmb2xsb3dlZCBieSBhbiBBRERcbiAgICAgICAgICAgIE9QRVJBVElPTltPUEVSQVRJT05bXCJERUxFVEVfQU5EX0FERFwiXSA9IDE5Ml0gPSBcIkRFTEVURV9BTkRfQUREXCI7XG4gICAgICAgICAgICAvLyBUT1VDSCBpcyB1c2VkIHRvIGRldGVybWluZSBoaWVyYXJjaHkgb2YgbmVzdGVkIFNjaGVtYSBzdHJ1Y3R1cmVzIGR1cmluZyBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgLy8gdG91Y2hlcyBhcmUgTk9UIGVuY29kZWQuXG4gICAgICAgICAgICBPUEVSQVRJT05bT1BFUkFUSU9OW1wiVE9VQ0hcIl0gPSAxXSA9IFwiVE9VQ0hcIjtcbiAgICAgICAgICAgIC8vIE1hcFNjaGVtYSBPcGVyYXRpb25zXG4gICAgICAgICAgICBPUEVSQVRJT05bT1BFUkFUSU9OW1wiQ0xFQVJcIl0gPSAxMF0gPSBcIkNMRUFSXCI7XG4gICAgICAgIH0pKGV4cG9ydHMuT1BFUkFUSU9OIHx8IChleHBvcnRzLk9QRVJBVElPTiA9IHt9KSk7XG4gICAgICAgIC8vIGV4cG9ydCBlbnVtIE9QRVJBVElPTiB7XG4gICAgICAgIC8vICAgICAvLyBhZGQgbmV3IHN0cnVjdHVyZS9wcmltaXRpdmVcbiAgICAgICAgLy8gICAgIC8vICgxMjgpXG4gICAgICAgIC8vICAgICBBREQgPSAxMjgsIC8vIDEwMDAwMDAwLFxuICAgICAgICAvLyAgICAgLy8gcmVwbGFjZSBzdHJ1Y3R1cmUvcHJpbWl0aXZlXG4gICAgICAgIC8vICAgICBSRVBMQUNFID0gMSwvLyAwMDAwMDAwMVxuICAgICAgICAvLyAgICAgLy8gZGVsZXRlIGZpZWxkXG4gICAgICAgIC8vICAgICBERUxFVEUgPSAxOTIsIC8vIDExMDAwMDAwXG4gICAgICAgIC8vICAgICAvLyBERUxFVEUgZmllbGQsIGZvbGxvd2VkIGJ5IGFuIEFERFxuICAgICAgICAvLyAgICAgREVMRVRFX0FORF9BREQgPSAyMjQsIC8vIDExMTAwMDAwXG4gICAgICAgIC8vICAgICAvLyBUT1VDSCBpcyB1c2VkIHRvIGRldGVybWluZSBoaWVyYXJjaHkgb2YgbmVzdGVkIFNjaGVtYSBzdHJ1Y3R1cmVzIGR1cmluZyBzZXJpYWxpemF0aW9uLlxuICAgICAgICAvLyAgICAgLy8gdG91Y2hlcyBhcmUgTk9UIGVuY29kZWQuXG4gICAgICAgIC8vICAgICBUT1VDSCA9IDAsIC8vIDAwMDAwMDAwXG4gICAgICAgIC8vICAgICAvLyBNYXBTY2hlbWEgT3BlcmF0aW9uc1xuICAgICAgICAvLyAgICAgQ0xFQVIgPSAxMCxcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJvb3QgaG9sZHMgYWxsIHNjaGVtYSByZWZlcmVuY2VzIGJ5IHVuaXF1ZSBpZFxuICAgICAgICAvL1xuICAgICAgICB2YXIgUm9vdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJvb3QoKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBSZWxhdGlvbiBvZiByZWZJZCA9PiBTY2hlbWEgc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgLy8gRm9yIGRpcmVjdCBhY2Nlc3Mgb2Ygc3RydWN0dXJlcyBkdXJpbmcgZGVjb2RpbmcgdGltZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZkNvdW50cyA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlZFJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0VW5pcXVlSWQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm9vdC5wcm90b3R5cGUuZ2V0TmV4dFVuaXF1ZUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRVbmlxdWVJZCsrO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGZvciBkZWNvZGluZ1xuICAgICAgICAgICAgUm9vdC5wcm90b3R5cGUuYWRkUmVmID0gZnVuY3Rpb24gKHJlZklkLCByZWYsIGluY3JlbWVudENvdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluY3JlbWVudENvdW50ID09PSB2b2lkIDApIHsgaW5jcmVtZW50Q291bnQgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZzLnNldChyZWZJZCwgcmVmKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jcmVtZW50Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZDb3VudHNbcmVmSWRdID0gKHRoaXMucmVmQ291bnRzW3JlZklkXSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGZvciBkZWNvZGluZ1xuICAgICAgICAgICAgUm9vdC5wcm90b3R5cGUucmVtb3ZlUmVmID0gZnVuY3Rpb24gKHJlZklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZDb3VudHNbcmVmSWRdID0gdGhpcy5yZWZDb3VudHNbcmVmSWRdIC0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZWRSZWZzLmFkZChyZWZJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUm9vdC5wcm90b3R5cGUuY2xlYXJSZWZzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlZFJlZnMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZkNvdW50cyA9IHt9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGZvciBkZWNvZGluZ1xuICAgICAgICAgICAgUm9vdC5wcm90b3R5cGUuZ2FyYmFnZUNvbGxlY3REZWxldGVkUmVmcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlZFJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlZkNvdW50c1tyZWZJZF0gPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IF90aGlzLnJlZnMuZ2V0KHJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY2hpbGQgc2NoZW1hIGluc3RhbmNlcyBoYXZlIHRoZWlyIHJlZmVyZW5jZXMgcmVtb3ZlZCBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gcmVmWydfZGVmaW5pdGlvbiddLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZWZbJ19kZWZpbml0aW9uJ10uc2NoZW1hW2ZpZWxkTmFtZV0pICE9PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZbZmllbGROYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmW2ZpZWxkTmFtZV1bJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZVJlZihyZWZbZmllbGROYW1lXVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IHJlZlsnJGNoYW5nZXMnXS5wYXJlbnQuX2RlZmluaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBkZWZpbml0aW9uLnNjaGVtYVtkZWZpbml0aW9uLmZpZWxkc0J5SW5kZXhbcmVmWyckY2hhbmdlcyddLnBhcmVudEluZGV4XV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoT2JqZWN0LnZhbHVlcyh0eXBlKVswXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHJlZi52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gX3RoaXMucmVtb3ZlUmVmKGNoaWxkWyckY2hhbmdlcyddLnJlZklkKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmcy5kZWxldGUocmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnJlZkNvdW50c1tyZWZJZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBkZWxldGVkIHJlZnMuXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVkUmVmcy5jbGVhcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBSb290O1xuICAgICAgICB9KCkpO1xuICAgICAgICB2YXIgQ2hhbmdlVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIENoYW5nZVRyZWUocmVmLCBwYXJlbnQsIHJvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxDaGFuZ2VzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIC8vIGNhY2hlZCBpbmRleGVzIGZvciBmaWx0ZXJpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlcyA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEN1c3RvbU9wZXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJlbnQocGFyZW50LCByb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQsIHJvb3QsIHBhcmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXMgPSAodGhpcy5yZWYgaW5zdGFuY2VvZiBTY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMucmVmWydfZGVmaW5pdGlvbiddLmluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50SW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCBzZXR0aW5nIHBhcmVudHMgd2l0aCBlbXB0eSBgcm9vdGBcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gYXNzaWduIHNhbWUgcGFyZW50IG9uIGNoaWxkIHN0cnVjdHVyZXNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZiBpbnN0YW5jZW9mIFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IHRoaXMucmVmWydfZGVmaW5pdGlvbiddO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiBkZWZpbml0aW9uLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5yZWZbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEluZGV4XzEgPSBkZWZpbml0aW9uLmluZGV4ZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWyckY2hhbmdlcyddLnNldFBhcmVudCh0aGlzLnJlZiwgcm9vdCwgcGFyZW50SW5kZXhfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mICh0aGlzLnJlZikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWYuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZVRyZWVlID0gdmFsdWVbJyRjaGFuZ2VzJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEluZGV4XzIgPSBfdGhpcy5yZWZbJyRjaGFuZ2VzJ10uaW5kZXhlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWVlLnNldFBhcmVudChfdGhpcy5yZWYsIF90aGlzLnJvb3QsIHBhcmVudEluZGV4XzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ2hhbmdlVHJlZS5wcm90b3R5cGUub3BlcmF0aW9uID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLnNldCgtLXRoaXMuY3VycmVudEN1c3RvbU9wZXJhdGlvbiwgb3ApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLmNoYW5nZSA9IGZ1bmN0aW9uIChmaWVsZE5hbWUsIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT09IHZvaWQgMCkgeyBvcGVyYXRpb24gPSBleHBvcnRzLk9QRVJBVElPTi5BREQ7IH1cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAodHlwZW9mIChmaWVsZE5hbWUpID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkTmFtZVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuaW5kZXhlc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRJbmRleChpbmRleCwgZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNDaGFuZ2UgPSB0aGlzLmNoYW5nZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzQ2hhbmdlIHx8XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ2hhbmdlLm9wID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNDaGFuZ2Uub3AgPT09IGV4cG9ydHMuT1BFUkFUSU9OLlRPVUNIIC8vIChtYXptb3JyYS5pbydzIEJhdHRsZUFjdGlvbiBpc3N1ZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLnNldChpbmRleCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3A6ICghcHJldmlvdXNDaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChwcmV2aW91c0NoYW5nZS5vcCA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfQUREXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gOiBPUEVSQVRJT04uUkVQTEFDRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxDaGFuZ2VzLmFkZChpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoUGFyZW50cygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24gKGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9ICh0eXBlb2YgKGZpZWxkTmFtZSkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgID8gZmllbGROYW1lXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5pbmRleGVzW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZEluZGV4KGluZGV4LCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGFuZ2VzLmhhcyhpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLnNldChpbmRleCwgeyBvcDogZXhwb3J0cy5PUEVSQVRJT04uVE9VQ0gsIGluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxDaGFuZ2VzLmFkZChpbmRleCk7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRvdWNoIGlzIHBsYWNlZCB1bnRpbCB0aGUgJHJvb3QgaXMgZm91bmQuXG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaFBhcmVudHMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDaGFuZ2VUcmVlLnByb3RvdHlwZS50b3VjaFBhcmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50WyckY2hhbmdlcyddLnRvdWNoKHRoaXMucGFyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDaGFuZ2VUcmVlLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVmWydfZGVmaW5pdGlvbiddKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gdGhpcy5yZWZbJ19kZWZpbml0aW9uJ107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uLnNjaGVtYVtkZWZpbml0aW9uLmZpZWxkc0J5SW5kZXhbaW5kZXhdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gdGhpcy5wYXJlbnRbJ19kZWZpbml0aW9uJ107XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gZGVmaW5pdGlvbi5zY2hlbWFbZGVmaW5pdGlvbi5maWVsZHNCeUluZGV4W3RoaXMucGFyZW50SW5kZXhdXTtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjaGlsZCB0eXBlIGZyb20gcGFyZW50IHN0cnVjdHVyZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gLSBbXCJzdHJpbmdcIl0gPT4gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAvLyAtIHsgbWFwOiBcInN0cmluZ1wiIH0gPT4gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAvLyAtIHsgc2V0OiBcInN0cmluZ1wiIH0gPT4gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhwYXJlbnRUeXBlKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ2hhbmdlVHJlZS5wcm90b3R5cGUuZ2V0Q2hpbGRyZW5GaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkRmlsdGVycyA9IHRoaXMucGFyZW50WydfZGVmaW5pdGlvbiddLmNoaWxkRmlsdGVycztcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRGaWx0ZXJzICYmIGNoaWxkRmlsdGVyc1t0aGlzLnBhcmVudEluZGV4XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdXNlZCBkdXJpbmcgYC5lbmNvZGUoKWBcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBDaGFuZ2VUcmVlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZlsnZ2V0QnlJbmRleCddKGluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDaGFuZ2VUcmVlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gKHR5cGVvZiAoZmllbGROYW1lKSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgPyBmaWVsZE5hbWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmluZGV4ZXNbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAY29seXNldXMvc2NoZW1hIFwiICsgdGhpcy5yZWYuY29uc3RydWN0b3IubmFtZSArIFwiOiB0cnlpbmcgdG8gZGVsZXRlIG5vbi1leGlzdGluZyBpbmRleDogXCIgKyBmaWVsZE5hbWUgKyBcIiAoXCIgKyBpbmRleCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiJGNoYW5nZXMuZGVsZXRlID0+XCIsIHsgZmllbGROYW1lLCBpbmRleCwgcHJldmlvdXNWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGluZGV4LCB7IG9wOiBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUsIGluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbENoYW5nZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgY2FjaGVcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBgcm9vdGAgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgJiYgcHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlWyckY2hhbmdlcyddLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdWNoUGFyZW50cygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLmRpc2NhcmQgPSBmdW5jdGlvbiAoY2hhbmdlZCwgZGlzY2FyZEFsbCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQgPT09IHZvaWQgMCkgeyBjaGFuZ2VkID0gZmFsc2U7IH1cbiAgICAgICAgICAgICAgICBpZiAoZGlzY2FyZEFsbCA9PT0gdm9pZCAwKSB7IGRpc2NhcmRBbGwgPSBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gTWFwLCBBcnJheSwgZXRjOlxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjYWNoZWQga2V5IHRvIGVuc3VyZSBBREQgb3BlcmF0aW9ucyBpcyB1bnNlZCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gUkVQTEFDRSBpbiBjYXNlIHNhbWUga2V5IGlzIHVzZWQgb24gbmV4dCBwYXRjaGVzLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcy4gdGhpcyBpcyBub3QgcmVsZXZhbnQgZm9yIENvbGxlY3Rpb24gYW5kIFNldC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmICghKHRoaXMucmVmIGluc3RhbmNlb2YgU2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLm9wID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5yZWZbJ2dldEluZGV4J10oY2hhbmdlLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuaW5kZXhlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIGlmIChkaXNjYXJkQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsQ2hhbmdlcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZS1zZXQgYGN1cnJlbnRDdXN0b21PcGVyYXRpb25gXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q3VzdG9tT3BlcmF0aW9uID0gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlY3Vyc2l2ZWx5IGRpc2NhcmQgYWxsIGNoYW5nZXMgZnJvbSB0aGlzLCBhbmQgY2hpbGQgc3RydWN0dXJlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ2hhbmdlVHJlZS5wcm90b3R5cGUuZGlzY2FyZEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMuZ2V0VmFsdWUoY2hhbmdlLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVsnJGNoYW5nZXMnXS5kaXNjYXJkQWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2NhcmQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBjYWNoZShmaWVsZDogbnVtYmVyLCBiZWdpbkluZGV4OiBudW1iZXIsIGVuZEluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24gKGZpZWxkLCBjYWNoZWRCeXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVzW2ZpZWxkXSA9IGNhY2hlZEJ5dGVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENoYW5nZVRyZWUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhbmdlVHJlZSh0aGlzLnJlZiwgdGhpcy5wYXJlbnQsIHRoaXMucm9vdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ2hhbmdlVHJlZS5wcm90b3R5cGUuZW5zdXJlUmVmSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiByZWZJZCBpcyBhbHJlYWR5IHNldC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZJZCA9IHRoaXMucm9vdC5nZXROZXh0VW5pcXVlSWQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDaGFuZ2VUcmVlLnByb3RvdHlwZS5hc3NlcnRWYWxpZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFuZ2VUcmVlOiBtaXNzaW5nIGluZGV4IGZvciBmaWVsZCBcXFwiXCIgKyBmaWVsZE5hbWUgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBDaGFuZ2VUcmVlO1xuICAgICAgICB9KCkpO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGVzOlxuICAgICAgICAvLyAtLS0tLVxuICAgICAgICAvL1xuICAgICAgICAvLyAtIFRoZSB0c2NvbmZpZy5qc29uIG9mIEBjb2x5c2V1cy9zY2hlbWEgdXNlcyBFUzIwMTguXG4gICAgICAgIC8vIC0gRVMyMDE5IGludHJvZHVjZXMgYGZsYXRNYXBgIC8gYGZsYXRgLCB3aGljaCBpcyBub3QgY3VycmVudGx5IHJlbGV2YW50LCBhbmQgY2F1c2VkIG90aGVyIGlzc3Vlcy5cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIERFRkFVTFRfU09SVCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgQSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBCID0gYi50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKEEgPCBCKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKEEgPiBCKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBnZXRBcnJheVByb3h5KHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZVsnJHByb3h5J10gPSB0cnVlO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGNvbXBhdGliaWxpdHkgd2l0aCBAY29seXNldXMvc2NoZW1hIDAuNS54XG4gICAgICAgICAgICAvLyAtIGFsbG93IGBtYXBbXCJrZXlcIl1gXG4gICAgICAgICAgICAvLyAtIGFsbG93IGBtYXBbXCJrZXlcIl0gPSBcInh4eFwiYFxuICAgICAgICAgICAgLy8gLSBhbGxvdyBgZGVsZXRlIG1hcFtcImtleVwiXWBcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBQcm94eSh2YWx1ZSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSAhPT0gXCJzeW1ib2xcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzTmFOKHByb3ApIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzU3ODcvODkyNjk4XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5hdChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG9iaiwgcHJvcCwgc2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgIT09IFwic3ltYm9sXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc05hTihwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBBcnJheS5mcm9tKG9ialsnJGl0ZW1zJ10ua2V5cygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwYXJzZUludChpbmRleGVzW3Byb3BdIHx8IHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldFZhbHVlID09PSB1bmRlZmluZWQgfHwgc2V0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZGVsZXRlQXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zZXRBdChrZXksIHNldFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNldFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIChvYmosIHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5kZWxldGVBdChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBBcnJheVNjaGVtYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEFycmF5U2NoZW1hKCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMgPSBuZXcgQ2hhbmdlVHJlZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZklkID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2guYXBwbHkodGhpcywgaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQXJyYXlTY2hlbWEuaXMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgLy8gdHlwZSBmb3JtYXQ6IFtcInN0cmluZ1wiXVxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodHlwZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gdHlwZSBmb3JtYXQ6IHsgYXJyYXk6IFwic3RyaW5nXCIgfVxuICAgICAgICAgICAgICAgICAgICAodHlwZVsnYXJyYXknXSAhPT0gdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5U2NoZW1hLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuc2l6ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpY2UodmFsdWUsIHRoaXMubGVuZ3RoIC0gdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBcImluZGV4XCIgZm9yIHJlZmVyZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gX3RoaXMuJHJlZklkKys7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEF0KGxhc3RJbmRleCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0SW5kZXg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IGVsZW1lbnQgZnJvbSBhbiBhcnJheSBhbmQgcmV0dXJucyBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gQXJyYXkuZnJvbSh0aGlzLiRpbmRleGVzLnZhbHVlcygpKS5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuJGl0ZW1zLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiB0aGlzIHNob3VsZCBiZSBPKDEpXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy5rZXlzKCkpW2luZGV4XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbJyRjaGFuZ2VzJ10uc2V0UGFyZW50KHRoaXMsIHRoaXMuJGNoYW5nZXMucm9vdCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gKF9iID0gKF9hID0gdGhpcy4kY2hhbmdlcy5pbmRleGVzW2luZGV4XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBleHBvcnRzLk9QRVJBVElPTi5BREQ7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5pbmRleGVzW2luZGV4XSA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuc2V0KGluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5jaGFuZ2UoaW5kZXgsIG9wZXJhdGlvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmRlbGV0ZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMua2V5cygpKVtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGRlbGV0ZUF0KGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLiRkZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBhdCBpbnRlcm5hbCBpbmRleFxuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmRlbGV0ZShpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIC8vIGRpc2NhcmQgcHJldmlvdXMgb3BlcmF0aW9ucy5cbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmRpc2NhcmQodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5pbmRleGVzID0ge307XG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgcHJldmlvdXMgaW5kZXhlc1xuICAgICAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAvLyBmbGFnIGNoaWxkIGl0ZW1zIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVjb2RpbmcgJiYgdHlwZW9mICh0aGlzLiRjaGFuZ2VzLmdldFR5cGUoKSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGNoYW5nZXMucm9vdC5yZW1vdmVSZWYoaXRlbVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjbGVhciBpdGVtc1xuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5vcGVyYXRpb24oeyBpbmRleDogMCwgb3A6IGV4cG9ydHMuT1BFUkFUSU9OLkNMRUFSIH0pO1xuICAgICAgICAgICAgICAgIC8vIHRvdWNoIGFsbCBzdHJ1Y3R1cmVzIHVudGlsIHJlYWNoIHJvb3RcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLnRvdWNoUGFyZW50cygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29tYmluZXMgdHdvIG9yIG1vcmUgYXJyYXlzLlxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1zIEFkZGl0aW9uYWwgaXRlbXMgdG8gYWRkIHRvIHRoZSBlbmQgb2YgYXJyYXkxLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IChBcnJheVNjaGVtYS5iaW5kLmFwcGx5KEFycmF5U2NoZW1hLCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCAoX2EgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKSkuY29uY2F0LmFwcGx5KF9hLCBpdGVtcykpKSkoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZHMgYWxsIHRoZSBlbGVtZW50cyBvZiBhbiBhcnJheSBzZXBhcmF0ZWQgYnkgdGhlIHNwZWNpZmllZCBzZXBhcmF0b3Igc3RyaW5nLlxuICAgICAgICAgICAgICogQHBhcmFtIHNlcGFyYXRvciBBIHN0cmluZyB1c2VkIHRvIHNlcGFyYXRlIG9uZSBlbGVtZW50IG9mIGFuIGFycmF5IGZyb20gdGhlIG5leHQgaW4gdGhlIHJlc3VsdGluZyBTdHJpbmcuIElmIG9taXR0ZWQsIHRoZSBhcnJheSBlbGVtZW50cyBhcmUgc2VwYXJhdGVkIHdpdGggYSBjb21tYS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAoc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldmVyc2VzIHRoZSBlbGVtZW50cyBpbiBhbiBBcnJheS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMua2V5cygpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmV2ZXJzZWRJdGVtcyA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICByZXZlcnNlZEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0QXQoaW5kZXhlc1tpXSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gYW4gYXJyYXkgYW5kIHJldHVybnMgaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMua2V5cygpKTtcbiAgICAgICAgICAgICAgICB2YXIgc2hpZnRBdCA9IGluZGV4ZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hpZnRBdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuJGl0ZW1zLmdldChzaGlmdEF0KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRkZWxldGVBdChzaGlmdEF0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgc2VjdGlvbiBvZiBhbiBhcnJheS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBzdGFydCBUaGUgYmVnaW5uaW5nIG9mIHRoZSBzcGVjaWZpZWQgcG9ydGlvbiBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gZW5kIFRoZSBlbmQgb2YgdGhlIHNwZWNpZmllZCBwb3J0aW9uIG9mIHRoZSBhcnJheS4gVGhpcyBpcyBleGNsdXNpdmUgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGluZGV4ICdlbmQnLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKEFycmF5U2NoZW1hLmJpbmQuYXBwbHkoQXJyYXlTY2hlbWEsIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLnNsaWNlKHN0YXJ0LCBlbmQpKSkpKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTb3J0cyBhbiBhcnJheS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBjb21wYXJlRm4gRnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgdGhlIG9yZGVyIG9mIHRoZSBlbGVtZW50cy4gSXQgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuXG4gICAgICAgICAgICAgKiBhIG5lZ2F0aXZlIHZhbHVlIGlmIGZpcnN0IGFyZ3VtZW50IGlzIGxlc3MgdGhhbiBzZWNvbmQgYXJndW1lbnQsIHplcm8gaWYgdGhleSdyZSBlcXVhbCBhbmQgYSBwb3NpdGl2ZVxuICAgICAgICAgICAgICogdmFsdWUgb3RoZXJ3aXNlLiBJZiBvbWl0dGVkLCB0aGUgZWxlbWVudHMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcsIEFTQ0lJIGNoYXJhY3RlciBvcmRlci5cbiAgICAgICAgICAgICAqIGBgYHRzXG4gICAgICAgICAgICAgKiBbMTEsMiwyMiwxXS5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIChjb21wYXJlRm4pIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlRm4gPT09IHZvaWQgMCkgeyBjb21wYXJlRm4gPSBERUZBVUxUX1NPUlQ7IH1cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhlcyA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMua2V5cygpKTtcbiAgICAgICAgICAgICAgICB2YXIgc29ydGVkSXRlbXMgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5zb3J0KGNvbXBhcmVGbik7XG4gICAgICAgICAgICAgICAgc29ydGVkSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRBdChpbmRleGVzW2ldLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBhbmQsIGlmIG5lY2Vzc2FyeSwgaW5zZXJ0cyBuZXcgZWxlbWVudHMgaW4gdGhlaXIgcGxhY2UsIHJldHVybmluZyB0aGUgZGVsZXRlZCBlbGVtZW50cy5cbiAgICAgICAgICAgICAqIEBwYXJhbSBzdGFydCBUaGUgemVyby1iYXNlZCBsb2NhdGlvbiBpbiB0aGUgYXJyYXkgZnJvbSB3aGljaCB0byBzdGFydCByZW1vdmluZyBlbGVtZW50cy5cbiAgICAgICAgICAgICAqIEBwYXJhbSBkZWxldGVDb3VudCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtcyBFbGVtZW50cyB0byBpbnNlcnQgaW50byB0aGUgYXJyYXkgaW4gcGxhY2Ugb2YgdGhlIGRlbGV0ZWQgZWxlbWVudHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUNvdW50ID09PSB2b2lkIDApIHsgZGVsZXRlQ291bnQgPSB0aGlzLmxlbmd0aCAtIHN0YXJ0OyB9XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmRleGVzID0gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy5rZXlzKCkpO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkSXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGRlbGV0ZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLnB1c2godGhpcy4kaXRlbXMuZ2V0KGluZGV4ZXNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZGVsZXRlQXQoaW5kZXhlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVkSXRlbXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbnNlcnRzIG5ldyBlbGVtZW50cyBhdCB0aGUgc3RhcnQgb2YgYW4gYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gaXRlbXMgIEVsZW1lbnRzIHRvIGluc2VydCBhdCB0aGUgc3RhcnQgb2YgdGhlIEFycmF5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgYWRkZWRMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgaW5kZXhlcyA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMua2V5cygpKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZXMgPSBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEF0KGksIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0QXQoYWRkZWRMZW5ndGggKyBpLCBwcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoICsgYWRkZWRMZW5ndGg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHZhbHVlIGluIGFuIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgVGhlIHZhbHVlIHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBhcnJheSBpbmRleCBhdCB3aGljaCB0byBiZWdpbiB0aGUgc2VhcmNoLiBJZiBmcm9tSW5kZXggaXMgb21pdHRlZCwgdGhlIHNlYXJjaCBzdGFydHMgYXQgaW5kZXggMC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLmluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYSBzcGVjaWZpZWQgdmFsdWUgaW4gYW4gYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBUaGUgdmFsdWUgdG8gbG9jYXRlIGluIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBmcm9tSW5kZXggVGhlIGFycmF5IGluZGV4IGF0IHdoaWNoIHRvIGJlZ2luIHRoZSBzZWFyY2guIElmIGZyb21JbmRleCBpcyBvbWl0dGVkLCB0aGUgc2VhcmNoIHN0YXJ0cyBhdCB0aGUgbGFzdCBpbmRleCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUluZGV4ID09PSB2b2lkIDApIHsgZnJvbUluZGV4ID0gdGhpcy5sZW5ndGggLSAxOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYWxsIHRoZSBtZW1iZXJzIG9mIGFuIGFycmF5IHNhdGlzZnkgdGhlIHNwZWNpZmllZCB0ZXN0LlxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrZm4gQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gdGhyZWUgYXJndW1lbnRzLiBUaGUgZXZlcnkgbWV0aG9kIGNhbGxzXG4gICAgICAgICAgICAgKiB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSB1bnRpbCB0aGUgY2FsbGJhY2tmbiByZXR1cm5zIGEgdmFsdWVcbiAgICAgICAgICAgICAqIHdoaWNoIGlzIGNvZXJjaWJsZSB0byB0aGUgQm9vbGVhbiB2YWx1ZSBmYWxzZSwgb3IgdW50aWwgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gdGhpc0FyZyBBbiBvYmplY3QgdG8gd2hpY2ggdGhlIHRoaXMga2V5d29yZCBjYW4gcmVmZXIgaW4gdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBJZiB0aGlzQXJnIGlzIG9taXR0ZWQsIHVuZGVmaW5lZCBpcyB1c2VkIGFzIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuZXZlcnkgPSBmdW5jdGlvbiAoY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5ldmVyeShjYWxsYmFja2ZuLCB0aGlzQXJnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBmb3IgYW55IGVsZW1lbnQgb2YgYW4gYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tmbiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byB0aHJlZSBhcmd1bWVudHMuIFRoZSBzb21lIG1ldGhvZCBjYWxsc1xuICAgICAgICAgICAgICogdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgdW50aWwgdGhlIGNhbGxiYWNrZm4gcmV0dXJucyBhIHZhbHVlXG4gICAgICAgICAgICAgKiB3aGljaCBpcyBjb2VyY2libGUgdG8gdGhlIEJvb2xlYW4gdmFsdWUgdHJ1ZSwgb3IgdW50aWwgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gdGhpc0FyZyBBbiBvYmplY3QgdG8gd2hpY2ggdGhlIHRoaXMga2V5d29yZCBjYW4gcmVmZXIgaW4gdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiBJZiB0aGlzQXJnIGlzIG9taXR0ZWQsIHVuZGVmaW5lZCBpcyB1c2VkIGFzIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLnNvbWUoY2FsbGJhY2tmbiwgdGhpc0FyZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQZXJmb3JtcyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmb3IgZWFjaCBlbGVtZW50IGluIGFuIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrZm4gIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIHRocmVlIGFyZ3VtZW50cy4gZm9yRWFjaCBjYWxscyB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbiBvbmUgdGltZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB0aGlzQXJnICBBbiBvYmplY3QgdG8gd2hpY2ggdGhlIHRoaXMga2V5d29yZCBjYW4gcmVmZXIgaW4gdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24uIElmIHRoaXNBcmcgaXMgb21pdHRlZCwgdW5kZWZpbmVkIGlzIHVzZWQgYXMgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbHMgYSBkZWZpbmVkIGNhbGxiYWNrIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheSwgYW5kIHJldHVybnMgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFja2ZuIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIHRocmVlIGFyZ3VtZW50cy4gVGhlIG1hcCBtZXRob2QgY2FsbHMgdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gb25lIHRpbWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gdGhpc0FyZyBBbiBvYmplY3QgdG8gd2hpY2ggdGhlIHRoaXMga2V5d29yZCBjYW4gcmVmZXIgaW4gdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24uIElmIHRoaXNBcmcgaXMgb21pdHRlZCwgdW5kZWZpbmVkIGlzIHVzZWQgYXMgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5tYXAoY2FsbGJhY2tmbiwgdGhpc0FyZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLmZpbHRlcihjYWxsYmFja2ZuLCB0aGlzQXJnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhbGxzIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGFsbCB0aGUgZWxlbWVudHMgaW4gYW4gYXJyYXkuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQsIGFuZCBpcyBwcm92aWRlZCBhcyBhbiBhcmd1bWVudCBpbiB0aGUgbmV4dCBjYWxsIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFja2ZuIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgYXJndW1lbnRzLiBUaGUgcmVkdWNlIG1ldGhvZCBjYWxscyB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbiBvbmUgdGltZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBpbml0aWFsVmFsdWUgSWYgaW5pdGlhbFZhbHVlIGlzIHNwZWNpZmllZCwgaXQgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSB0byBzdGFydCB0aGUgYWNjdW11bGF0aW9uLiBUaGUgZmlyc3QgY2FsbCB0byB0aGUgY2FsbGJhY2tmbiBmdW5jdGlvbiBwcm92aWRlcyB0aGlzIHZhbHVlIGFzIGFuIGFyZ3VtZW50IGluc3RlYWQgb2YgYW4gYXJyYXkgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2FsbGJhY2tmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLnJlZHVjZShjYWxsYmFja2ZuLCBpbml0aWFsVmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbHMgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgYWxsIHRoZSBlbGVtZW50cyBpbiBhbiBhcnJheSwgaW4gZGVzY2VuZGluZyBvcmRlci4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCwgYW5kIGlzIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50IGluIHRoZSBuZXh0IGNhbGwgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrZm4gQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciBhcmd1bWVudHMuIFRoZSByZWR1Y2VSaWdodCBtZXRob2QgY2FsbHMgdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gb25lIHRpbWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5pdGlhbFZhbHVlIElmIGluaXRpYWxWYWx1ZSBpcyBzcGVjaWZpZWQsIGl0IGlzIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgdG8gc3RhcnQgdGhlIGFjY3VtdWxhdGlvbi4gVGhlIGZpcnN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrZm4gZnVuY3Rpb24gcHJvdmlkZXMgdGhpcyB2YWx1ZSBhcyBhbiBhcmd1bWVudCBpbnN0ZWFkIG9mIGFuIGFycmF5IHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoY2FsbGJhY2tmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4sIGluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgd2hlcmUgcHJlZGljYXRlIGlzIHRydWUsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgICAgICAqIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBwcmVkaWNhdGUgZmluZCBjYWxscyBwcmVkaWNhdGUgb25jZSBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSwgaW4gYXNjZW5kaW5nXG4gICAgICAgICAgICAgKiBvcmRlciwgdW50aWwgaXQgZmluZHMgb25lIHdoZXJlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUuIElmIHN1Y2ggYW4gZWxlbWVudCBpcyBmb3VuZCwgZmluZFxuICAgICAgICAgICAgICogaW1tZWRpYXRlbHkgcmV0dXJucyB0aGF0IGVsZW1lbnQgdmFsdWUuIE90aGVyd2lzZSwgZmluZCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB0aGlzQXJnIElmIHByb3ZpZGVkLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIHRoaXMgdmFsdWUgZm9yIGVhY2ggaW52b2NhdGlvbiBvZlxuICAgICAgICAgICAgICogcHJlZGljYXRlLiBJZiBpdCBpcyBub3QgcHJvdmlkZWQsIHVuZGVmaW5lZCBpcyB1c2VkIGluc3RlYWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgd2hlcmUgcHJlZGljYXRlIGlzIHRydWUsIGFuZCAtMVxuICAgICAgICAgICAgICogb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICogQHBhcmFtIHByZWRpY2F0ZSBmaW5kIGNhbGxzIHByZWRpY2F0ZSBvbmNlIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5LCBpbiBhc2NlbmRpbmdcbiAgICAgICAgICAgICAqIG9yZGVyLCB1bnRpbCBpdCBmaW5kcyBvbmUgd2hlcmUgcHJlZGljYXRlIHJldHVybnMgdHJ1ZS4gSWYgc3VjaCBhbiBlbGVtZW50IGlzIGZvdW5kLFxuICAgICAgICAgICAgICogZmluZEluZGV4IGltbWVkaWF0ZWx5IHJldHVybnMgdGhhdCBlbGVtZW50IGluZGV4LiBPdGhlcndpc2UsIGZpbmRJbmRleCByZXR1cm5zIC0xLlxuICAgICAgICAgICAgICogQHBhcmFtIHRoaXNBcmcgSWYgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgdGhpcyB2YWx1ZSBmb3IgZWFjaCBpbnZvY2F0aW9uIG9mXG4gICAgICAgICAgICAgKiBwcmVkaWNhdGUuIElmIGl0IGlzIG5vdCBwcm92aWRlZCwgdW5kZWZpbmVkIGlzIHVzZWQgaW5zdGVhZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmZpbmRJbmRleCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy52YWx1ZXMoKSkuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSB0aGlzIG9iamVjdCBhZnRlciBmaWxsaW5nIHRoZSBzZWN0aW9uIGlkZW50aWZpZWQgYnkgc3RhcnQgYW5kIGVuZCB3aXRoIHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gZmlsbCBhcnJheSBzZWN0aW9uIHdpdGhcbiAgICAgICAgICAgICAqIEBwYXJhbSBzdGFydCBpbmRleCB0byBzdGFydCBmaWxsaW5nIHRoZSBhcnJheSBhdC4gSWYgc3RhcnQgaXMgbmVnYXRpdmUsIGl0IGlzIHRyZWF0ZWQgYXNcbiAgICAgICAgICAgICAqIGxlbmd0aCtzdGFydCB3aGVyZSBsZW5ndGggaXMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gZW5kIGluZGV4IHRvIHN0b3AgZmlsbGluZyB0aGUgYXJyYXkgYXQuIElmIGVuZCBpcyBuZWdhdGl2ZSwgaXQgaXMgdHJlYXRlZCBhc1xuICAgICAgICAgICAgICogbGVuZ3RoK2VuZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5U2NoZW1hI2ZpbGwoKSBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSB0aGlzIG9iamVjdCBhZnRlciBjb3B5aW5nIGEgc2VjdGlvbiBvZiB0aGUgYXJyYXkgaWRlbnRpZmllZCBieSBzdGFydCBhbmQgZW5kXG4gICAgICAgICAgICAgKiB0byB0aGUgc2FtZSBhcnJheSBzdGFydGluZyBhdCBwb3NpdGlvbiB0YXJnZXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB0YXJnZXQgSWYgdGFyZ2V0IGlzIG5lZ2F0aXZlLCBpdCBpcyB0cmVhdGVkIGFzIGxlbmd0aCt0YXJnZXQgd2hlcmUgbGVuZ3RoIGlzIHRoZVxuICAgICAgICAgICAgICogbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBzdGFydCBJZiBzdGFydCBpcyBuZWdhdGl2ZSwgaXQgaXMgdHJlYXRlZCBhcyBsZW5ndGgrc3RhcnQuIElmIGVuZCBpcyBuZWdhdGl2ZSwgaXRcbiAgICAgICAgICAgICAqIGlzIHRyZWF0ZWQgYXMgbGVuZ3RoK2VuZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSBlbmQgSWYgbm90IHNwZWNpZmllZCwgbGVuZ3RoIG9mIHRoZSB0aGlzIG9iamVjdCBpcyB1c2VkIGFzIGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuY29weVdpdGhpbiA9IGZ1bmN0aW9uICh0YXJnZXQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5U2NoZW1hI2NvcHlXaXRoaW4oKSBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGFycmF5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiRpdGVtcy50b1N0cmluZygpOyB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGFycmF5LiBUaGUgZWxlbWVudHMgYXJlIGNvbnZlcnRlZCB0byBzdHJpbmcgdXNpbmcgdGhlaXIgdG9Mb2NhbFN0cmluZyBtZXRob2RzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiRpdGVtcy50b0xvY2FsZVN0cmluZygpOyB9O1xuICAgICAgICAgICAgLyoqIEl0ZXJhdG9yICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy52YWx1ZXMoKSlbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZVtTeW1ib2wudW5zY29wYWJsZXNdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtc1tTeW1ib2wudW5zY29wYWJsZXNdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhYmxlIG9mIGtleSwgdmFsdWUgcGFpcnMgZm9yIGV2ZXJ5IGVudHJ5IGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJGl0ZW1zLmVudHJpZXMoKTsgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYWJsZSBvZiBrZXlzIGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuJGl0ZW1zLmtleXMoKTsgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYWJsZSBvZiB2YWx1ZXMgaW4gdGhlIGFycmF5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiRpdGVtcy52YWx1ZXMoKTsgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGFycmF5IGluY2x1ZGVzIGEgY2VydGFpbiBlbGVtZW50LCByZXR1cm5pbmcgdHJ1ZSBvciBmYWxzZSBhcyBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IFRoZSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAgICAgICAgICAgKiBAcGFyYW0gZnJvbUluZGV4IFRoZSBwb3NpdGlvbiBpbiB0aGlzIGFycmF5IGF0IHdoaWNoIHRvIGJlZ2luIHNlYXJjaGluZyBmb3Igc2VhcmNoRWxlbWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKS5pbmNsdWRlcyhzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbHMgYSBkZWZpbmVkIGNhbGxiYWNrIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheS4gVGhlbiwgZmxhdHRlbnMgdGhlIHJlc3VsdCBpbnRvXG4gICAgICAgICAgICAgKiBhIG5ldyBhcnJheS5cbiAgICAgICAgICAgICAqIFRoaXMgaXMgaWRlbnRpY2FsIHRvIGEgbWFwIGZvbGxvd2VkIGJ5IGZsYXQgd2l0aCBkZXB0aCAxLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byB0aHJlZSBhcmd1bWVudHMuIFRoZSBmbGF0TWFwIG1ldGhvZCBjYWxscyB0aGVcbiAgICAgICAgICAgICAqIGNhbGxiYWNrIGZ1bmN0aW9uIG9uZSB0aW1lIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuICAgICAgICAgICAgICogQHBhcmFtIHRoaXNBcmcgQW4gb2JqZWN0IHRvIHdoaWNoIHRoZSB0aGlzIGtleXdvcmQgY2FuIHJlZmVyIGluIHRoZSBjYWxsYmFjayBmdW5jdGlvbi4gSWZcbiAgICAgICAgICAgICAqIHRoaXNBcmcgaXMgb21pdHRlZCwgdW5kZWZpbmVkIGlzIHVzZWQgYXMgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5mbGF0TWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5U2NoZW1hI2ZsYXRNYXAoKSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCBhbGwgc3ViLWFycmF5IGVsZW1lbnRzIGNvbmNhdGVuYXRlZCBpbnRvIGl0IHJlY3Vyc2l2ZWx5IHVwIHRvIHRoZVxuICAgICAgICAgICAgICogc3BlY2lmaWVkIGRlcHRoLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmZsYXQgPSBmdW5jdGlvbiAoZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlTY2hlbWEjZmxhdCgpIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGdldCBzaXplICgpIHtcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gdGhpcy4kaXRlbXMuc2l6ZTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS5zZXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwga2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5zZXQoaW5kZXgsIGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuZ2V0QnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5nZXQodGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuZGVsZXRlQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLiRpbmRleGVzLmdldChpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEFycmF5U2NoZW1hLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mICh2YWx1ZVsndG9KU09OJ10pID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbHVlWyd0b0pTT04nXSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEZWNvZGluZyB1dGlsaXRpZXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBBcnJheVNjaGVtYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoaXNEZWNvZGluZykge1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkID0gbmV3IChBcnJheVNjaGVtYS5iaW5kLmFwcGx5KEFycmF5U2NoZW1hLCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKSkpKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkID0gbmV3IChBcnJheVNjaGVtYS5iaW5kLmFwcGx5KEFycmF5U2NoZW1hLCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gKChpdGVtWyckY2hhbmdlcyddKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpdGVtLmNsb25lKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbSk7IH0pKSkpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQXJyYXlTY2hlbWEucHJvdG90eXBlLnRyaWdnZXJBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS50cmlnZ2VyQWxsLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheVNjaGVtYTtcbiAgICAgICAgfSgpKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRNYXBQcm94eSh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWVbJyRwcm94eSddID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IFByb3h5KHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApICE9PSBcInN5bWJvbFwiICYmIC8vIGFjY2Vzc2luZyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgKG9ialtwcm9wXSkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmouZ2V0KHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAob2JqLCBwcm9wLCBzZXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSAhPT0gXCJzeW1ib2xcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHByb3AuaW5kZXhPZihcIiRcIikgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCAhPT0gXCJvbkFkZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCAhPT0gXCJvblJlbW92ZVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCAhPT0gXCJvbkNoYW5nZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNldChwcm9wLCBzZXRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiAob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5kZWxldGUocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgTWFwU2NoZW1hID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gTWFwU2NoZW1hKGluaXRpYWxWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMgPSBuZXcgQ2hhbmdlVHJlZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZklkID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFZhbHVlcyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBfdGhpcy5zZXQoaywgdik7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoaywgaW5pdGlhbFZhbHVlc1trXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBNYXBTY2hlbWEuaXMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlWydtYXAnXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qKiBJdGVyYXRvciAqL1xuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpOyB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFNjaGVtYS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy4kaXRlbXNbU3ltYm9sLnRvU3RyaW5nVGFnXTsgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hcFNjaGVtYSNzZXQoJ1wiICsga2V5ICsgXCInLCBcIiArIHZhbHVlICsgXCIpOiB0cnlpbmcgdG8gc2V0IFwiICsgdmFsdWUgKyBcIiB2YWx1ZSBvbiAnXCIgKyBrZXkgKyBcIicuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBnZXQgXCJpbmRleFwiIGZvciB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgICAgIHZhciBoYXNJbmRleCA9IHR5cGVvZiAodGhpcy4kY2hhbmdlcy5pbmRleGVzW2tleV0pICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IChoYXNJbmRleClcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLiRjaGFuZ2VzLmluZGV4ZXNba2V5XVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuJHJlZklkKys7XG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IChoYXNJbmRleClcbiAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRzLk9QRVJBVElPTi5SRVBMQUNFXG4gICAgICAgICAgICAgICAgICAgIDogZXhwb3J0cy5PUEVSQVRJT04uQUREO1xuICAgICAgICAgICAgICAgIHZhciBpc1JlZiA9ICh2YWx1ZVsnJGNoYW5nZXMnXSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbJyRjaGFuZ2VzJ10uc2V0UGFyZW50KHRoaXMsIHRoaXMuJGNoYW5nZXMucm9vdCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIChlbmNvZGluZylcbiAgICAgICAgICAgICAgICAvLyBzZXQgYSB1bmlxdWUgaWQgdG8gcmVsYXRlIGRpcmVjdGx5IHdpdGggdGhpcyBrZXkvdmFsdWUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoIWhhc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuaW5kZXhlc1trZXldID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuc2V0KGluZGV4LCBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlZiAmJiAvLyBpZiBpcyBzY2hlbWEsIGZvcmNlIEFERCBvcGVyYXRpb24gaWYgdmFsdWUgZGlmZmVyIGZyb20gcHJldmlvdXMgb25lLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5nZXQoa2V5KSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gZXhwb3J0cy5PUEVSQVRJT04uQUREO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5jaGFuZ2Uoa2V5LCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBNYXBTY2hlbWEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFkZCBhIFwicHVyZ2VcIiBtZXRob2QgYWZ0ZXIgLmVuY29kZSgpIHJ1bnMsIHRvIGNsZWFudXAgcmVtb3ZlZCBgJGluZGV4ZXNgXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCByZW1vdmUgJGluZGV4ZXMgdG8gYWxsb3cgc2V0dGluZyB0aGUgc2FtZSBrZXkgaW4gdGhlIHNhbWUgcGF0Y2hcbiAgICAgICAgICAgICAgICAvLyAoU2VlIFwic2hvdWxkIGFsbG93IHRvIHJlbW92ZSBhbmQgc2V0IGFuIGl0ZW0gaW4gdGhlIHNhbWUgcGxhY2VcIiB0ZXN0KVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gLy8gY29uc3QgaW5kZXggPSB0aGlzLiRjaGFuZ2VzLmluZGV4ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAvLyAvLyB0aGlzLiRpbmRleGVzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChpc0RlY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIHByZXZpb3VzIG9wZXJhdGlvbnMuXG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kaXNjYXJkKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuaW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIHByZXZpb3VzIGluZGV4ZXNcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgLy8gZmxhZyBjaGlsZCBpdGVtcyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChpc0RlY29kaW5nICYmIHR5cGVvZiAodGhpcy4kY2hhbmdlcy5nZXRUeXBlKCkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRjaGFuZ2VzLnJvb3QucmVtb3ZlUmVmKGl0ZW1bJyRjaGFuZ2VzJ10ucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgaXRlbXNcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMub3BlcmF0aW9uKHsgaW5kZXg6IDAsIG9wOiBleHBvcnRzLk9QRVJBVElPTi5DTEVBUiB9KTtcbiAgICAgICAgICAgICAgICAvLyB0b3VjaCBhbGwgc3RydWN0dXJlcyB1bnRpbCByZWFjaCByb290XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy50b3VjaFBhcmVudHMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBNYXBTY2hlbWEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuaGFzKGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrZm4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKGNhbGxiYWNrZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZW50cmllcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMua2V5cygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpdGVtcy52YWx1ZXMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwU2NoZW1hLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLnNpemU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZS5zZXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwga2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5zZXQoaW5kZXgsIGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpbmRleGVzLmdldChpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgTWFwU2NoZW1hLnByb3RvdHlwZS5nZXRCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmdldCh0aGlzLiRpbmRleGVzLmdldChpbmRleCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUuZGVsZXRlQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLiRpbmRleGVzLmdldChpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwW2tleV0gPSAodHlwZW9mICh2YWx1ZVsndG9KU09OJ10pID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbHVlWyd0b0pTT04nXSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERlY29kaW5nIHV0aWxpdGllc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoaXNEZWNvZGluZykge1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGVcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkID0gT2JqZWN0LmFzc2lnbihuZXcgTWFwU2NoZW1hKCksIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VydmVyLXNpZGVcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkID0gbmV3IE1hcFNjaGVtYSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZC5zZXQoa2V5LCB2YWx1ZVsnY2xvbmUnXSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1hcFNjaGVtYS5wcm90b3R5cGUudHJpZ2dlckFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLnRyaWdnZXJBbGwuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIE1hcFNjaGVtYTtcbiAgICAgICAgfSgpKTtcblxuICAgICAgICB2YXIgcmVnaXN0ZXJlZFR5cGVzID0ge307XG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyVHlwZShpZGVudGlmaWVyLCBkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICByZWdpc3RlcmVkVHlwZXNbaWRlbnRpZmllcl0gPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFR5cGUoaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRUeXBlc1tpZGVudGlmaWVyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBTY2hlbWFEZWZpbml0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gU2NoZW1hRGVmaW5pdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHVzZSBhIFwiZmllbGRcIiBzdHJ1Y3R1cmUgY29tYmluaW5nIGFsbCB0aGVzZSBwcm9wZXJ0aWVzIHBlci1maWVsZC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuZmllbGRzQnlJbmRleCA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwcmVjYXRlZCA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzY3JpcHRvcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNjaGVtYURlZmluaXRpb24uY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gbmV3IFNjaGVtYURlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IGluaGVyaXRhbmNlXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5zY2hlbWEgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQgJiYgcGFyZW50LnNjaGVtYSB8fCB7fSk7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5pbmRleGVzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50ICYmIHBhcmVudC5pbmRleGVzIHx8IHt9KTtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLmZpZWxkc0J5SW5kZXggPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQgJiYgcGFyZW50LmZpZWxkc0J5SW5kZXggfHwge30pO1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb24uZGVzY3JpcHRvcnMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQgJiYgcGFyZW50LmRlc2NyaXB0b3JzIHx8IHt9KTtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLmRlcHJlY2F0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQgJiYgcGFyZW50LmRlcHJlY2F0ZWQgfHwge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYURlZmluaXRpb24ucHJvdG90eXBlLmFkZEZpZWxkID0gZnVuY3Rpb24gKGZpZWxkLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXROZXh0RmllbGRJbmRleCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmllbGRzQnlJbmRleFtpbmRleF0gPSBmaWVsZDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbZmllbGRdID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlbWFbZmllbGRdID0gKEFycmF5LmlzQXJyYXkodHlwZSkpXG4gICAgICAgICAgICAgICAgICAgID8geyBhcnJheTogdHlwZVswXSB9XG4gICAgICAgICAgICAgICAgICAgIDogdHlwZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTY2hlbWFEZWZpbml0aW9uLnByb3RvdHlwZS5hZGRGaWx0ZXIgPSBmdW5jdGlvbiAoZmllbGQsIGNiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1dpdGhGaWx0ZXJzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyc1t0aGlzLmluZGV4ZXNbZmllbGRdXSA9IGNiO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1dpdGhGaWx0ZXJzLnB1c2godGhpcy5pbmRleGVzW2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hRGVmaW5pdGlvbi5wcm90b3R5cGUuYWRkQ2hpbGRyZW5GaWx0ZXIgPSBmdW5jdGlvbiAoZmllbGQsIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleGVzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuc2NoZW1hW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VHlwZShPYmplY3Qua2V5cyh0eXBlKVswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoaWxkRmlsdGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZEZpbHRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkRmlsdGVyc1tpbmRleF0gPSBjYjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAZmlsdGVyQ2hpbGRyZW46IGZpZWxkICdcIiArIGZpZWxkICsgXCInIGNhbid0IGhhdmUgY2hpbGRyZW4uIElnbm9yaW5nIGZpbHRlci5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYURlZmluaXRpb24ucHJvdG90eXBlLmdldENoaWxkcmVuRmlsdGVyID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRGaWx0ZXJzICYmIHRoaXMuY2hpbGRGaWx0ZXJzW3RoaXMuaW5kZXhlc1tmaWVsZF1dO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYURlZmluaXRpb24ucHJvdG90eXBlLmdldE5leHRGaWVsZEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNjaGVtYSB8fCB7fSkubGVuZ3RoO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBTY2hlbWFEZWZpbml0aW9uO1xuICAgICAgICB9KCkpO1xuICAgICAgICBmdW5jdGlvbiBoYXNGaWx0ZXIoa2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBrbGFzcy5fY29udGV4dCAmJiBrbGFzcy5fY29udGV4dC51c2VGaWx0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQ29udGV4dCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlbWFzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXNlRmlsdGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ29udGV4dC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjaGVtYXMuaGFzKHNjaGVtYSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ29udGV4dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHR5cGVpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGVzW3R5cGVpZF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ29udGV4dC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHNjaGVtYSwgdHlwZWlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVpZCA9PT0gdm9pZCAwKSB7IHR5cGVpZCA9IHRoaXMuc2NoZW1hcy5zaXplOyB9XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IG1vdmUgdGhpcyB0byBzb21ld2hlcmUgZWxzZT9cbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IGluaGVyaXRhbmNlXG4gICAgICAgICAgICAgICAgc2NoZW1hLl9kZWZpbml0aW9uID0gU2NoZW1hRGVmaW5pdGlvbi5jcmVhdGUoc2NoZW1hLl9kZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICBzY2hlbWEuX3R5cGVpZCA9IHR5cGVpZDtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVzW3R5cGVpZF0gPSBzY2hlbWE7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlbWFzLnNldChzY2hlbWEsIHR5cGVpZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ29udGV4dC5jcmVhdGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG5ldyBDb250ZXh0OyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlKGRlZmluaXRpb24sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIENvbnRleHQ7XG4gICAgICAgIH0oKSk7XG4gICAgICAgIHZhciBnbG9iYWxDb250ZXh0ID0gbmV3IENvbnRleHQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBAdHlwZSgpYCBkZWNvcmF0b3IgZm9yIHByb3hpZXNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHR5cGUodHlwZSwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gZ2xvYmFsQ29udGV4dDsgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHN0YXRpYyBzY2hlbWFcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuaGFzKGNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFkZChjb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gY29uc3RydWN0b3IuX2RlZmluaXRpb247XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5hZGRGaWVsZChmaWVsZCwgdHlwZSk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogc2tpcCBpZiBkZXNjcmlwdG9yIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIGZpZWxkIChgQGRlcHJlY2F0ZWQoKWApXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uZGVzY3JpcHRvcnNbZmllbGRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmRlcHJlY2F0ZWRbZmllbGRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgY3JlYXRlIGFjY2Vzc29ycyBmb3IgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5aW5nIHRvIGRlZmluZSBzYW1lIHByb3BlcnR5IG11bHRpcGxlIHRpbWVzIGFjcm9zcyBpbmhlcml0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2x5c2V1cy9jb2x5c2V1cy11bml0eTNkL2lzc3Vlcy8xMzEjaXNzdWVjb21tZW50LTgxNDMwODU3MlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAY29seXNldXMvc2NoZW1hOiBEdXBsaWNhdGUgJ1wiICsgZmllbGQgKyBcIicgZGVmaW5pdGlvbiBvbiAnXCIgKyBjb25zdHJ1Y3Rvci5uYW1lICsgXCInLlxcbkNoZWNrIEB0eXBlKCkgYW5ub3RhdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb25BdExpbmUgPSBlLnN0YWNrLnNwbGl0KFwiXFxuXCIpWzRdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZS5tZXNzYWdlICsgXCIgXCIgKyBkZWZpbml0aW9uQXRMaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5U2NoZW1hLmlzKHR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBpc01hcCA9ICFpc0FycmF5ICYmIE1hcFNjaGVtYS5pcyh0eXBlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciBtZS5cbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBhYnN0cmFjdCBpbnRlcm1lZGlhcnkgY2xhc3NlcyB3aXRoIG5vIGZpZWxkcyB0byBiZSBzZXJpYWxpemVkXG4gICAgICAgICAgICAgICAgLy8gKFNlZSBcInNob3VsZCBzdXBwb3J0IGFuIGluaGVyaXRhbmNlIHdpdGggYSBTY2hlbWEgdHlwZSB3aXRob3V0IGZpZWxkc1wiIHRlc3QpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodHlwZSkgIT09IFwic3RyaW5nXCIgJiYgIVNjaGVtYS5pcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRUeXBlID0gT2JqZWN0LnZhbHVlcyh0eXBlKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2hpbGRUeXBlKSAhPT0gXCJzdHJpbmdcIiAmJiAhY29udGV4dC5oYXMoY2hpbGRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hZGQoY2hpbGRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZmllbGRDYWNoZWQgPSBcIl9cIiArIGZpZWxkO1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb24uZGVzY3JpcHRvcnNbZmllbGRDYWNoZWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLmRlc2NyaXB0b3JzW2ZpZWxkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tmaWVsZENhY2hlZF07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIENyZWF0ZSBQcm94eSBmb3IgYXJyYXkgb3IgbWFwIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgdmFsdWUgaXMgdGhlIHNhbWUgYXMgY2FjaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzW2ZpZWxkQ2FjaGVkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx0eSB0cmFuc2Zvcm0gQXJyYXkgaW50byBBcnJheVNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5ICYmICEodmFsdWUgaW5zdGFuY2VvZiBBcnJheVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgKEFycmF5U2NoZW1hLmJpbmQuYXBwbHkoQXJyYXlTY2hlbWEsIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIHZhbHVlKSkpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHR5IHRyYW5zZm9ybSBNYXAgaW50byBNYXBTY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE1hcFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgTWFwU2NoZW1hKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHR1cm4gcHJvdmlkZWQgc3RydWN0dXJlIGludG8gYSBQcm94eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJHByb3h5J10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0TWFwUHJveHkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0QXJyYXlQcm94eSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmxhZyB0aGUgY2hhbmdlIGZvciBlbmNvZGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmNoYW5nZShmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHNldFBhcmVudCgpIHJlY3Vyc2l2ZWx5IGZvciB0aGlzIGFuZCBpdHMgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJ1Y3R1cmVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWyckY2hhbmdlcyddLnNldFBhcmVudCh0aGlzLCB0aGlzLiRjaGFuZ2VzLnJvb3QsIHRoaXMuX2RlZmluaXRpb24uaW5kZXhlc1tmaWVsZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyBhIGZpZWxkIHRvIGBudWxsYCBvciBgdW5kZWZpbmVkYCB3aWxsIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuZGVsZXRlKGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGRDYWNoZWRdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgQGZpbHRlcigpYCBkZWNvcmF0b3IgZm9yIGRlZmluaW5nIGRhdGEgZmlsdGVycyBwZXIgY2xpZW50XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBmaWx0ZXIoY2IpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBmaWVsZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yLl9kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmFkZEZpbHRlcihmaWVsZCwgY2IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLl9jb250ZXh0LnVzZUZpbHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmlsdGVyQ2hpbGRyZW4oY2IpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBmaWVsZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB2YXIgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yLl9kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmFkZENoaWxkcmVuRmlsdGVyKGZpZWxkLCBjYikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IuX2NvbnRleHQudXNlRmlsdGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogYEBkZXByZWNhdGVkKClgIGZsYWcgYSBmaWVsZCBhcyBkZXByZWNhdGVkLlxuICAgICAgICAgKiBUaGUgcHJldmlvdXMgYEB0eXBlKClgIGFubm90YXRpb24gc2hvdWxkIHJlbWFpbiBhbG9uZyB3aXRoIHRoaXMgb25lLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVwcmVjYXRlZCh0aHJvd3MsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0aHJvd3MgPT09IHZvaWQgMCkgeyB0aHJvd3MgPSB0cnVlOyB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgZmllbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uc3RydWN0b3IgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmluaXRpb24gPSBjb25zdHJ1Y3Rvci5fZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uLmRlcHJlY2F0ZWRbZmllbGRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhyb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24uZGVzY3JpcHRvcnNbZmllbGRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihmaWVsZCArIFwiIGlzIGRlcHJlY2F0ZWQuXCIpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWZpbmVUeXBlcyh0YXJnZXQsIGZpZWxkcywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gdGFyZ2V0Ll9jb250ZXh0IHx8IGdsb2JhbENvbnRleHQ7IH1cbiAgICAgICAgICAgIGZvciAodmFyIGZpZWxkIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIHR5cGUoZmllbGRzW2ZpZWxkXSwgY29udGV4dCkodGFyZ2V0LnByb3RvdHlwZSwgZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTggRW5kZWwgRHJleWVyXG4gICAgICAgICAqIENvcHlyaWdodCAoYykgMjAxNCBJb24gRHJpdmUgU29mdHdhcmUgTHRkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgICAgICogU09GVFdBUkVcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtc2dwYWNrIGltcGxlbWVudGF0aW9uIGhpZ2hseSBiYXNlZCBvbiBub3RlcGFjay5pb1xuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZGFycmFjaGVxdWVzbmUvbm90ZXBhY2tcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHV0ZjhMZW5ndGgoc3RyKSB7XG4gICAgICAgICAgICB2YXIgYyA9IDAsIGxlbmd0aCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGUwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXRmOFdyaXRlKHZpZXcsIG9mZnNldCwgc3RyKSB7XG4gICAgICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdbb2Zmc2V0KytdID0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdbb2Zmc2V0KytdID0gMHhjMCB8IChjID4+IDYpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3W29mZnNldCsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdbb2Zmc2V0KytdID0gMHhlMCB8IChjID4+IDEyKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld1tvZmZzZXQrK10gPSAweDgwIHwgKGMgPj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3W29mZnNldCsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoKGMgJiAweDNmZikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KGkpICYgMHgzZmYpKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld1tvZmZzZXQrK10gPSAweGYwIHwgKGMgPj4gMTgpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3W29mZnNldCsrXSA9IDB4ODAgfCAoYyA+PiAxMiAmIDB4M2YpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3W29mZnNldCsrXSA9IDB4ODAgfCAoYyA+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdbb2Zmc2V0KytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGludDgkMShieXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2godmFsdWUgJiAyNTUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVpbnQ4JDEoYnl0ZXMsIHZhbHVlKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKHZhbHVlICYgMjU1KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnQxNiQxKGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDI1NSk7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCh2YWx1ZSA+PiA4KSAmIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdWludDE2JDEoYnl0ZXMsIHZhbHVlKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKHZhbHVlICYgMjU1KTtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goKHZhbHVlID4+IDgpICYgMjU1KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnQzMiQxKGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDI1NSk7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCh2YWx1ZSA+PiA4KSAmIDI1NSk7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCh2YWx1ZSA+PiAxNikgJiAyNTUpO1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgodmFsdWUgPj4gMjQpICYgMjU1KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1aW50MzIkMShieXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBiNCA9IHZhbHVlID4+IDI0O1xuICAgICAgICAgICAgdmFyIGIzID0gdmFsdWUgPj4gMTY7XG4gICAgICAgICAgICB2YXIgYjIgPSB2YWx1ZSA+PiA4O1xuICAgICAgICAgICAgdmFyIGIxID0gdmFsdWU7XG4gICAgICAgICAgICBieXRlcy5wdXNoKGIxICYgMjU1KTtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goYjIgJiAyNTUpO1xuICAgICAgICAgICAgYnl0ZXMucHVzaChiMyAmIDI1NSk7XG4gICAgICAgICAgICBieXRlcy5wdXNoKGI0ICYgMjU1KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnQ2NCQxKGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGhpZ2ggPSBNYXRoLmZsb29yKHZhbHVlIC8gTWF0aC5wb3coMiwgMzIpKTtcbiAgICAgICAgICAgIHZhciBsb3cgPSB2YWx1ZSA+Pj4gMDtcbiAgICAgICAgICAgIHVpbnQzMiQxKGJ5dGVzLCBsb3cpO1xuICAgICAgICAgICAgdWludDMyJDEoYnl0ZXMsIGhpZ2gpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVpbnQ2NCQxKGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGhpZ2ggPSAodmFsdWUgLyBNYXRoLnBvdygyLCAzMikpID4+IDA7XG4gICAgICAgICAgICB2YXIgbG93ID0gdmFsdWUgPj4+IDA7XG4gICAgICAgICAgICB1aW50MzIkMShieXRlcywgbG93KTtcbiAgICAgICAgICAgIHVpbnQzMiQxKGJ5dGVzLCBoaWdoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmbG9hdDMyJDEoYnl0ZXMsIHZhbHVlKSB7XG4gICAgICAgICAgICB3cml0ZUZsb2F0MzIoYnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmbG9hdDY0JDEoYnl0ZXMsIHZhbHVlKSB7XG4gICAgICAgICAgICB3cml0ZUZsb2F0NjQoYnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2ludDMyJDEgPSBuZXcgSW50MzJBcnJheSgyKTtcbiAgICAgICAgdmFyIF9mbG9hdDMyJDEgPSBuZXcgRmxvYXQzMkFycmF5KF9pbnQzMiQxLmJ1ZmZlcik7XG4gICAgICAgIHZhciBfZmxvYXQ2NCQxID0gbmV3IEZsb2F0NjRBcnJheShfaW50MzIkMS5idWZmZXIpO1xuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0MzIoYnl0ZXMsIHZhbHVlKSB7XG4gICAgICAgICAgICBfZmxvYXQzMiQxWzBdID0gdmFsdWU7XG4gICAgICAgICAgICBpbnQzMiQxKGJ5dGVzLCBfaW50MzIkMVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdDY0KGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgX2Zsb2F0NjQkMVswXSA9IHZhbHVlO1xuICAgICAgICAgICAgaW50MzIkMShieXRlcywgX2ludDMyJDFbMCBdKTtcbiAgICAgICAgICAgIGludDMyJDEoYnl0ZXMsIF9pbnQzMiQxWzEgXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYm9vbGVhbiQxKGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVpbnQ4JDEoYnl0ZXMsIHZhbHVlID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZyQxKGJ5dGVzLCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gZW5jb2RlIGBudWxsYCBzdHJpbmdzIGFzIGVtcHR5LlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB1dGY4TGVuZ3RoKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciBzaXplID0gMDtcbiAgICAgICAgICAgIC8vIGZpeHN0clxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDB4MjApIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKGxlbmd0aCB8IDB4YTApO1xuICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RyIDhcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGQ5KTtcbiAgICAgICAgICAgICAgICB1aW50OCQxKGJ5dGVzLCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIHNpemUgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RyIDE2XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGRhKTtcbiAgICAgICAgICAgICAgICB1aW50MTYkMShieXRlcywgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzaXplID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0ciAzMlxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZGIpO1xuICAgICAgICAgICAgICAgIHVpbnQzMiQxKGJ5dGVzLCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIHNpemUgPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdG9vIGxvbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0ZjhXcml0ZShieXRlcywgYnl0ZXMubGVuZ3RoLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSArIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBudW1iZXIkMShieXRlcywgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyJDEoYnl0ZXMsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIkMShieXRlcywgKHZhbHVlID4gMCkgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IC1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gKHZhbHVlIHwgMCkpIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4Y2IpO1xuICAgICAgICAgICAgICAgIHdyaXRlRmxvYXQ2NChieXRlcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGVuY29kZSBmbG9hdCAzMj9cbiAgICAgICAgICAgICAgICAvLyBpcyBpdCBwb3NzaWJsZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gZmxvYXQzMiAvIGZsb2F0NjQgaGVyZT9cbiAgICAgICAgICAgICAgICAvLyAvLyBmbG9hdCAzMlxuICAgICAgICAgICAgICAgIC8vIGJ5dGVzLnB1c2goMHhjYSk7XG4gICAgICAgICAgICAgICAgLy8gd3JpdGVGbG9hdDMyKGJ5dGVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHBvc2l0aXZlIGZpeG51bVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgdWludDgkMShieXRlcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCA4XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGNjKTtcbiAgICAgICAgICAgICAgICAgICAgdWludDgkMShieXRlcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCAxNlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweGNkKTtcbiAgICAgICAgICAgICAgICAgICAgdWludDE2JDEoYnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgMzJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4Y2UpO1xuICAgICAgICAgICAgICAgICAgICB1aW50MzIkMShieXRlcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCA2NFxuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhjZik7XG4gICAgICAgICAgICAgICAgdWludDY0JDEoYnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5lZ2F0aXZlIGZpeG51bVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAtMHgyMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZTAgfCAodmFsdWUgKyAweDIwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnQgOFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZDApO1xuICAgICAgICAgICAgICAgICAgICBpbnQ4JDEoYnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludCAxNlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhkMSk7XG4gICAgICAgICAgICAgICAgICAgIGludDE2JDEoYnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludCAzMlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZDIpO1xuICAgICAgICAgICAgICAgICAgICBpbnQzMiQxKGJ5dGVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnQgNjRcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4ZDMpO1xuICAgICAgICAgICAgICAgIGludDY0JDEoYnl0ZXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmNvZGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgICAgICB1dGY4V3JpdGU6IHV0ZjhXcml0ZSxcbiAgICAgICAgICAgIGludDg6IGludDgkMSxcbiAgICAgICAgICAgIHVpbnQ4OiB1aW50OCQxLFxuICAgICAgICAgICAgaW50MTY6IGludDE2JDEsXG4gICAgICAgICAgICB1aW50MTY6IHVpbnQxNiQxLFxuICAgICAgICAgICAgaW50MzI6IGludDMyJDEsXG4gICAgICAgICAgICB1aW50MzI6IHVpbnQzMiQxLFxuICAgICAgICAgICAgaW50NjQ6IGludDY0JDEsXG4gICAgICAgICAgICB1aW50NjQ6IHVpbnQ2NCQxLFxuICAgICAgICAgICAgZmxvYXQzMjogZmxvYXQzMiQxLFxuICAgICAgICAgICAgZmxvYXQ2NDogZmxvYXQ2NCQxLFxuICAgICAgICAgICAgd3JpdGVGbG9hdDMyOiB3cml0ZUZsb2F0MzIsXG4gICAgICAgICAgICB3cml0ZUZsb2F0NjQ6IHdyaXRlRmxvYXQ2NCxcbiAgICAgICAgICAgIGJvb2xlYW46IGJvb2xlYW4kMSxcbiAgICAgICAgICAgIHN0cmluZzogc3RyaW5nJDEsXG4gICAgICAgICAgICBudW1iZXI6IG51bWJlciQxXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMTggRW5kZWwgRHJleWVyXG4gICAgICAgICAqIENvcHlyaWdodCAoYykgMjAxNCBJb24gRHJpdmUgU29mdHdhcmUgTHRkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgICAgICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICAgICAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgICAgICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICAgICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgICAgICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICAgICAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgICAgICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICAgICAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgICAgICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICAgICAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICAgICAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICAgICAgICogU09GVFdBUkVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHV0ZjhSZWFkKGJ5dGVzLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9ICcnLCBjaHIgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZSA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICgoYnl0ZSAmIDB4ODApID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChieXRlICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlICYgMHgxZikgPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ5dGVzWysraV0gJiAweDNmKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGJ5dGUgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGUgJiAweDBmKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKChieXRlc1srK2ldICYgMHgzZikgPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKChieXRlc1srK2ldICYgMHgzZikgPDwgMCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChieXRlICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hyID0gKChieXRlICYgMHgwNykgPDwgMTgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICgoYnl0ZXNbKytpXSAmIDB4M2YpIDw8IDEyKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoKGJ5dGVzWysraV0gJiAweDNmKSA8PCA2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoKGJ5dGVzWysraV0gJiAweDNmKSA8PCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNociA+PSAweDAxMDAwMCkgeyAvLyBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hyIC09IDB4MDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNociA+Pj4gMTApICsgMHhEODAwLCAoY2hyICYgMHgzRkYpICsgMHhEQzAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgYnl0ZSAnICsgYnl0ZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgIC8vIChkbyBub3QgdGhyb3cgZXJyb3IgdG8gYXZvaWQgc2VydmVyL2NsaWVudCBmcm9tIGNyYXNoaW5nIGR1ZSB0byBoYWNrIGF0dGVtcHMpXG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgJyArIGJ5dGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW50OChieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB1aW50OChieXRlcywgaXQpIDw8IDI0ID4+IDI0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVpbnQ4KGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzW2l0Lm9mZnNldCsrXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnQxNihieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB1aW50MTYoYnl0ZXMsIGl0KSA8PCAxNiA+PiAxNjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1aW50MTYoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNbaXQub2Zmc2V0KytdIHwgYnl0ZXNbaXQub2Zmc2V0KytdIDw8IDg7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW50MzIoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNbaXQub2Zmc2V0KytdIHwgYnl0ZXNbaXQub2Zmc2V0KytdIDw8IDggfCBieXRlc1tpdC5vZmZzZXQrK10gPDwgMTYgfCBieXRlc1tpdC5vZmZzZXQrK10gPDwgMjQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdWludDMyKGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludDMyKGJ5dGVzLCBpdCkgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxvYXQzMihieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRmxvYXQzMihieXRlcywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsb2F0NjQoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZsb2F0NjQoYnl0ZXMsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnQ2NChieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHZhciBsb3cgPSB1aW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIHZhciBoaWdoID0gaW50MzIoYnl0ZXMsIGl0KSAqIE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICAgIHJldHVybiBoaWdoICsgbG93O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVpbnQ2NChieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHZhciBsb3cgPSB1aW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIHZhciBoaWdoID0gdWludDMyKGJ5dGVzLCBpdCkgKiBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICByZXR1cm4gaGlnaCArIGxvdztcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2ludDMyID0gbmV3IEludDMyQXJyYXkoMik7XG4gICAgICAgIHZhciBfZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoX2ludDMyLmJ1ZmZlcik7XG4gICAgICAgIHZhciBfZmxvYXQ2NCA9IG5ldyBGbG9hdDY0QXJyYXkoX2ludDMyLmJ1ZmZlcik7XG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdDMyKGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgX2ludDMyWzBdID0gaW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIHJldHVybiBfZmxvYXQzMlswXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXQ2NChieXRlcywgaXQpIHtcbiAgICAgICAgICAgIF9pbnQzMlswIF0gPSBpbnQzMihieXRlcywgaXQpO1xuICAgICAgICAgICAgX2ludDMyWzEgXSA9IGludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICByZXR1cm4gX2Zsb2F0NjRbMF07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYm9vbGVhbihieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB1aW50OChieXRlcywgaXQpID4gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdHJpbmcoYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gYnl0ZXNbaXQub2Zmc2V0KytdO1xuICAgICAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwcmVmaXggPCAweGMwKSB7XG4gICAgICAgICAgICAgICAgLy8gZml4c3RyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcHJlZml4ICYgMHgxZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhkOSkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHVpbnQ4KGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4ZGEpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB1aW50MTYoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhkYikge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHVpbnQzMihieXRlcywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdXRmOFJlYWQoYnl0ZXMsIGl0Lm9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGl0Lm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RyaW5nQ2hlY2soYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gYnl0ZXNbaXQub2Zmc2V0XTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyBmaXhzdHJcbiAgICAgICAgICAgIChwcmVmaXggPCAweGMwICYmIHByZWZpeCA+IDB4YTApIHx8XG4gICAgICAgICAgICAgICAgLy8gc3RyIDhcbiAgICAgICAgICAgICAgICBwcmVmaXggPT09IDB4ZDkgfHxcbiAgICAgICAgICAgICAgICAvLyBzdHIgMTZcbiAgICAgICAgICAgICAgICBwcmVmaXggPT09IDB4ZGEgfHxcbiAgICAgICAgICAgICAgICAvLyBzdHIgMzJcbiAgICAgICAgICAgICAgICBwcmVmaXggPT09IDB4ZGIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG51bWJlcihieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBieXRlc1tpdC5vZmZzZXQrK107XG4gICAgICAgICAgICBpZiAocHJlZml4IDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIC8vIHBvc2l0aXZlIGZpeGludFxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4Y2EpIHtcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCAzMlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkRmxvYXQzMihieXRlcywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGNiKSB7XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgNjRcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZEZsb2F0NjQoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhjYykge1xuICAgICAgICAgICAgICAgIC8vIHVpbnQgOFxuICAgICAgICAgICAgICAgIHJldHVybiB1aW50OChieXRlcywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGNkKSB7XG4gICAgICAgICAgICAgICAgLy8gdWludCAxNlxuICAgICAgICAgICAgICAgIHJldHVybiB1aW50MTYoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhjZSkge1xuICAgICAgICAgICAgICAgIC8vIHVpbnQgMzJcbiAgICAgICAgICAgICAgICByZXR1cm4gdWludDMyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4Y2YpIHtcbiAgICAgICAgICAgICAgICAvLyB1aW50IDY0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVpbnQ2NChieXRlcywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGQwKSB7XG4gICAgICAgICAgICAgICAgLy8gaW50IDhcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50OChieXRlcywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAweGQxKSB7XG4gICAgICAgICAgICAgICAgLy8gaW50IDE2XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludDE2KGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmaXggPT09IDB4ZDIpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnQgMzJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50MzIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gMHhkMykge1xuICAgICAgICAgICAgICAgIC8vIGludCA2NFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnQ2NChieXRlcywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlZml4ID4gMHhkZikge1xuICAgICAgICAgICAgICAgIC8vIG5lZ2F0aXZlIGZpeGludFxuICAgICAgICAgICAgICAgIHJldHVybiAoMHhmZiAtIHByZWZpeCArIDEpICogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbnVtYmVyQ2hlY2soYnl0ZXMsIGl0KSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gYnl0ZXNbaXQub2Zmc2V0XTtcbiAgICAgICAgICAgIC8vIHBvc2l0aXZlIGZpeGludCAtIDB4MDAgLSAweDdmXG4gICAgICAgICAgICAvLyBmbG9hdCAzMiAgICAgICAgLSAweGNhXG4gICAgICAgICAgICAvLyBmbG9hdCA2NCAgICAgICAgLSAweGNiXG4gICAgICAgICAgICAvLyB1aW50IDggICAgICAgICAgLSAweGNjXG4gICAgICAgICAgICAvLyB1aW50IDE2ICAgICAgICAgLSAweGNkXG4gICAgICAgICAgICAvLyB1aW50IDMyICAgICAgICAgLSAweGNlXG4gICAgICAgICAgICAvLyB1aW50IDY0ICAgICAgICAgLSAweGNmXG4gICAgICAgICAgICAvLyBpbnQgOCAgICAgICAgICAgLSAweGQwXG4gICAgICAgICAgICAvLyBpbnQgMTYgICAgICAgICAgLSAweGQxXG4gICAgICAgICAgICAvLyBpbnQgMzIgICAgICAgICAgLSAweGQyXG4gICAgICAgICAgICAvLyBpbnQgNjQgICAgICAgICAgLSAweGQzXG4gICAgICAgICAgICByZXR1cm4gKHByZWZpeCA8IDB4ODAgfHxcbiAgICAgICAgICAgICAgICAocHJlZml4ID49IDB4Y2EgJiYgcHJlZml4IDw9IDB4ZDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnJheUNoZWNrKGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzW2l0Lm9mZnNldF0gPCAweGEwO1xuICAgICAgICAgICAgLy8gY29uc3QgcHJlZml4ID0gYnl0ZXNbaXQub2Zmc2V0XSA7XG4gICAgICAgICAgICAvLyBpZiAocHJlZml4IDwgMHhhMCkge1xuICAgICAgICAgICAgLy8gICByZXR1cm4gcHJlZml4O1xuICAgICAgICAgICAgLy8gLy8gYXJyYXlcbiAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAocHJlZml4ID09PSAweGRjKSB7XG4gICAgICAgICAgICAvLyAgIGl0Lm9mZnNldCArPSAyO1xuICAgICAgICAgICAgLy8gfSBlbHNlIGlmICgweGRkKSB7XG4gICAgICAgICAgICAvLyAgIGl0Lm9mZnNldCArPSA0O1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gcmV0dXJuIHByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzd2l0Y2hTdHJ1Y3R1cmVDaGVjayhieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyBwcmV2aW91cyBieXRlIHNob3VsZCBiZSBgU1dJVENIX1RPX1NUUlVDVFVSRWBcbiAgICAgICAgICAgIGJ5dGVzW2l0Lm9mZnNldCAtIDFdID09PSBTV0lUQ0hfVE9fU1RSVUNUVVJFICYmXG4gICAgICAgICAgICAgICAgLy8gbmV4dCBieXRlIHNob3VsZCBiZSBhIG51bWJlclxuICAgICAgICAgICAgICAgIChieXRlc1tpdC5vZmZzZXRdIDwgMHg4MCB8fCAoYnl0ZXNbaXQub2Zmc2V0XSA+PSAweGNhICYmIGJ5dGVzW2l0Lm9mZnNldF0gPD0gMHhkMykpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWNvZGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgICAgICBpbnQ4OiBpbnQ4LFxuICAgICAgICAgICAgdWludDg6IHVpbnQ4LFxuICAgICAgICAgICAgaW50MTY6IGludDE2LFxuICAgICAgICAgICAgdWludDE2OiB1aW50MTYsXG4gICAgICAgICAgICBpbnQzMjogaW50MzIsXG4gICAgICAgICAgICB1aW50MzI6IHVpbnQzMixcbiAgICAgICAgICAgIGZsb2F0MzI6IGZsb2F0MzIsXG4gICAgICAgICAgICBmbG9hdDY0OiBmbG9hdDY0LFxuICAgICAgICAgICAgaW50NjQ6IGludDY0LFxuICAgICAgICAgICAgdWludDY0OiB1aW50NjQsXG4gICAgICAgICAgICByZWFkRmxvYXQzMjogcmVhZEZsb2F0MzIsXG4gICAgICAgICAgICByZWFkRmxvYXQ2NDogcmVhZEZsb2F0NjQsXG4gICAgICAgICAgICBib29sZWFuOiBib29sZWFuLFxuICAgICAgICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICAgICAgICBzdHJpbmdDaGVjazogc3RyaW5nQ2hlY2ssXG4gICAgICAgICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgICAgICAgIG51bWJlckNoZWNrOiBudW1iZXJDaGVjayxcbiAgICAgICAgICAgIGFycmF5Q2hlY2s6IGFycmF5Q2hlY2ssXG4gICAgICAgICAgICBzd2l0Y2hTdHJ1Y3R1cmVDaGVjazogc3dpdGNoU3RydWN0dXJlQ2hlY2tcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIENvbGxlY3Rpb25TY2hlbWEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBDb2xsZWN0aW9uU2NoZW1hKGluaXRpYWxWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMgPSBuZXcgQ2hhbmdlVHJlZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZklkID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLmFkZCh2KTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ29sbGVjdGlvblNjaGVtYS5pcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVbJ2NvbGxlY3Rpb24nXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHNldCBcImluZGV4XCIgZm9yIHJlZmVyZW5jZS5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLiRyZWZJZCsrO1xuICAgICAgICAgICAgICAgIHZhciBpc1JlZiA9ICh2YWx1ZVsnJGNoYW5nZXMnXSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbJyRjaGFuZ2VzJ10uc2V0UGFyZW50KHRoaXMsIHRoaXMuJGNoYW5nZXMucm9vdCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmluZGV4ZXNbaW5kZXhdID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5zZXQoaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmNoYW5nZShpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMua2V5cygpKVtpbmRleF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmdldChrZXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmVudHJpZXMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDb2xsZWN0aW9uU2NoZW1hLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy4kaXRlbXMuZW50cmllcygpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cmllcy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSBlbnRyeS52YWx1ZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBlbnRyeS52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDb2xsZWN0aW9uU2NoZW1hLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChpc0RlY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIHByZXZpb3VzIG9wZXJhdGlvbnMuXG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kaXNjYXJkKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuaW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIHByZXZpb3VzIGluZGV4ZXNcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgLy8gZmxhZyBjaGlsZCBpdGVtcyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChpc0RlY29kaW5nICYmIHR5cGVvZiAodGhpcy4kY2hhbmdlcy5nZXRUeXBlKCkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRjaGFuZ2VzLnJvb3QucmVtb3ZlUmVmKGl0ZW1bJyRjaGFuZ2VzJ10ucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgaXRlbXNcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMub3BlcmF0aW9uKHsgaW5kZXg6IDAsIG9wOiBleHBvcnRzLk9QRVJBVElPTi5DTEVBUiB9KTtcbiAgICAgICAgICAgICAgICAvLyB0b3VjaCBhbGwgc3RydWN0dXJlcyB1bnRpbCByZWFjaCByb290XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy50b3VjaFBhcmVudHMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDb2xsZWN0aW9uU2NoZW1hLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiRpdGVtcy52YWx1ZXMoKSkuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gdiA9PT0gdmFsdWU7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2tmbikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSwgXykgeyByZXR1cm4gY2FsbGJhY2tmbih2YWx1ZSwga2V5LCBfdGhpcyk7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMudmFsdWVzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuc2l6ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBDb2xsZWN0aW9uU2NoZW1hLnByb3RvdHlwZS5zZXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwga2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5zZXQoaW5kZXgsIGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ29sbGVjdGlvblNjaGVtYS5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5kZXhlcy5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLmdldEJ5SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZ2V0KHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQ29sbGVjdGlvblNjaGVtYS5wcm90b3R5cGUuZGVsZXRlQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLiRpbmRleGVzLmdldChpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5kZXhlcy5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4kaXRlbXMudmFsdWVzKCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCh0eXBlb2YgKHZhbHVlWyd0b0pTT04nXSkgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVbJ3RvSlNPTiddKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERlY29kaW5nIHV0aWxpdGllc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvbmVkO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1zaWRlXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZCA9IE9iamVjdC5hc3NpZ24obmV3IENvbGxlY3Rpb25TY2hlbWEoKSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXJ2ZXItc2lkZVxuICAgICAgICAgICAgICAgICAgICBjbG9uZWQgPSBuZXcgQ29sbGVjdGlvblNjaGVtYSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQuYWRkKHZhbHVlWydjbG9uZSddKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENvbGxlY3Rpb25TY2hlbWEucHJvdG90eXBlLnRyaWdnZXJBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS50cmlnZ2VyQWxsLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBDb2xsZWN0aW9uU2NoZW1hO1xuICAgICAgICB9KCkpO1xuXG4gICAgICAgIHZhciBTZXRTY2hlbWEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBTZXRTY2hlbWEoaW5pdGlhbFZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcyA9IG5ldyBDaGFuZ2VUcmVlKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVmSWQgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gX3RoaXMuYWRkKHYpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTZXRTY2hlbWEuaXMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlWydzZXQnXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNldFNjaGVtYS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVsbHkgcmV0dXJuIGZhbHNlIGlmIHZhbHVlIGFscmVhZHkgYWRkZWQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNldCBcImluZGV4XCIgZm9yIHJlZmVyZW5jZS5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLiRyZWZJZCsrO1xuICAgICAgICAgICAgICAgIGlmICgodmFsdWVbJyRjaGFuZ2VzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbJyRjaGFuZ2VzJ10uc2V0UGFyZW50KHRoaXMsIHRoaXMuJGNoYW5nZXMucm9vdCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gKF9iID0gKF9hID0gdGhpcy4kY2hhbmdlcy5pbmRleGVzW2luZGV4XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBleHBvcnRzLk9QRVJBVElPTi5BREQ7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5pbmRleGVzW2luZGV4XSA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuJGluZGV4ZXMuc2V0KGluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kaXRlbXMuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5jaGFuZ2UoaW5kZXgsIG9wZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNldFNjaGVtYS5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZW50cmllcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNldFNjaGVtYS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuJGl0ZW1zLmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJpZXMubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gZW50cnkudmFsdWVbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZW50cnkudmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuZGVsZXRlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmRlbGV0ZShpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2V0U2NoZW1hLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChpc0RlY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIHByZXZpb3VzIG9wZXJhdGlvbnMuXG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kaXNjYXJkKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuaW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIGNsZWFyIHByZXZpb3VzIGluZGV4ZXNcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgLy8gZmxhZyBjaGlsZCBpdGVtcyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChpc0RlY29kaW5nICYmIHR5cGVvZiAodGhpcy4kY2hhbmdlcy5nZXRUeXBlKCkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRjaGFuZ2VzLnJvb3QucmVtb3ZlUmVmKGl0ZW1bJyRjaGFuZ2VzJ10ucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgaXRlbXNcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMub3BlcmF0aW9uKHsgaW5kZXg6IDAsIG9wOiBleHBvcnRzLk9QRVJBVElPTi5DTEVBUiB9KTtcbiAgICAgICAgICAgICAgICAvLyB0b3VjaCBhbGwgc3RydWN0dXJlcyB1bnRpbCByZWFjaCByb290XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy50b3VjaFBhcmVudHMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLiRpdGVtcy52YWx1ZXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbnRyeSA9IHZhbHVlcy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZW50cnkudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNldFNjaGVtYS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBfKSB7IHJldHVybiBjYWxsYmFja2ZuKHZhbHVlLCBrZXksIF90aGlzKTsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2V0U2NoZW1hLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGl0ZW1zLnZhbHVlcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXRTY2hlbWEucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuc2l6ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLnNldEluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBrZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLnNldChpbmRleCwga2V5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLmdldEJ5SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaXRlbXMuZ2V0KHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2V0U2NoZW1hLnByb3RvdHlwZS5kZWxldGVCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuJGluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpdGVtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbmRleGVzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2V0U2NoZW1hLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJGl0ZW1zLnZhbHVlcygpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXRTY2hlbWEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCh0eXBlb2YgKHZhbHVlWyd0b0pTT04nXSkgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVbJ3RvSlNPTiddKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERlY29kaW5nIHV0aWxpdGllc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIFNldFNjaGVtYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoaXNEZWNvZGluZykge1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVjb2RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGVcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkID0gT2JqZWN0LmFzc2lnbihuZXcgU2V0U2NoZW1hKCksIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VydmVyLXNpZGVcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkID0gbmV3IFNldFNjaGVtYSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWQuYWRkKHZhbHVlWydjbG9uZSddKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNldFNjaGVtYS5wcm90b3R5cGUudHJpZ2dlckFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLnRyaWdnZXJBbGwuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFNldFNjaGVtYTtcbiAgICAgICAgfSgpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0cmFjdGVkIGZyb20gaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3Ryb25nLWV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEV2ZW50RW1pdHRlcl8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXJfKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEV2ZW50RW1pdHRlcl8ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGNiLCBvbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGNiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBFdmVudEVtaXR0ZXJfLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlci5hcHBseSh2b2lkIDAsIGFyZ3MpOyB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBFdmVudEVtaXR0ZXJfLnByb3RvdHlwZS5pbnZva2VBc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgYXJncyk7IH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBFdmVudEVtaXR0ZXJfLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmhhbmRsZXJzLmluZGV4T2YoY2IpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnNbaW5kZXhdID0gdGhpcy5oYW5kbGVyc1t0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMucG9wKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRXZlbnRFbWl0dGVyXy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXJfO1xuICAgICAgICB9KCkpO1xuXG4gICAgICAgIHZhciBDbGllbnRTdGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIENsaWVudFN0YXRlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmSWRzID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lckluZGV4ZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udGFpbmVySW5kZXhlcyA9IG5ldyBNYXA8Q2hhbmdlVHJlZSwgU2V0PG51bWJlcj4+KCk7XG4gICAgICAgICAgICBDbGllbnRTdGF0ZS5wcm90b3R5cGUuYWRkUmVmSWQgPSBmdW5jdGlvbiAoY2hhbmdlVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZWZJZHMuaGFzKGNoYW5nZVRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmSWRzLmFkZChjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXJJbmRleGVzLnNldChjaGFuZ2VUcmVlLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDbGllbnRTdGF0ZS5nZXQgPSBmdW5jdGlvbiAoY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudC4kZmlsdGVyU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQuJGZpbHRlclN0YXRlID0gbmV3IENsaWVudFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnQuJGZpbHRlclN0YXRlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBDbGllbnRTdGF0ZTtcbiAgICAgICAgfSgpKTtcblxuICAgICAgICB2YXIgRW5jb2RlU2NoZW1hRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoRW5jb2RlU2NoZW1hRXJyb3IsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBFbmNvZGVTY2hlbWFFcnJvcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRW5jb2RlU2NoZW1hRXJyb3I7XG4gICAgICAgIH0oRXJyb3IpKTtcbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSwga2xhc3MsIGZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgdHlwZW9mVGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGFsbG93TnVsbCA9IGZhbHNlO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInVpbnQxNlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImZsb2F0MzJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmxvYXQ2NFwiOlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2ZUYXJnZXQgPSBcIm51bWJlclwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInRyeWluZyB0byBlbmNvZGUgXFxcIk5hTlxcXCIgaW4gXCIgKyBrbGFzcy5jb25zdHJ1Y3Rvci5uYW1lICsgXCIjXCIgKyBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2ZUYXJnZXQgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd051bGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBib29sZWFuIGlzIGFsd2F5cyBlbmNvZGVkIGFzIHRydWUvZmFsc2UgYmFzZWQgb24gdHJ1dGhpbmVzc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IHR5cGVvZlRhcmdldCAmJiAoIWFsbG93TnVsbCB8fCAoYWxsb3dOdWxsICYmIHZhbHVlICE9PSBudWxsKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm91bmRWYWx1ZSA9IFwiJ1wiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgXCInXCIgKyAoKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIFwiIChcIiArIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgKyBcIilcIikgfHwgJycpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFbmNvZGVTY2hlbWFFcnJvcihcImEgJ1wiICsgdHlwZW9mVGFyZ2V0ICsgXCInIHdhcyBleHBlY3RlZCwgYnV0IFwiICsgZm91bmRWYWx1ZSArIFwiIHdhcyBwcm92aWRlZCBpbiBcIiArIGtsYXNzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIiNcIiArIGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhc3NlcnRJbnN0YW5jZVR5cGUodmFsdWUsIHR5cGUsIGtsYXNzLCBmaWVsZCkge1xuICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiB0eXBlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFbmNvZGVTY2hlbWFFcnJvcihcImEgJ1wiICsgdHlwZS5uYW1lICsgXCInIHdhcyBleHBlY3RlZCwgYnV0ICdcIiArIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgKyBcIicgd2FzIHByb3ZpZGVkIGluIFwiICsga2xhc3MuY29uc3RydWN0b3IubmFtZSArIFwiI1wiICsgZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVuY29kZVByaW1pdGl2ZVR5cGUodHlwZSwgYnl0ZXMsIHZhbHVlLCBrbGFzcywgZmllbGQpIHtcbiAgICAgICAgICAgIGFzc2VydFR5cGUodmFsdWUsIHR5cGUsIGtsYXNzLCBmaWVsZCk7XG4gICAgICAgICAgICB2YXIgZW5jb2RlRnVuYyA9IGVuY29kZVt0eXBlXTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVGdW5jKSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlRnVuYyhieXRlcywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVuY29kZVNjaGVtYUVycm9yKFwiYSAnXCIgKyB0eXBlICsgXCInIHdhcyBleHBlY3RlZCwgYnV0IFwiICsgdmFsdWUgKyBcIiB3YXMgcHJvdmlkZWQgaW4gXCIgKyBrbGFzcy5jb25zdHJ1Y3Rvci5uYW1lICsgXCIjXCIgKyBmaWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlUHJpbWl0aXZlVHlwZSh0eXBlLCBieXRlcywgaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVbdHlwZV0oYnl0ZXMsIGl0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2NoZW1hIGVuY29kZXIgLyBkZWNvZGVyXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgU2NoZW1hID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gYWxsb3cgaW5oZXJpdGVkIGNsYXNzZXMgdG8gaGF2ZSBhIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBmdW5jdGlvbiBTY2hlbWEoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZpeCBlbnVtZXJhYmlsaXR5IG9mIGZpZWxkcyBmb3IgZW5kLXVzZXJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICRjaGFuZ2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IENoYW5nZVRyZWUodGhpcywgdW5kZWZpbmVkLCBuZXcgUm9vdCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJGxpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9ycyA9IHRoaXMuX2RlZmluaXRpb24uZGVzY3JpcHRvcnM7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIGRlc2NyaXB0b3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduKGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNjaGVtYS5vbkVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5pcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlWydfZGVmaW5pdGlvbiddICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVbJ19kZWZpbml0aW9uJ10uc2NoZW1hICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUuYXNzaWduID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYS5wcm90b3R5cGUsIFwiX2RlZmluaXRpb25cIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5fZGVmaW5pdGlvbjsgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAoYXR0ciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy4kbGlzdGVuZXJzW2F0dHJdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxpc3RlbmVyc1thdHRyXSA9IG5ldyBFdmVudEVtaXR0ZXJfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJGxpc3RlbmVyc1thdHRyXS5yZWdpc3RlcihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHVuLXJlZ2lzdGVyIGNhbGxiYWNrLlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kbGlzdGVuZXJzW2F0dHJdLnJlbW92ZShjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChieXRlcywgaXQsIHJlZiwgYWxsQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGlmIChpdCA9PT0gdm9pZCAwKSB7IGl0ID0geyBvZmZzZXQ6IDAgfTsgfVxuICAgICAgICAgICAgICAgIGlmIChyZWYgPT09IHZvaWQgMCkgeyByZWYgPSB0aGlzOyB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbENoYW5nZXMgPT09IHZvaWQgMCkgeyBhbGxDaGFuZ2VzID0gbmV3IE1hcCgpOyB9XG4gICAgICAgICAgICAgICAgdmFyICRyb290ID0gdGhpcy4kY2hhbmdlcy5yb290O1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbEJ5dGVzID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciByZWZJZCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAkcm9vdC5yZWZzLnNldChyZWZJZCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgYWxsQ2hhbmdlcy5zZXQocmVmSWQsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpdC5vZmZzZXQgPCB0b3RhbEJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBieXRlID0gYnl0ZXNbaXQub2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZSA9PSBTV0lUQ0hfVE9fU1RSVUNUVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZJZCA9IG51bWJlcihieXRlcywgaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRSZWYgPSAkcm9vdC5yZWZzLmdldChyZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIGFjY2VzcyBhIHJlZmVyZW5jZSB0aGF0IGhhdmVuJ3QgYmVlbiBkZWNvZGVkIHlldC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXFwicmVmSWRcXFwiIG5vdCBmb3VuZDogXCIgKyByZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYgPSBuZXh0UmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGVtcHR5IGxpc3Qgb2YgY2hhbmdlcyBmb3IgdGhpcyByZWZJZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbENoYW5nZXMuc2V0KHJlZklkLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VUcmVlID0gcmVmWyckY2hhbmdlcyddO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNTY2hlbWEgPSAocmVmWydfZGVmaW5pdGlvbiddICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gKGlzU2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoYnl0ZSA+PiA2KSA8PCA2IC8vIFwiY29tcHJlc3NlZFwiIGluZGV4ICsgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJ5dGU7IC8vIFwidW5jb21wcmVzc2VkXCIgaW5kZXggKyBvcGVyYXRpb24gKGFycmF5L21hcCBpdGVtcylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQ0xFQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciBtZSFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBgLmNsZWFyKClgIG1ldGhvZCBpcyBjYWxsaW5nIGAkcm9vdC5yZW1vdmVSZWYocmVmSWQpYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhY2ggaXRlbSBpbnNpZGUgdGhpcyBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmNsZWFyKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkSW5kZXggPSAoaXNTY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGJ5dGUgJSAob3BlcmF0aW9uIHx8IDI1NSkgLy8gaWYgXCJSRVBMQUNFXCIgb3BlcmF0aW9uICgwKSwgdXNlIDI1NVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudW1iZXIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IChpc1NjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKHJlZlsnX2RlZmluaXRpb24nXS5maWVsZHNCeUluZGV4W2ZpZWxkSW5kZXhdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNoYW5nZVRyZWUuZ2V0VHlwZShmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5bmFtaWNJbmRleCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IHJlZlsnZ2V0QnlJbmRleCddKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvcGVyYXRpb24gJiBleHBvcnRzLk9QRVJBVElPTi5BREQpID09PSBleHBvcnRzLk9QRVJBVElPTi5BREQpIHsgLy8gQUREIG9yIERFTEVURV9BTkRfQUREXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY0luZGV4ID0gKHJlZiBpbnN0YW5jZW9mIE1hcFNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzdHJpbmcoYnl0ZXMsIGl0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmWydzZXRJbmRleCddKGZpZWxkSW5kZXgsIGR5bmFtaWNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY0luZGV4ID0gcmVmWydnZXRJbmRleCddKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IHJlZltcIl9cIiArIGZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgaWYgKChvcGVyYXRpb24gJiBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24gIT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURV9BTkRfQUREKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmWydkZWxldGVCeUluZGV4J10oZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGFnIGByZWZJZGAgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlICYmIHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdC5yZW1vdmVSZWYocHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAY29seXNldXMvc2NoZW1hOiBkZWZpbml0aW9uIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgc2tpcHBpbmcgbmV4dCBieXRlcyB1bnRpbCByZWFjaGVzIGEga25vd24gc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBsb2NhbCBkZWNvZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SXRlcmF0b3IgPSB7IG9mZnNldDogaXQub2Zmc2V0IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaXQub2Zmc2V0IDwgdG90YWxCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzd2l0Y2hTdHJ1Y3R1cmVDaGVjayhieXRlcywgaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJdGVyYXRvci5vZmZzZXQgPSBpdC5vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHJvb3QucmVmcy5oYXMobnVtYmVyKGJ5dGVzLCBuZXh0SXRlcmF0b3IpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24gPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSkgO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTY2hlbWEuaXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWZJZF8xID0gbnVtYmVyKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICRyb290LnJlZnMuZ2V0KHJlZklkXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiAhPT0gZXhwb3J0cy5PUEVSQVRJT04uUkVQTEFDRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFR5cGUgPSB0aGlzLmdldFNjaGVtYVR5cGUoYnl0ZXMsIGl0LCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jcmVhdGVUeXBlSW5zdGFuY2UoY2hpbGRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuJGNoYW5nZXMucmVmSWQgPSByZWZJZF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUub25DaGFuZ2UgPSBwcmV2aW91c1ZhbHVlLm9uQ2hhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUub25SZW1vdmUgPSBwcmV2aW91c1ZhbHVlLm9uUmVtb3ZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuJGxpc3RlbmVycyA9IHByZXZpb3VzVmFsdWUuJGxpc3RlbmVycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlWyckY2hhbmdlcyddLnJlZklkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmSWRfMSAhPT0gcHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290LnJlbW92ZVJlZihwcmV2aW91c1ZhbHVlWyckY2hhbmdlcyddLnJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdC5hZGRSZWYocmVmSWRfMSwgdmFsdWUsICh2YWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAodHlwZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmUgdmFsdWUgKG51bWJlciwgc3RyaW5nLCBib29sZWFuLCBldGMpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVQcmltaXRpdmVUeXBlKHR5cGUsIGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZURlZiA9IGdldFR5cGUoT2JqZWN0LmtleXModHlwZSlbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZklkXzIgPSBudW1iZXIoYnl0ZXMsIGl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZVJlZiA9ICgkcm9vdC5yZWZzLmhhcyhyZWZJZF8yKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHByZXZpb3VzVmFsdWUgfHwgJHJvb3QucmVmcy5nZXQocmVmSWRfMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyB0eXBlRGVmLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlUmVmLmNsb25lKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuJGNoYW5nZXMucmVmSWQgPSByZWZJZF8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlc2VydmUgc2NoZW1hIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vbkFkZCA9IHByZXZpb3VzVmFsdWUub25BZGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUub25SZW1vdmUgPSBwcmV2aW91c1ZhbHVlLm9uUmVtb3ZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLm9uQ2hhbmdlID0gcHJldmlvdXNWYWx1ZS5vbkNoYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZJZF8yICE9PSBwcmV2aW91c1ZhbHVlWyckY2hhbmdlcyddLnJlZklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290LnJlbW92ZVJlZihwcmV2aW91c1ZhbHVlWyckY2hhbmdlcyddLnJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBvblJlbW92ZSBpZiBzdHJ1Y3R1cmUgaGFzIGJlZW4gcmVwbGFjZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gcHJldmlvdXNWYWx1ZS5lbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGl0ZXIgPSBlbnRyaWVzLm5leHQoKSkgJiYgIWl0ZXIuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gaXRlci52YWx1ZSwga2V5ID0gX2FbMF0sIHZhbHVlXzEgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTogdmFsdWVfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbENoYW5nZXMuc2V0KHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQsIGRlbGV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290LmFkZFJlZihyZWZJZF8yLCB2YWx1ZSwgKHZhbHVlUmVmICE9PSBwcmV2aW91c1ZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVwcmVjYXRlIHByb3hpZXMgb24gbmV4dCB2ZXJzaW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHByb3h5IHRvIHRhcmdldCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZURlZi5nZXRQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHlwZURlZi5nZXRQcm94eSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0NoYW5nZSA9IChwcmV2aW91c1ZhbHVlICE9PSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbJyRjaGFuZ2VzJ10uc2V0UGFyZW50KGNoYW5nZVRyZWUucmVmLCBjaGFuZ2VUcmVlLnJvb3QsIGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZltmaWVsZE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogdXNlIGBfZmllbGRgIGluc3RlYWQgb2YgYGZpZWxkYC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBmaWVsZGAgaXMgZ29pbmcgdG8gdXNlIHRoZSBzZXR0ZXIgb2YgdGhlIFByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjcmVhdGUgYSBwcm94eSBmb3IgYXJyYXkvbWFwLiBUaGlzIGlzIG9ubHkgdXNlZnVsIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggQGNvbHlzZXVzL3NjaGVtYUAwLjUueFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLy8gcmVmW19maWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZiBpbnN0YW5jZW9mIE1hcFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGtleSA9IHJlZlsnJGluZGV4ZXMnXS5nZXQoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBkeW5hbWljSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZbJyRpdGVtcyddLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZiBpbnN0YW5jZW9mIEFycmF5U2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3Qga2V5ID0gcmVmWyckaW5kZXhlcyddW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlNFVFRJTkcgRk9SIEFycmF5U2NoZW1hID0+XCIsIHsgZmllbGQsIGtleSwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYuc2V0QXQoZmllbGRJbmRleCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmIGluc3RhbmNlb2YgQ29sbGVjdGlvblNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJlZi5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZlsnc2V0SW5kZXgnXShmaWVsZEluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYgaW5zdGFuY2VvZiBTZXRTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSByZWYuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZlsnc2V0SW5kZXgnXShmaWVsZEluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNDaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5vbkNoYW5nZSB8fCByZWYuJGxpc3RlbmVyc1tmaWVsZF1cbiAgICAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IG9wZXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNJbmRleDogZHluYW1pY0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiBwcmV2aW91c1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZXMoYWxsQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgLy8gZHJvcCByZWZlcmVuY2VzIG9mIHVudXNlZCBzY2hlbWFzXG4gICAgICAgICAgICAgICAgJHJvb3QuZ2FyYmFnZUNvbGxlY3REZWxldGVkUmVmcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbGxDaGFuZ2VzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGVuY29kZUFsbCwgYnl0ZXMsIHVzZUZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RlQWxsID09PSB2b2lkIDApIHsgZW5jb2RlQWxsID0gZmFsc2U7IH1cbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXMgPT09IHZvaWQgMCkgeyBieXRlcyA9IFtdOyB9XG4gICAgICAgICAgICAgICAgaWYgKHVzZUZpbHRlcnMgPT09IHZvaWQgMCkgeyB1c2VGaWx0ZXJzID0gZmFsc2U7IH1cbiAgICAgICAgICAgICAgICB2YXIgcm9vdENoYW5nZVRyZWUgPSB0aGlzLiRjaGFuZ2VzO1xuICAgICAgICAgICAgICAgIHZhciByZWZJZHNWaXNpdGVkID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlVHJlZXMgPSBbcm9vdENoYW5nZVRyZWVdO1xuICAgICAgICAgICAgICAgIHZhciBudW1DaGFuZ2VUcmVlcyA9IDE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1DaGFuZ2VUcmVlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VUcmVlID0gY2hhbmdlVHJlZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzU2NoZW1hID0gKHJlZiBpbnN0YW5jZW9mIFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIHVuaXF1ZSByZWZJZCBmb3IgdGhlIENoYW5nZVRyZWUuXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuZW5zdXJlUmVmSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFyayB0aGlzIENoYW5nZVRyZWUgYXMgdmlzaXRlZC5cbiAgICAgICAgICAgICAgICAgICAgcmVmSWRzVmlzaXRlZC5hZGQoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJvb3QgYHJlZklkYCBpcyBza2lwcGVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlVHJlZSAhPT0gcm9vdENoYW5nZVRyZWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGFuZ2VUcmVlLmNoYW5nZWQgfHwgZW5jb2RlQWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWludDgkMShieXRlcywgU1dJVENIX1RPX1NUUlVDVFVSRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIkMShieXRlcywgY2hhbmdlVHJlZS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSAoZW5jb2RlQWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBBcnJheS5mcm9tKGNoYW5nZVRyZWUuYWxsQ2hhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogQXJyYXkuZnJvbShjaGFuZ2VUcmVlLmNoYW5nZXMudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgY2wgPSBjaGFuZ2VzLmxlbmd0aDsgaiA8IGNsOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb24gPSAoZW5jb2RlQWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBvcDogZXhwb3J0cy5PUEVSQVRJT04uQURELCBpbmRleDogY2hhbmdlc1tqXSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGFuZ2VzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkSW5kZXggPSBvcGVyYXRpb24uaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSAoaXNTY2hlbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZWZbJ19kZWZpbml0aW9uJ10uZmllbGRzQnlJbmRleCAmJiByZWZbJ19kZWZpbml0aW9uJ10uZmllbGRzQnlJbmRleFtmaWVsZEluZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhY2hlIGJlZ2luIGluZGV4IGlmIGB1c2VGaWx0ZXJzYFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJlZ2luSW5kZXggPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmNvZGUgZmllbGQgaW5kZXggKyBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgIT09IGV4cG9ydHMuT1BFUkFUSU9OLlRPVUNIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXByZXNzIGBmaWVsZEluZGV4YCArIGBvcGVyYXRpb25gIGludG8gYSBzaW5nbGUgYnl0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBhZGRzIGEgbGltaXRhaW9uIG9mIDY0IGZpZWxkcyBwZXIgU2NoZW1hIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aW50OCQxKGJ5dGVzLCAoZmllbGRJbmRleCB8IG9wZXJhdGlvbi5vcCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWludDgkMShieXRlcywgb3BlcmF0aW9uLm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gZXhwb3J0cy5PUEVSQVRJT04uQ0xFQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4ZWQgb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIkMShieXRlcywgZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuY29kZSBcImFsaWFzXCIgZm9yIGR5bmFtaWMgZmllbGRzIChtYXBzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNTY2hlbWEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3BlcmF0aW9uLm9wICYgZXhwb3J0cy5PUEVSQVRJT04uQUREKSA9PSBleHBvcnRzLk9QRVJBVElPTi5BREQgLy8gQUREIG9yIERFTEVURV9BTkRfQUREXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgTWFwU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcFNjaGVtYSBkeW5hbWljIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHluYW1pY0luZGV4ID0gY2hhbmdlVHJlZS5yZWZbJyRpbmRleGVzJ10uZ2V0KGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmckMShieXRlcywgZHluYW1pY0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSBleHBvcnRzLk9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRlbGV0ZSBmcm9tIGZpbHRlciBjYWNoZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHVzZUZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgZGVsZXRlIGNoYW5nZVRyZWUuY2FjaGVzW2ZpZWxkSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IHR5cGUgPSBjaGFuZ2VUcmVlLmNoaWxkVHlwZSB8fCByZWYuX3NjaGVtYVtmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNoYW5nZVRyZWUuZ2V0VHlwZShmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IHR5cGUgPSBjaGFuZ2VUcmVlLmdldFR5cGUoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjaGFuZ2VUcmVlLmdldFZhbHVlKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5xdWV1ZSBDaGFuZ2VUcmVlIHRvIGJlIHZpc2l0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWyckY2hhbmdlcyddICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXJlZklkc1Zpc2l0ZWQuaGFzKHZhbHVlWyckY2hhbmdlcyddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWVzLnB1c2godmFsdWVbJyRjaGFuZ2VzJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWyckY2hhbmdlcyddLmVuc3VyZVJlZklkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtQ2hhbmdlVHJlZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09IGV4cG9ydHMuT1BFUkFUSU9OLlRPVUNIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoU2NoZW1hLmlzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SW5zdGFuY2VUeXBlKHZhbHVlLCB0eXBlLCByZWYsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZSByZWZJZCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYWN0dWFsIGluc3RhbmNlIGlzIGdvaW5nIHRvIGJlIGVuY29kZWQgb24gbmV4dCBgY2hhbmdlVHJlZWAgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyJDEoYnl0ZXMsIHZhbHVlLiRjaGFuZ2VzLnJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZW5jb2RlIGluaGVyaXRlZCBUWVBFX0lEIGlmIGl0J3MgYW4gQUREIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9wZXJhdGlvbi5vcCAmIGV4cG9ydHMuT1BFUkFUSU9OLkFERCkgPT09IGV4cG9ydHMuT1BFUkFUSU9OLkFERCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVuY29kZVR5cGVJZChieXRlcywgdHlwZSwgdmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAodHlwZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVByaW1pdGl2ZVR5cGUodHlwZSwgYnl0ZXMsIHZhbHVlLCByZWYsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3VzdG9tIHR5cGUgKE1hcFNjaGVtYSwgQXJyYXlTY2hlbWEsIGV0YylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZpbml0aW9uID0gZ2V0VHlwZShPYmplY3Qua2V5cyh0eXBlKVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgYSBBcnJheVNjaGVtYSBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SW5zdGFuY2VUeXBlKHJlZltcIl9cIiArIGZpZWxkXSwgZGVmaW5pdGlvbi5jb25zdHJ1Y3RvciwgcmVmLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmNvZGUgcmVmSWQgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCBpbnN0YW5jZSBpcyBnb2luZyB0byBiZSBlbmNvZGVkIG9uIG5leHQgYGNoYW5nZVRyZWVgIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciQxKGJ5dGVzLCB2YWx1ZS4kY2hhbmdlcy5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlRmlsdGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhY2hlIGJlZ2luIC8gZW5kIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5jYWNoZShmaWVsZEluZGV4LCBieXRlcy5zbGljZShiZWdpbkluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmNvZGVBbGwgJiYgIXVzZUZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuZGlzY2FyZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLmVuY29kZUFsbCA9IGZ1bmN0aW9uICh1c2VGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKHRydWUsIFtdLCB1c2VGaWx0ZXJzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLmFwcGx5RmlsdGVycyA9IGZ1bmN0aW9uIChjbGllbnQsIGVuY29kZUFsbCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZUFsbCA9PT0gdm9pZCAwKSB7IGVuY29kZUFsbCA9IGZhbHNlOyB9XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciByZWZJZHNEaXNzYWxsb3dlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICB2YXIgJGZpbHRlclN0YXRlID0gQ2xpZW50U3RhdGUuZ2V0KGNsaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZVRyZWVzID0gW3RoaXMuJGNoYW5nZXNdO1xuICAgICAgICAgICAgICAgIHZhciBudW1DaGFuZ2VUcmVlcyA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkQnl0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VUcmVlID0gY2hhbmdlVHJlZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZJZHNEaXNzYWxsb3dlZC5oYXMoY2hhbmdlVHJlZS5yZWZJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IGNoYW5nZVRyZWUucmVmO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNTY2hlbWEgPSByZWYgaW5zdGFuY2VvZiBTY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgIHVpbnQ4JDEoZmlsdGVyZWRCeXRlcywgU1dJVENIX1RPX1NUUlVDVFVSRSk7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlciQxKGZpbHRlcmVkQnl0ZXMsIGNoYW5nZVRyZWUucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpZW50SGFzUmVmSWQgPSAkZmlsdGVyU3RhdGUucmVmSWRzLmhhcyhjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzRW5jb2RlQWxsID0gKGVuY29kZUFsbCB8fCAhY2xpZW50SGFzUmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlJFRjpcIiwgcmVmLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkVuY29kZSBhbGw/XCIsIGlzRW5jb2RlQWxsKTtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jbHVkZSBgY2hhbmdlVHJlZWAgb24gbGlzdCBvZiBrbm93biByZWZJZHMgYnkgdGhpcyBjbGllbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICRmaWx0ZXJTdGF0ZS5hZGRSZWZJZChjaGFuZ2VUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lckluZGV4ZXMgPSAkZmlsdGVyU3RhdGUuY29udGFpbmVySW5kZXhlcy5nZXQoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gKGlzRW5jb2RlQWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBBcnJheS5mcm9tKGNoYW5nZVRyZWUuYWxsQ2hhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogQXJyYXkuZnJvbShjaGFuZ2VUcmVlLmNoYW5nZXMudmFsdWVzKCkpO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBXT1JLQVJPVU5EOiB0cmllcyB0byByZS1ldmFsdWF0ZSBwcmV2aW91c2x5IG5vdCBpbmNsdWRlZCBAZmlsdGVyKCkgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAvLyAtIHNlZSBcIkRFTEVURSBhIGZpZWxkIG9mIFNjaGVtYVwiIHRlc3QgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmNvZGVBbGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2NoZW1hICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByZWYuX2RlZmluaXRpb24uaW5kZXhlc1dpdGhGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhlc1dpdGhGaWx0ZXJzID0gcmVmLl9kZWZpbml0aW9uLmluZGV4ZXNXaXRoRmlsdGVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXNXaXRoRmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleFdpdGhGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lckluZGV4ZXMuaGFzKGluZGV4V2l0aEZpbHRlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5hbGxDaGFuZ2VzLmhhcyhpbmRleFdpdGhGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VuY29kZUFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGluZGV4V2l0aEZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBvcDogZXhwb3J0cy5PUEVSQVRJT04uQURELCBpbmRleDogaW5kZXhXaXRoRmlsdGVyLCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBjbCA9IGNoYW5nZXMubGVuZ3RoOyBqIDwgY2w7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IChpc0VuY29kZUFsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgb3A6IGV4cG9ydHMuT1BFUkFUSU9OLkFERCwgaW5kZXg6IGNoYW5nZXNbal0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2hhbmdlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBvcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLm9wID09PSBleHBvcnRzLk9QRVJBVElPTi5DTEVBUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpbnQ4JDEoZmlsdGVyZWRCeXRlcywgY2hhbmdlLm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZEluZGV4ID0gY2hhbmdlLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0aW5nIGZpZWxkczogZW5jb2RlIHRoZSBvcGVyYXRpb24gKyBmaWVsZCBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uub3AgPT09IGV4cG9ydHMuT1BFUkFUSU9OLkRFTEVURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gREVMRVRFIG9wZXJhdGlvbnMgYWxzbyBuZWVkIHRvIGdvIHRocm91Z2ggZmlsdGVyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogY2FjaGUgdGhlIHByZXZpb3VzIHZhbHVlIHNvIHdlIGNhbiBhY2Nlc3MgdGhlIHZhbHVlIChwcmltaXRpdmUgb3IgYHJlZklkYClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoY2hlY2sgYWdhaW5zdCBgJGZpbHRlclN0YXRlLnJlZklkc2ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWludDgkMShmaWx0ZXJlZEJ5dGVzLCBjaGFuZ2Uub3AgfCBmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpbnQ4JDEoZmlsdGVyZWRCeXRlcywgY2hhbmdlLm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyJDEoZmlsdGVyZWRCeXRlcywgZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhlZCBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNoYW5nZVRyZWUuZ2V0VmFsdWUoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNoYW5nZVRyZWUuZ2V0VHlwZShmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIGEgU2NoZW1hIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSAocmVmLl9kZWZpbml0aW9uLmZpbHRlcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLl9kZWZpbml0aW9uLmZpbHRlcnNbZmllbGRJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlci5jYWxsKHJlZiwgY2xpZW50LCB2YWx1ZSwgcm9vdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZJZHNEaXNzYWxsb3dlZC5hZGQodmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIGEgY29sbGVjdGlvbiEgKG1hcCwgYXJyYXksIGV0Yy4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGNoYW5nZVRyZWUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBjaGFuZ2VUcmVlLmdldENoaWxkcmVuRmlsdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyLmNhbGwocGFyZW50LCBjbGllbnQsIHJlZlsnJGluZGV4ZXMnXS5nZXQoZmllbGRJbmRleCksIHZhbHVlLCByb290KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZklkc0Rpc3NhbGxvd2VkLmFkZCh2YWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmlzaXQgY2hpbGQgQ2hhbmdlVHJlZSBvbiBmdXJ0aGVyIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWVzLnB1c2godmFsdWVbJyRjaGFuZ2VzJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUNoYW5nZVRyZWVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBjYWNoZWQgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLm9wICE9PSBleHBvcnRzLk9QRVJBVElPTi5UT1VDSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgbWUhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLm9wID09PSBleHBvcnRzLk9QRVJBVElPTi5BREQgfHwgaXNTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGNhY2hlZCBieXRlcyBkaXJlY3RseSBpZiBpcyBmcm9tIFNjaGVtYSB0eXBlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEJ5dGVzLnB1c2guYXBwbHkoZmlsdGVyZWRCeXRlcywgKF9hID0gY2hhbmdlVHJlZS5jYWNoZXNbZmllbGRJbmRleF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVySW5kZXhlcy5hZGQoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVySW5kZXhlcy5oYXMoZmllbGRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgY2FjaGVkIGJ5dGVzIGlmIGFscmVhZHkgaGFzIHRoZSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQnl0ZXMucHVzaC5hcHBseShmaWx0ZXJlZEJ5dGVzLCAoX2IgPSBjaGFuZ2VUcmVlLmNhY2hlc1tmaWVsZEluZGV4XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIEFERCBvcGVyYXRpb24gaWYgZmllbGQgaXMgbm90IGtub3duIGJ5IHRoaXMgY2xpZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckluZGV4ZXMuYWRkKGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWludDgkMShmaWx0ZXJlZEJ5dGVzLCBleHBvcnRzLk9QRVJBVElPTi5BREQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyJDEoZmlsdGVyZWRCeXRlcywgZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgTWFwU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXBTY2hlbWEgZHluYW1pYyBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeW5hbWljSW5kZXggPSBjaGFuZ2VUcmVlLnJlZlsnJGluZGV4ZXMnXS5nZXQoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nJDEoZmlsdGVyZWRCeXRlcywgZHluYW1pY0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciQxKGZpbHRlcmVkQnl0ZXMsIHZhbHVlWyckY2hhbmdlcyddLnJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiZW5jb2RlUHJpbWl0aXZlVHlwZVwiIHdpdGhvdXQgdHlwZSBjaGVja2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdHlwZSBjaGVja2luZyBoYXMgYmVlbiBkb25lIG9uIHRoZSBmaXJzdCAuZW5jb2RlKCkgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVbdHlwZV0oZmlsdGVyZWRCeXRlcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVbJyRjaGFuZ2VzJ10gJiYgIWlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gdHJhY2sgQUREL1JFUExBQ0UvREVMRVRFIGluc3RhbmNlcyBvbiBgJGZpbHRlclN0YXRlYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gZG8gTk9UIGFsd2F5cyBlbmNvZGUgZHluYW1pY0luZGV4IGZvciBNYXBTY2hlbWEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAoSWYgY2xpZW50IGFscmVhZHkgaGFzIHRoYXQga2V5LCBvbmx5IHRoZSBmaXJzdCBpbmRleCBpcyBuZWNlc3NhcnkuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWludDgkMShmaWx0ZXJlZEJ5dGVzLCBleHBvcnRzLk9QRVJBVElPTi5BREQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciQxKGZpbHRlcmVkQnl0ZXMsIGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBNYXBTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwU2NoZW1hIGR5bmFtaWMga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeW5hbWljSW5kZXggPSBjaGFuZ2VUcmVlLnJlZlsnJGluZGV4ZXMnXS5nZXQoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyQxKGZpbHRlcmVkQnl0ZXMsIGR5bmFtaWNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciQxKGZpbHRlcmVkQnl0ZXMsIHZhbHVlWyckY2hhbmdlcyddLnJlZklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1DaGFuZ2VUcmVlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZEJ5dGVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lZCA9IG5ldyAodGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuX2RlZmluaXRpb24uc2NoZW1hO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGZpZWxkIGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzW2ZpZWxkXSkgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiAodGhpc1tmaWVsZF0uY2xvbmUpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZXAgY2xvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lZFtmaWVsZF0gPSB0aGlzW2ZpZWxkXS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkW2ZpZWxkXSA9IHRoaXNbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS50cmlnZ2VyQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgaGF2ZW4ndCByZWNlaXZlZCBhbnkgcmVtb3RlIHJlZnMgeWV0LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRjaGFuZ2VzLnJvb3QucmVmcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFsbENoYW5nZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5fdHJpZ2dlckFsbEZpbGxDaGFuZ2VzLmNhbGwodGhpcywgdGhpcywgYWxsQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5fdHJpZ2dlckNoYW5nZXMuY2FsbCh0aGlzLCBhbGxDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgU2NoZW1hLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzY2hlbWEgPSB0aGlzLl9kZWZpbml0aW9uLnNjaGVtYTtcbiAgICAgICAgICAgICAgICB2YXIgZGVwcmVjYXRlZCA9IHRoaXMuX2RlZmluaXRpb24uZGVwcmVjYXRlZDtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZmllbGQgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVwcmVjYXRlZFtmaWVsZF0gJiYgdGhpc1tmaWVsZF0gIT09IG51bGwgJiYgdHlwZW9mICh0aGlzW2ZpZWxkXSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtmaWVsZF0gPSAodHlwZW9mICh0aGlzW2ZpZWxkXVsndG9KU09OJ10pID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzW2ZpZWxkXVsndG9KU09OJ10oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpc1tcIl9cIiArIGZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUuZGlzY2FyZEFsbENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kaXNjYXJkQWxsKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5nZXRCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdGhpcy5fZGVmaW5pdGlvbi5maWVsZHNCeUluZGV4W2luZGV4XV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5kZWxldGVCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLl9kZWZpbml0aW9uLmZpZWxkc0J5SW5kZXhbaW5kZXhdXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLnRyeUVuY29kZVR5cGVJZCA9IGZ1bmN0aW9uIChieXRlcywgdHlwZSwgdGFyZ2V0VHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLl90eXBlaWQgIT09IHRhcmdldFR5cGUuX3R5cGVpZCkge1xuICAgICAgICAgICAgICAgICAgICB1aW50OCQxKGJ5dGVzLCBUWVBFX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyJDEoYnl0ZXMsIHRhcmdldFR5cGUuX3R5cGVpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUuZ2V0U2NoZW1hVHlwZSA9IGZ1bmN0aW9uIChieXRlcywgaXQsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzW2l0Lm9mZnNldF0gPT09IFRZUEVfSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0aGlzLmNvbnN0cnVjdG9yLl9jb250ZXh0LmdldChudW1iZXIoYnl0ZXMsIGl0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlIHx8IGRlZmF1bHRUeXBlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUuY3JlYXRlVHlwZUluc3RhbmNlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgdHlwZSgpO1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiByb290IG9uICRjaGFuZ2VzXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuJGNoYW5nZXMucm9vdCA9IHRoaXMuJGNoYW5nZXMucm9vdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5fdHJpZ2dlckFsbEZpbGxDaGFuZ2VzID0gZnVuY3Rpb24gKHJlZiwgYWxsQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGlmIChhbGxDaGFuZ2VzLmhhcyhyZWZbJyRjaGFuZ2VzJ10ucmVmSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBhbGxDaGFuZ2VzLnNldChyZWZbJyRjaGFuZ2VzJ10ucmVmSWQgfHwgMCwgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gcmVmLl9kZWZpbml0aW9uLnNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9maWVsZCA9IFwiX1wiICsgZmllbGROYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVmW19maWVsZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBleHBvcnRzLk9QRVJBVElPTi5BREQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5fdHJpZ2dlckFsbEZpbGxDaGFuZ2VzLmNhbGwodGhpcywgdmFsdWUsIGFsbENoYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSByZWYuZW50cmllcygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChpdGVyID0gZW50cmllcy5uZXh0KCkpICYmICFpdGVyLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGl0ZXIudmFsdWUsIGtleSA9IF9hWzBdLCB2YWx1ZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogZXhwb3J0cy5PUEVSQVRJT04uQURELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY0luZGV4OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLl90cmlnZ2VyQWxsRmlsbENoYW5nZXMuY2FsbCh0aGlzLCB2YWx1ZSwgYWxsQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5fdHJpZ2dlckNoYW5nZXMgPSBmdW5jdGlvbiAoYWxsQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgYWxsQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2VzLCByZWZJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IF90aGlzLiRjaGFuZ2VzLnJvb3QucmVmcy5nZXQocmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzU2NoZW1hID0gcmVmIGluc3RhbmNlb2YgU2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gcmVmWyckbGlzdGVuZXJzJ10gJiYgcmVmWyckbGlzdGVuZXJzJ11bY2hhbmdlLmZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uub3AgPT09IGV4cG9ydHMuT1BFUkFUSU9OLkFERCAmJiBjaGFuZ2UucHJldmlvdXNWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSByZWYpLm9uQWRkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgY2hhbmdlLnZhbHVlLCAoX2MgPSBjaGFuZ2UuZHluYW1pY0luZGV4KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjaGFuZ2UuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS5vcCA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IGBwcmV2aW91c1ZhbHVlYCBzaG91bGQgYWx3YXlzIGJlIGF2YWlpYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFERCArIERFTEVURSBvcGVyYXRpb25zIGFyZSBzdGlsbCBlbmNvZGluZyBERUxFVEUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UucHJldmlvdXNWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9lID0gKF9kID0gcmVmKS5vblJlbW92ZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QsIGNoYW5nZS5wcmV2aW91c1ZhbHVlLCAoX2YgPSBjaGFuZ2UuZHluYW1pY0luZGV4KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBjaGFuZ2UuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS5vcCA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFX0FORF9BREQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UucHJldmlvdXNWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9oID0gKF9nID0gcmVmKS5vblJlbW92ZSkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmNhbGwoX2csIGNoYW5nZS5wcmV2aW91c1ZhbHVlLCBjaGFuZ2UuZHluYW1pY0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfayA9IChfaiA9IHJlZikub25BZGQpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5jYWxsKF9qLCBjaGFuZ2UudmFsdWUsIGNoYW5nZS5keW5hbWljSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS5vcCA9PT0gZXhwb3J0cy5PUEVSQVRJT04uUkVQTEFDRSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnZhbHVlICE9PSBjaGFuZ2UucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9tID0gKF9sID0gcmVmKS5vbkNoYW5nZSkgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLmNhbGwoX2wsIGNoYW5nZS52YWx1ZSwgY2hhbmdlLmR5bmFtaWNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIG9uUmVtb3ZlIG9uIGNoaWxkIHN0cnVjdHVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY2hhbmdlLm9wICYgZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFKSA9PT0gZXhwb3J0cy5PUEVSQVRJT04uREVMRVRFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5wcmV2aW91c1ZhbHVlIGluc3RhbmNlb2YgU2NoZW1hICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5wcmV2aW91c1ZhbHVlLm9uUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5wcmV2aW91c1ZhbHVlLm9uUmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuaW52b2tlKGNoYW5nZS52YWx1ZSwgY2hhbmdlLnByZXZpb3VzVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTY2hlbWEub25FcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWYub25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZi5vbkNoYW5nZShjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2NoZW1hLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTY2hlbWEuX2RlZmluaXRpb24gPSBTY2hlbWFEZWZpbml0aW9uLmNyZWF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFNjaGVtYTtcbiAgICAgICAgfSgpKTtcblxuICAgICAgICBmdW5jdGlvbiBkdW1wQ2hhbmdlcyhzY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VUcmVlcyA9IFtzY2hlbWFbJyRjaGFuZ2VzJ11dO1xuICAgICAgICAgICAgdmFyIG51bUNoYW5nZVRyZWVzID0gMTtcbiAgICAgICAgICAgIHZhciBkdW1wID0ge307XG4gICAgICAgICAgICB2YXIgY3VycmVudFN0cnVjdHVyZSA9IGR1bXA7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZVRyZWUgPSBjaGFuZ2VUcmVlc1tpXTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSBjaGFuZ2VUcmVlLnJlZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkSW5kZXggPSBjaGFuZ2UuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IChyZWZbJ19kZWZpbml0aW9uJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZlsnX2RlZmluaXRpb24nXS5maWVsZHNCeUluZGV4W2ZpZWxkSW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlZlsnJGluZGV4ZXMnXS5nZXQoZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmVbZmllbGRdID0gY2hhbmdlVHJlZS5nZXRWYWx1ZShmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNoYW5nZVRyZWVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGR1bXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmbGVjdGlvbkNvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIFJlZmxlY3Rpb25GaWVsZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhSZWZsZWN0aW9uRmllbGQsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aW9uRmllbGQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICAgICAgdHlwZShcInN0cmluZ1wiLCByZWZsZWN0aW9uQ29udGV4dClcbiAgICAgICAgICAgIF0sIFJlZmxlY3Rpb25GaWVsZC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuICAgICAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICAgICAgdHlwZShcInN0cmluZ1wiLCByZWZsZWN0aW9uQ29udGV4dClcbiAgICAgICAgICAgIF0sIFJlZmxlY3Rpb25GaWVsZC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuICAgICAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICAgICAgdHlwZShcIm51bWJlclwiLCByZWZsZWN0aW9uQ29udGV4dClcbiAgICAgICAgICAgIF0sIFJlZmxlY3Rpb25GaWVsZC5wcm90b3R5cGUsIFwicmVmZXJlbmNlZFR5cGVcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0aW9uRmllbGQ7XG4gICAgICAgIH0oU2NoZW1hKSk7XG4gICAgICAgIHZhciBSZWZsZWN0aW9uVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhSZWZsZWN0aW9uVHlwZSwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJlZmxlY3Rpb25UeXBlKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgICAgIF90aGlzLmZpZWxkcyA9IG5ldyBBcnJheVNjaGVtYSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgICAgIHR5cGUoXCJudW1iZXJcIiwgcmVmbGVjdGlvbkNvbnRleHQpXG4gICAgICAgICAgICBdLCBSZWZsZWN0aW9uVHlwZS5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgICAgIHR5cGUoW1JlZmxlY3Rpb25GaWVsZF0sIHJlZmxlY3Rpb25Db250ZXh0KVxuICAgICAgICAgICAgXSwgUmVmbGVjdGlvblR5cGUucHJvdG90eXBlLCBcImZpZWxkc1wiLCB2b2lkIDApO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Rpb25UeXBlO1xuICAgICAgICB9KFNjaGVtYSkpO1xuICAgICAgICB2YXIgUmVmbGVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhSZWZsZWN0aW9uLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgICAgICBfdGhpcy50eXBlcyA9IG5ldyBBcnJheVNjaGVtYSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlZmxlY3Rpb24uZW5jb2RlID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RTY2hlbWFUeXBlID0gaW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgdmFyIHJlZmxlY3Rpb24gPSBuZXcgUmVmbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHJlZmxlY3Rpb24ucm9vdFR5cGUgPSByb290U2NoZW1hVHlwZS5fdHlwZWlkO1xuICAgICAgICAgICAgICAgIHZhciBidWlsZFR5cGUgPSBmdW5jdGlvbiAoY3VycmVudFR5cGUsIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBuZXcgUmVmbGVjdGlvbkZpZWxkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5uYW1lID0gZmllbGROYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHNjaGVtYVtmaWVsZE5hbWVdKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVHlwZSA9IHNjaGVtYVtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVfMSA9IHNjaGVtYVtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFR5cGVTY2hlbWEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciBiZWxvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTY2hlbWEuaXModHlwZV8xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFR5cGUgPSBcInJlZlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFR5cGVTY2hlbWEgPSBzY2hlbWFbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVHlwZSA9IE9iamVjdC5rZXlzKHR5cGVfMSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHR5cGVfMVtmaWVsZFR5cGVdKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlICs9IFwiOlwiICsgdHlwZV8xW2ZpZWxkVHlwZV07IC8vIGFycmF5OnN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRUeXBlU2NoZW1hID0gdHlwZV8xW2ZpZWxkVHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQucmVmZXJlbmNlZFR5cGUgPSAoY2hpbGRUeXBlU2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNoaWxkVHlwZVNjaGVtYS5fdHlwZWlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC50eXBlID0gZmllbGRUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFR5cGUuZmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlZmxlY3Rpb24udHlwZXMucHVzaChjdXJyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZXMgPSByb290U2NoZW1hVHlwZS5fY29udGV4dC50eXBlcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0eXBlaWQgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVfMiA9IG5ldyBSZWZsZWN0aW9uVHlwZSgpO1xuICAgICAgICAgICAgICAgICAgICB0eXBlXzIuaWQgPSBOdW1iZXIodHlwZWlkKTtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRUeXBlKHR5cGVfMiwgdHlwZXNbdHlwZWlkXS5fZGVmaW5pdGlvbi5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmbGVjdGlvbi5lbmNvZGVBbGwoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBSZWZsZWN0aW9uLmRlY29kZSA9IGZ1bmN0aW9uIChieXRlcywgaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZmxlY3Rpb24gPSBuZXcgUmVmbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHJlZmxlY3Rpb24uZGVjb2RlKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICAgICAgdmFyIHNjaGVtYVR5cGVzID0gcmVmbGVjdGlvbi50eXBlcy5yZWR1Y2UoZnVuY3Rpb24gKHR5cGVzLCByZWZsZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX19leHRlbmRzKF8sIF9zdXBlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfO1xuICAgICAgICAgICAgICAgICAgICB9KFNjaGVtYSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZWlkID0gcmVmbGVjdGlvblR5cGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzW3R5cGVpZF0gPSBzY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYWRkKHNjaGVtYSwgdHlwZWlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICByZWZsZWN0aW9uLnR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHJlZmxlY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2hlbWFUeXBlID0gc2NoZW1hVHlwZXNbcmVmbGVjdGlvblR5cGUuaWRdO1xuICAgICAgICAgICAgICAgICAgICByZWZsZWN0aW9uVHlwZS5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZWZlcmVuY2VkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IGZpZWxkLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZlR5cGUgPSBzY2hlbWFUeXBlc1tmaWVsZC5yZWZlcmVuY2VkVHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFwIG9yIGFycmF5IG9mIHByaW1pdGl2ZSB0eXBlICgtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZlR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVJbmZvID0gZmllbGQudHlwZS5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVHlwZSA9IHR5cGVJbmZvWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZUeXBlID0gdHlwZUluZm9bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZFR5cGUgPT09IFwicmVmXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZShyZWZUeXBlLCBjb250ZXh0KShzY2hlbWFUeXBlLnByb3RvdHlwZSwgZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlKChfYSA9IHt9LCBfYVtmaWVsZFR5cGVdID0gcmVmVHlwZSwgX2EpLCBjb250ZXh0KShzY2hlbWFUeXBlLnByb3RvdHlwZSwgZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZShmaWVsZC50eXBlLCBjb250ZXh0KShzY2hlbWFUeXBlLnByb3RvdHlwZSwgZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciByb290VHlwZSA9IHNjaGVtYVR5cGVzW3JlZmxlY3Rpb24ucm9vdFR5cGVdO1xuICAgICAgICAgICAgICAgIHZhciByb290SW5zdGFuY2UgPSBuZXcgcm9vdFR5cGUoKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBhdXRvLWluaXRpYWxpemUgcmVmZXJlbmNlZCB0eXBlcyBvbiByb290IHR5cGVcbiAgICAgICAgICAgICAgICAgKiB0byBhbGxvdyByZWdpc3RlcmluZyBsaXN0ZW5lcnMgaW1tZWRpYXRlbGx5IG9uIGNsaWVudC1zaWRlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIHJvb3RUeXBlLl9kZWZpbml0aW9uLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRUeXBlID0gcm9vdFR5cGUuX2RlZmluaXRpb24uc2NoZW1hW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGZpZWxkVHlwZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RJbnN0YW5jZVtmaWVsZE5hbWVdID0gKHR5cGVvZiAoZmllbGRUeXBlKSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IGZpZWxkVHlwZSgpIC8vIGlzIGEgc2NoZW1hIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IChnZXRUeXBlKE9iamVjdC5rZXlzKGZpZWxkVHlwZSlbMF0pKS5jb25zdHJ1Y3RvcigpOyAvLyBpcyBhIFwiY29sbGVjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RJbnN0YW5jZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgICAgICB0eXBlKFtSZWZsZWN0aW9uVHlwZV0sIHJlZmxlY3Rpb25Db250ZXh0KVxuICAgICAgICAgICAgXSwgUmVmbGVjdGlvbi5wcm90b3R5cGUsIFwidHlwZXNcIiwgdm9pZCAwKTtcbiAgICAgICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgICAgIHR5cGUoXCJudW1iZXJcIiwgcmVmbGVjdGlvbkNvbnRleHQpXG4gICAgICAgICAgICBdLCBSZWZsZWN0aW9uLnByb3RvdHlwZSwgXCJyb290VHlwZVwiLCB2b2lkIDApO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Rpb247XG4gICAgICAgIH0oU2NoZW1hKSk7XG5cbiAgICAgICAgcmVnaXN0ZXJUeXBlKFwibWFwXCIsIHsgY29uc3RydWN0b3I6IE1hcFNjaGVtYSwgZ2V0UHJveHk6IGdldE1hcFByb3h5IH0pO1xuICAgICAgICByZWdpc3RlclR5cGUoXCJhcnJheVwiLCB7IGNvbnN0cnVjdG9yOiBBcnJheVNjaGVtYSwgZ2V0UHJveHk6IGdldEFycmF5UHJveHkgfSk7XG4gICAgICAgIHJlZ2lzdGVyVHlwZShcInNldFwiLCB7IGNvbnN0cnVjdG9yOiBTZXRTY2hlbWEgfSk7XG4gICAgICAgIHJlZ2lzdGVyVHlwZShcImNvbGxlY3Rpb25cIiwgeyBjb25zdHJ1Y3RvcjogQ29sbGVjdGlvblNjaGVtYSwgfSk7XG5cbiAgICAgICAgZXhwb3J0cy5BcnJheVNjaGVtYSA9IEFycmF5U2NoZW1hO1xuICAgICAgICBleHBvcnRzLkNvbGxlY3Rpb25TY2hlbWEgPSBDb2xsZWN0aW9uU2NoZW1hO1xuICAgICAgICBleHBvcnRzLkNvbnRleHQgPSBDb250ZXh0O1xuICAgICAgICBleHBvcnRzLk1hcFNjaGVtYSA9IE1hcFNjaGVtYTtcbiAgICAgICAgZXhwb3J0cy5SZWZsZWN0aW9uID0gUmVmbGVjdGlvbjtcbiAgICAgICAgZXhwb3J0cy5SZWZsZWN0aW9uRmllbGQgPSBSZWZsZWN0aW9uRmllbGQ7XG4gICAgICAgIGV4cG9ydHMuUmVmbGVjdGlvblR5cGUgPSBSZWZsZWN0aW9uVHlwZTtcbiAgICAgICAgZXhwb3J0cy5TY2hlbWEgPSBTY2hlbWE7XG4gICAgICAgIGV4cG9ydHMuU2NoZW1hRGVmaW5pdGlvbiA9IFNjaGVtYURlZmluaXRpb247XG4gICAgICAgIGV4cG9ydHMuU2V0U2NoZW1hID0gU2V0U2NoZW1hO1xuICAgICAgICBleHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbiAgICAgICAgZXhwb3J0cy5kZWZpbmVUeXBlcyA9IGRlZmluZVR5cGVzO1xuICAgICAgICBleHBvcnRzLmRlcHJlY2F0ZWQgPSBkZXByZWNhdGVkO1xuICAgICAgICBleHBvcnRzLmR1bXBDaGFuZ2VzID0gZHVtcENoYW5nZXM7XG4gICAgICAgIGV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuICAgICAgICBleHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgZXhwb3J0cy5maWx0ZXJDaGlsZHJlbiA9IGZpbHRlckNoaWxkcmVuO1xuICAgICAgICBleHBvcnRzLmhhc0ZpbHRlciA9IGhhc0ZpbHRlcjtcbiAgICAgICAgZXhwb3J0cy5yZWdpc3RlclR5cGUgPSByZWdpc3RlclR5cGU7XG4gICAgICAgIGV4cG9ydHMudHlwZSA9IHR5cGU7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuICAgIH0pKSk7XG4gICAgfSk7XG5cbiAgICB2YXIgUm9vbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUm9vbShuYW1lLCByb290U2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gUHVibGljIHNpZ25hbHNcbiAgICAgICAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IGNyZWF0ZVNpZ25hbCgpO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yID0gY3JlYXRlU2lnbmFsKCk7XG4gICAgICAgICAgICB0aGlzLm9uTGVhdmUgPSBjcmVhdGVTaWduYWwoKTtcbiAgICAgICAgICAgIHRoaXMub25Kb2luID0gY3JlYXRlU2lnbmFsKCk7XG4gICAgICAgICAgICB0aGlzLmhhc0pvaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2VIYW5kbGVycyA9IGNyZWF0ZU5hbm9FdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGlmIChyb290U2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IChnZXRTZXJpYWxpemVyKFwic2NoZW1hXCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RTY2hlbWEgPSByb290U2NoZW1hO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplci5zdGF0ZSA9IG5ldyByb290U2NoZW1hKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoZnVuY3Rpb24gKGNvZGUsIG1lc3NhZ2UpIHsgcmV0dXJuIGNvbnNvbGUud2FybihcImNvbHlzZXVzLmpzIC0gb25FcnJvciA9PiAoXCIgKyBjb2RlICsgXCIpIFwiICsgbWVzc2FnZSk7IH0pO1xuICAgICAgICAgICAgdGhpcy5vbkxlYXZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlbW92ZUFsbExpc3RlbmVycygpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBSb29tLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKGVuZHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5ldmVudHMub25tZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2VDYWxsYmFjay5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmV2ZW50cy5vbmNsb3NlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmhhc0pvaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJSb29tIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCB1bmV4cGVjdGVkbHkgKFwiICsgZS5jb2RlICsgXCIpOiBcIiArIGUucmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25FcnJvci5pbnZva2UoZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMub25MZWF2ZS5pbnZva2UoZS5jb2RlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmV2ZW50cy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJSb29tLCBvbkVycm9yIChcIiArIGUuY29kZSArIFwiKTogXCIgKyBlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgX3RoaXMub25FcnJvci5pbnZva2UoZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3QoZW5kcG9pbnQpO1xuICAgICAgICB9O1xuICAgICAgICBSb29tLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uIChjb25zZW50ZWQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoY29uc2VudGVkID09PSB2b2lkIDApIHsgY29uc2VudGVkID0gdHJ1ZTsgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25MZWF2ZShmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gcmVzb2x2ZShjb2RlKTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNlbnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdGlvbi5zZW5kKFtleHBvcnRzLlByb3RvY29sLkxFQVZFX1JPT01dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25MZWF2ZS5pbnZva2UoNDAwMCk7IC8vIFwiY29uc2VudGVkXCIgY29kZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBSb29tLnByb3RvdHlwZS5vbk1lc3NhZ2UgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uTWVzc2FnZUhhbmRsZXJzLm9uKHRoaXMuZ2V0TWVzc2FnZUhhbmRsZXJLZXkodHlwZSksIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgUm9vbS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbEJ5dGVzID0gW2V4cG9ydHMuUHJvdG9jb2wuUk9PTV9EQVRBXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR5cGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdW1kLmVuY29kZS5zdHJpbmcoaW5pdGlhbEJ5dGVzLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVtZC5lbmNvZGUubnVtYmVyKGluaXRpYWxCeXRlcywgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJyO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmNvZGVkID0gZW5jb2RlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGFyciA9IG5ldyBVaW50OEFycmF5KGluaXRpYWxCeXRlcy5sZW5ndGggKyBlbmNvZGVkLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGFyci5zZXQobmV3IFVpbnQ4QXJyYXkoaW5pdGlhbEJ5dGVzKSwgMCk7XG4gICAgICAgICAgICAgICAgYXJyLnNldChuZXcgVWludDhBcnJheShlbmNvZGVkKSwgaW5pdGlhbEJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnIgPSBuZXcgVWludDhBcnJheShpbml0aWFsQnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmQoYXJyLmJ1ZmZlcik7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb29tLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVyLmdldFN0YXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJvb20ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMub25Kb2luLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLm9uU3RhdGVDaGFuZ2UuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMub25FcnJvci5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5vbkxlYXZlLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZUhhbmRsZXJzLmV2ZW50cyA9IHt9O1xuICAgICAgICB9O1xuICAgICAgICBSb29tLnByb3RvdHlwZS5vbk1lc3NhZ2VDYWxsYmFjayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGJ5dGVzID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShldmVudC5kYXRhKSk7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4cG9ydHMuUHJvdG9jb2wuSk9JTl9ST09NKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVySWQgPSB1dGY4UmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdXRmOExlbmd0aCh0aGlzLnNlcmlhbGl6ZXJJZCk7XG4gICAgICAgICAgICAgICAgLy8gSW5zdGFudGlhdGUgc2VyaWFsaXplciBpZiBub3QgbG9jYWxseSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlcmlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBnZXRTZXJpYWxpemVyKHRoaXMuc2VyaWFsaXplcklkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IHNlcmlhbGl6ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IG9mZnNldCAmJiB0aGlzLnNlcmlhbGl6ZXIuaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplci5oYW5kc2hha2UoYnl0ZXMsIHsgb2Zmc2V0OiBvZmZzZXQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGFzSm9pbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSm9pbi5pbnZva2UoKTtcbiAgICAgICAgICAgICAgICAvLyBhY2tub3dsZWRnZSBzdWNjZXNzZnVsbCBKT0lOX1JPT01cbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZChbZXhwb3J0cy5Qcm90b2NvbC5KT0lOX1JPT01dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPT09IGV4cG9ydHMuUHJvdG9jb2wuRVJST1IpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRfMSA9IHsgb2Zmc2V0OiAxIH07XG4gICAgICAgICAgICAgICAgdmFyIGNvZGVfMSA9IHVtZC5kZWNvZGUubnVtYmVyKGJ5dGVzLCBpdF8xKTtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHVtZC5kZWNvZGUuc3RyaW5nKGJ5dGVzLCBpdF8xKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IuaW52b2tlKGNvZGVfMSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSBleHBvcnRzLlByb3RvY29sLkxFQVZFX1JPT00pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSBleHBvcnRzLlByb3RvY29sLlJPT01fREFUQV9TQ0hFTUEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRfMiA9IHsgb2Zmc2V0OiAxIH07XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHRfMSA9IHRoaXMuc2VyaWFsaXplci5nZXRTdGF0ZSgpLmNvbnN0cnVjdG9yLl9jb250ZXh0O1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gY29udGV4dF8xLmdldCh1bWQuZGVjb2RlLm51bWJlcihieXRlcywgaXRfMikpO1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3IHR5cGUoKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRlY29kZShieXRlcywgaXRfMik7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE1lc3NhZ2UodHlwZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSBleHBvcnRzLlByb3RvY29sLlJPT01fU1RBVEUpIHtcbiAgICAgICAgICAgICAgICBieXRlcy5zaGlmdCgpOyAvLyBkcm9wIGBjb2RlYCBieXRlXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSBleHBvcnRzLlByb3RvY29sLlJPT01fU1RBVEVfUEFUQ0gpIHtcbiAgICAgICAgICAgICAgICBieXRlcy5zaGlmdCgpOyAvLyBkcm9wIGBjb2RlYCBieXRlXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaChieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSBleHBvcnRzLlByb3RvY29sLlJPT01fREFUQSkge1xuICAgICAgICAgICAgICAgIHZhciBpdF8zID0geyBvZmZzZXQ6IDEgfTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9ICh1bWQuZGVjb2RlLnN0cmluZ0NoZWNrKGJ5dGVzLCBpdF8zKSlcbiAgICAgICAgICAgICAgICAgICAgPyB1bWQuZGVjb2RlLnN0cmluZyhieXRlcywgaXRfMylcbiAgICAgICAgICAgICAgICAgICAgOiB1bWQuZGVjb2RlLm51bWJlcihieXRlcywgaXRfMyk7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAoYnl0ZXMubGVuZ3RoID4gaXRfMy5vZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgID8gZGVjb2RlKGV2ZW50LmRhdGEsIGl0XzMub2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoTWVzc2FnZSh0eXBlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUm9vbS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoZW5jb2RlZFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZXIuc2V0U3RhdGUoZW5jb2RlZFN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMub25TdGF0ZUNoYW5nZS5pbnZva2UodGhpcy5zZXJpYWxpemVyLmdldFN0YXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBSb29tLnByb3RvdHlwZS5wYXRjaCA9IGZ1bmN0aW9uIChiaW5hcnlQYXRjaCkge1xuICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVyLnBhdGNoKGJpbmFyeVBhdGNoKTtcbiAgICAgICAgICAgIHRoaXMub25TdGF0ZUNoYW5nZS5pbnZva2UodGhpcy5zZXJpYWxpemVyLmdldFN0YXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBSb29tLnByb3RvdHlwZS5kaXNwYXRjaE1lc3NhZ2UgPSBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VUeXBlID0gdGhpcy5nZXRNZXNzYWdlSGFuZGxlcktleSh0eXBlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uTWVzc2FnZUhhbmRsZXJzLmV2ZW50c1ttZXNzYWdlVHlwZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZUhhbmRsZXJzLmVtaXQobWVzc2FnZVR5cGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vbk1lc3NhZ2VIYW5kbGVycy5ldmVudHNbJyonXSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25NZXNzYWdlSGFuZGxlcnMuZW1pdCgnKicsIHR5cGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiY29seXNldXMuanM6IG9uTWVzc2FnZSgpIG5vdCByZWdpc3RlcmVkIGZvciB0eXBlICdcIiArIHR5cGUgKyBcIicuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSb29tLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VyaWFsaXplcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplci50ZWFyZG93bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSb29tLnByb3RvdHlwZS5nZXRNZXNzYWdlSGFuZGxlcktleSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiAodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyB0eXBlb2YgU2NoZW1hXG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBcIiRcIiArIHR5cGUuX3R5cGVpZDtcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmdcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiB0eXBlO1xuICAgICAgICAgICAgICAgIC8vIG51bWJlclxuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjogcmV0dXJuIFwiaVwiICsgdHlwZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG1lc3NhZ2UgdHlwZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSb29tO1xuICAgIH0oKSk7XG5cbiAgICAvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vdHlwaW5ncy9jb2Nvcy1jcmVhdG9yLmQudHNcIiAvPlxuICAgIC8qKlxuICAgICAqIFdlIGRvIG5vdCBhc3NpZ24gJ3N0b3JhZ2UnIHRvIHdpbmRvdy5sb2NhbFN0b3JhZ2UgaW1tZWRpYXRlbGx5IGZvciBSZWFjdFxuICAgICAqIE5hdGl2ZSBjb21wYXRpYmlsaXR5LiB3aW5kb3cubG9jYWxTdG9yYWdlIGlzIG5vdCBwcmVzZW50IHdoZW4gdGhpcyBtb2R1bGUgaXNcbiAgICAgKiBsb2FkZWQuXG4gICAgICovXG4gICAgdmFyIHN0b3JhZ2U7XG4gICAgZnVuY3Rpb24gZ2V0U3RvcmFnZSgpIHtcbiAgICAgICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICAgICAgICBzdG9yYWdlID0gKHR5cGVvZiAoY2MpICE9PSAndW5kZWZpbmVkJyAmJiBjYy5zeXMgJiYgY2Muc3lzLmxvY2FsU3RvcmFnZSlcbiAgICAgICAgICAgICAgICA/IGNjLnN5cy5sb2NhbFN0b3JhZ2UgLy8gY29tcGF0aWJpbGl0eSB3aXRoIGNvY29zIGNyZWF0b3JcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiAod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYWxTdG9yYWdlIC8vUk4gZG9lcyBoYXZlIHdpbmRvdyBvYmplY3QgYXQgdGhpcyBwb2ludCwgYnV0IGxvY2FsU3RvcmFnZSBpcyBub3QgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHdpbmRvdy5sb2NhbFN0b3JhZ2UgLy8gcmVndWxhciBicm93c2VyIGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXRlbTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsgdGhpcy5jYWNoZVtrZXldID0gdmFsdWU7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRJdGVtOiBmdW5jdGlvbiAoa2V5KSB7IHRoaXMuY2FjaGVba2V5XTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIChrZXkpIHsgZGVsZXRlIHRoaXMuY2FjaGVba2V5XTsgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmFnZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgICAgIGdldFN0b3JhZ2UoKS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVJdGVtKGtleSkge1xuICAgICAgICBnZXRTdG9yYWdlKCkucmVtb3ZlSXRlbShrZXkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJdGVtKGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0U3RvcmFnZSgpLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiAoUHJvbWlzZSkgPT09ICd1bmRlZmluZWQnIHx8IC8vIG9sZCBicm93c2Vyc1xuICAgICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICAvLyBicm93c2VyIGhhcyBzeW5jaHJvbm91cyByZXR1cm5cbiAgICAgICAgICAgIGNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlYWN0LW5hdGl2ZSBpcyBhc3luY2hyb25vdXNcbiAgICAgICAgICAgIHZhbHVlLnRoZW4oZnVuY3Rpb24gKGlkKSB7IHJldHVybiBjYWxsYmFjayhpZCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFRPS0VOX1NUT1JBR0UgPSBcImNvbHlzZXVzLWF1dGgtdG9rZW5cIjtcbiAgICBleHBvcnRzLlBsYXRmb3JtID0gdm9pZCAwO1xuICAgIChmdW5jdGlvbiAoUGxhdGZvcm0pIHtcbiAgICAgICAgUGxhdGZvcm1bXCJpb3NcIl0gPSBcImlvc1wiO1xuICAgICAgICBQbGF0Zm9ybVtcImFuZHJvaWRcIl0gPSBcImFuZHJvaWRcIjtcbiAgICB9KShleHBvcnRzLlBsYXRmb3JtIHx8IChleHBvcnRzLlBsYXRmb3JtID0ge30pKTtcbiAgICB2YXIgQXV0aCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQXV0aChlbmRwb2ludCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2lkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy51c2VybmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmF2YXRhclVybCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuaXNBbm9ueW1vdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmVtYWlsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5sYW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudGltZXpvbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5kZXZpY2VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5mYWNlYm9va0lkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50d2l0dGVySWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmdvb2dsZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5nYW1lQ2VudGVySWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnN0ZWFtSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmZyaWVuZElkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tlZFVzZXJJZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlZEF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gYXV0aCB0b2tlblxuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludC5yZXBsYWNlKFwid3NcIiwgXCJodHRwXCIpO1xuICAgICAgICAgICAgZ2V0SXRlbShUT0tFTl9TVE9SQUdFLCBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIF90aGlzLnRva2VuID0gdG9rZW47IH0pO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdXRoLnByb3RvdHlwZSwgXCJoYXNUb2tlblwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLnRva2VuO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBBdXRoLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeVBhcmFtcywgZGF0YSwgYXR0cjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnRva2VuID0gdGhpcy50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KCdwb3N0JywgJy9hdXRoJywgcXVlcnlQYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCAmIGNhY2hlIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbiA9IGRhdGEudG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXRlbShUT0tFTl9TVE9SQUdFLCB0aGlzLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGF0dHIgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1thdHRyXSA9IGRhdGFbYXR0cl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlclBpbmdTZXJ2aWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXV0aC5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KCdwdXQnLCAnL2F1dGgnLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IHRoaXMuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YXRhclVybDogdGhpcy5hdmF0YXJVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmc6IHRoaXMubGFuZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHRoaXMubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWV6b25lOiB0aGlzLnRpbWV6b25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXV0aC5wcm90b3R5cGUuZ2V0RnJpZW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KCdnZXQnLCAnL2ZyaWVuZHMvYWxsJyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXV0aC5wcm90b3R5cGUuZ2V0T25saW5lRnJpZW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KCdnZXQnLCAnL2ZyaWVuZHMvb25saW5lJyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXV0aC5wcm90b3R5cGUuZ2V0RnJpZW5kUmVxdWVzdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVxdWVzdCgnZ2V0JywgJy9mcmllbmRzL3JlcXVlc3RzJyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXV0aC5wcm90b3R5cGUuc2VuZEZyaWVuZFJlcXVlc3QgPSBmdW5jdGlvbiAoZnJpZW5kSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KCdwb3N0JywgJy9mcmllbmRzL3JlcXVlc3RzJywgeyB1c2VySWQ6IGZyaWVuZElkIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEF1dGgucHJvdG90eXBlLmFjY2VwdEZyaWVuZFJlcXVlc3QgPSBmdW5jdGlvbiAoZnJpZW5kSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KCdwdXQnLCAnL2ZyaWVuZHMvcmVxdWVzdHMnLCB7IHVzZXJJZDogZnJpZW5kSWQgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXV0aC5wcm90b3R5cGUuZGVjbGluZUZyaWVuZFJlcXVlc3QgPSBmdW5jdGlvbiAoZnJpZW5kSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KCdkZWwnLCAnL2ZyaWVuZHMvcmVxdWVzdHMnLCB7IHVzZXJJZDogZnJpZW5kSWQgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnNlbnQoKSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXV0aC5wcm90b3R5cGUuYmxvY2tVc2VyID0gZnVuY3Rpb24gKGZyaWVuZElkKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVxdWVzdCgncG9zdCcsICcvZnJpZW5kcy9ibG9jaycsIHsgdXNlcklkOiBmcmllbmRJZCB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS51bmJsb2NrVXNlciA9IGZ1bmN0aW9uIChmcmllbmRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3QoJ3B1dCcsICcvZnJpZW5kcy9ibG9jaycsIHsgdXNlcklkOiBmcmllbmRJZCB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2Euc2VudCgpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgc2VnbWVudHMsIHF1ZXJ5LCBib2R5LCBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAocXVlcnkgPT09IHZvaWQgMCkgeyBxdWVyeSA9IHt9OyB9XG4gICAgICAgICAgICBpZiAoaGVhZGVycyA9PT0gdm9pZCAwKSB7IGhlYWRlcnMgPSB7fTsgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeVBhcmFtcywgbmFtZV8xLCBxdWVyeVN0cmluZywgb3B0cztcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmVhcmVyICcgKyB0aGlzLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobmFtZV8xIGluIHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnB1c2gobmFtZV8xICsgXCI9XCIgKyBxdWVyeVtuYW1lXzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSAocXVlcnlQYXJhbXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIj9cIiArIHF1ZXJ5UGFyYW1zLmpvaW4oXCImXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IHsgaGVhZGVyczogaGVhZGVycyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGh0dHBbbWV0aG9kXShcIlwiICsgdGhpcy5lbmRwb2ludCArIHNlZ21lbnRzICsgcXVlcnlTdHJpbmcsIG9wdHMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpLmRhdGFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXV0aC5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlbW92ZUl0ZW0oVE9LRU5fU1RPUkFHRSk7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJQaW5nU2VydmljZSgpO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS5yZWdpc3RlclBpbmdTZXJ2aWNlID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7IHRpbWVvdXQgPSAxNTAwMDsgfVxuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyUGluZ1NlcnZpY2UoKTtcbiAgICAgICAgICAgIHRoaXMua2VlcE9ubGluZUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVxdWVzdCgnZ2V0JywgJy9hdXRoJyk7IH0sIHRpbWVvdXQpO1xuICAgICAgICB9O1xuICAgICAgICBBdXRoLnByb3RvdHlwZS51bnJlZ2lzdGVyUGluZ1NlcnZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMua2VlcE9ubGluZUludGVydmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEF1dGg7XG4gICAgfSgpKTtcblxuICAgIHZhciBfYTtcbiAgICB2YXIgTWF0Y2hNYWtlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhNYXRjaE1ha2VFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTWF0Y2hNYWtlRXJyb3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNYXRjaE1ha2VFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRjaE1ha2VFcnJvcjtcbiAgICB9KEVycm9yKSk7XG4gICAgLy8gLSBSZWFjdCBOYXRpdmUgZG9lcyBub3QgcHJvdmlkZSBgd2luZG93LmxvY2F0aW9uYFxuICAgIC8vIC0gQ29jb3MgQ3JlYXRvciAoTmF0aXZlKSBkb2VzIG5vdCBwcm92aWRlIGB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWVgIFxuICAgIHZhciBERUZBVUxUX0VORFBPSU5UID0gKHR5cGVvZiAod2luZG93KSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgKChfYSA9IHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhvc3RuYW1lKSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgPyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wucmVwbGFjZShcImh0dHBcIiwgXCJ3c1wiKSArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSArICh3aW5kb3cubG9jYXRpb24ucG9ydCAmJiBcIjpcIiArIHdpbmRvdy5sb2NhdGlvbi5wb3J0KVxuICAgICAgICA6IFwid3M6Ly8xMjcuMC4wLjE6MjU2N1wiO1xuICAgIHZhciBDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENsaWVudChlbmRwb2ludCkge1xuICAgICAgICAgICAgaWYgKGVuZHBvaW50ID09PSB2b2lkIDApIHsgZW5kcG9pbnQgPSBERUZBVUxUX0VORFBPSU5UOyB9XG4gICAgICAgICAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsaWVudC5wcm90b3R5cGUsIFwiYXV0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2F1dGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aCA9IG5ldyBBdXRoKHRoaXMuZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXV0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5qb2luT3JDcmVhdGUgPSBmdW5jdGlvbiAocm9vbU5hbWUsIG9wdGlvbnMsIHJvb3RTY2hlbWEpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY3JlYXRlTWF0Y2hNYWtlUmVxdWVzdCgnam9pbk9yQ3JlYXRlJywgcm9vbU5hbWUsIG9wdGlvbnMsIHJvb3RTY2hlbWEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDbGllbnQucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChyb29tTmFtZSwgb3B0aW9ucywgcm9vdFNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jcmVhdGVNYXRjaE1ha2VSZXF1ZXN0KCdjcmVhdGUnLCByb29tTmFtZSwgb3B0aW9ucywgcm9vdFNjaGVtYSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENsaWVudC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIChyb29tTmFtZSwgb3B0aW9ucywgcm9vdFNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jcmVhdGVNYXRjaE1ha2VSZXF1ZXN0KCdqb2luJywgcm9vbU5hbWUsIG9wdGlvbnMsIHJvb3RTY2hlbWEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDbGllbnQucHJvdG90eXBlLmpvaW5CeUlkID0gZnVuY3Rpb24gKHJvb21JZCwgb3B0aW9ucywgcm9vdFNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jcmVhdGVNYXRjaE1ha2VSZXF1ZXN0KCdqb2luQnlJZCcsIHJvb21JZCwgb3B0aW9ucywgcm9vdFNjaGVtYSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENsaWVudC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKHJvb21JZCwgc2Vzc2lvbklkLCByb290U2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY3JlYXRlTWF0Y2hNYWtlUmVxdWVzdCgnam9pbkJ5SWQnLCByb29tSWQsIHsgc2Vzc2lvbklkOiBzZXNzaW9uSWQgfSwgcm9vdFNjaGVtYSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENsaWVudC5wcm90b3R5cGUuZ2V0QXZhaWxhYmxlUm9vbXMgPSBmdW5jdGlvbiAocm9vbU5hbWUpIHtcbiAgICAgICAgICAgIGlmIChyb29tTmFtZSA9PT0gdm9pZCAwKSB7IHJvb21OYW1lID0gXCJcIjsgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB1cmw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gdGhpcy5lbmRwb2ludC5yZXBsYWNlKFwid3NcIiwgXCJodHRwXCIpICsgXCIvbWF0Y2htYWtlL1wiICsgcm9vbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0XzEodXJsLCB7IGhlYWRlcnM6IHsgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyB9IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpLmRhdGFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5jb25zdW1lU2VhdFJlc2VydmF0aW9uID0gZnVuY3Rpb24gKHJlc3BvbnNlLCByb290U2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb207XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICByb29tID0gdGhpcy5jcmVhdGVSb29tKHJlc3BvbnNlLnJvb20ubmFtZSwgcm9vdFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIHJvb20uaWQgPSByZXNwb25zZS5yb29tLnJvb21JZDtcbiAgICAgICAgICAgICAgICAgICAgcm9vbS5zZXNzaW9uSWQgPSByZXNwb25zZS5zZXNzaW9uSWQ7XG4gICAgICAgICAgICAgICAgICAgIHJvb20uY29ubmVjdCh0aGlzLmJ1aWxkRW5kcG9pbnQocmVzcG9uc2Uucm9vbSwgeyBzZXNzaW9uSWQ6IHJvb20uc2Vzc2lvbklkIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIChjb2RlLCBtZXNzYWdlKSB7IHJldHVybiByZWplY3QobmV3IFNlcnZlckVycm9yKGNvZGUsIG1lc3NhZ2UpKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb29tLm9uRXJyb3Iub25jZShvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb29tWydvbkpvaW4nXS5vbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vbS5vbkVycm9yLnJlbW92ZShvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyb29tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBDbGllbnQucHJvdG90eXBlLmNyZWF0ZU1hdGNoTWFrZVJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCByb29tTmFtZSwgb3B0aW9ucywgcm9vdFNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJsLCByZXNwb25zZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmVuZHBvaW50LnJlcGxhY2UoXCJ3c1wiLCBcImh0dHBcIikgKyBcIi9tYXRjaG1ha2UvXCIgKyBtZXRob2QgKyBcIi9cIiArIHJvb21OYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZm9yd2FyZCBhdXRoIHRva2VuLCBpZiBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F1dGggJiYgdGhpcy5fYXV0aC5oYXNUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRva2VuID0gdGhpcy5fYXV0aC50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcG9zdF8xKHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IChfYS5zZW50KCkpLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNYXRjaE1ha2VFcnJvcihyZXNwb25zZS5lcnJvciwgcmVzcG9uc2UuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmNvbnN1bWVTZWF0UmVzZXJ2YXRpb24ocmVzcG9uc2UsIHJvb3RTY2hlbWEpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENsaWVudC5wcm90b3R5cGUuY3JlYXRlUm9vbSA9IGZ1bmN0aW9uIChyb29tTmFtZSwgcm9vdFNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSb29tKHJvb21OYW1lLCByb290U2NoZW1hKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2xpZW50LnByb3RvdHlwZS5idWlsZEVuZHBvaW50ID0gZnVuY3Rpb24gKHJvb20sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChuYW1lXzEgKyBcIj1cIiArIG9wdGlvbnNbbmFtZV8xXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmRwb2ludCArIFwiL1wiICsgcm9vbS5wcm9jZXNzSWQgKyBcIi9cIiArIHJvb20ucm9vbUlkICsgXCI/XCIgKyBwYXJhbXMuam9pbignJicpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2xpZW50O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgU2NoZW1hU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2NoZW1hU2VyaWFsaXplcigpIHtcbiAgICAgICAgfVxuICAgICAgICBTY2hlbWFTZXJpYWxpemVyLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChyYXdTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5kZWNvZGUocmF3U3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBTY2hlbWFTZXJpYWxpemVyLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICAgICAgICB9O1xuICAgICAgICBTY2hlbWFTZXJpYWxpemVyLnByb3RvdHlwZS5wYXRjaCA9IGZ1bmN0aW9uIChwYXRjaGVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmRlY29kZShwYXRjaGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NoZW1hU2VyaWFsaXplci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5zdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyckY2hhbmdlcyddKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iucm9vdC5jbGVhclJlZnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NoZW1hU2VyaWFsaXplci5wcm90b3R5cGUuaGFuZHNoYWtlID0gZnVuY3Rpb24gKGJ5dGVzLCBpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyB2YWxpZGF0ZSBjbGllbnQvc2VydmVyIGRlZmluaXRpbm9zXG4gICAgICAgICAgICAgICAgdmFyIHJlZmxlY3Rpb24gPSBuZXcgdW1kLlJlZmxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICByZWZsZWN0aW9uLmRlY29kZShieXRlcywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSByZWZsZWN0ZWQgc3RhdGUgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdW1kLlJlZmxlY3Rpb24uZGVjb2RlKGJ5dGVzLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTY2hlbWFTZXJpYWxpemVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgTm9uZVNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5vbmVTZXJpYWxpemVyKCkge1xuICAgICAgICB9XG4gICAgICAgIE5vbmVTZXJpYWxpemVyLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChyYXdTdGF0ZSkgeyB9O1xuICAgICAgICBOb25lU2VyaWFsaXplci5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICBOb25lU2VyaWFsaXplci5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbiAocGF0Y2hlcykgeyB9O1xuICAgICAgICBOb25lU2VyaWFsaXplci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIE5vbmVTZXJpYWxpemVyLnByb3RvdHlwZS5oYW5kc2hha2UgPSBmdW5jdGlvbiAoYnl0ZXMpIHsgfTtcbiAgICAgICAgcmV0dXJuIE5vbmVTZXJpYWxpemVyO1xuICAgIH0oKSk7XG5cbiAgICByZWdpc3RlclNlcmlhbGl6ZXIoJ3NjaGVtYScsIFNjaGVtYVNlcmlhbGl6ZXIpO1xuICAgIHJlZ2lzdGVyU2VyaWFsaXplcignbm9uZScsIE5vbmVTZXJpYWxpemVyKTtcblxuICAgIGV4cG9ydHMuQXV0aCA9IEF1dGg7XG4gICAgZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG4gICAgZXhwb3J0cy5Sb29tID0gUm9vbTtcbiAgICBleHBvcnRzLlNjaGVtYVNlcmlhbGl6ZXIgPSBTY2hlbWFTZXJpYWxpemVyO1xuICAgIGV4cG9ydHMucmVnaXN0ZXJTZXJpYWxpemVyID0gcmVnaXN0ZXJTZXJpYWxpemVyO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbHlzZXVzLmpzLm1hcFxuIiwiLyoqXG4gKiBBIHNpbXBsZSBldmVudCBzeXN0ZW0uIEFsbG93cyB5b3UgdG8gaG9vayBpbnRvIEtvbnRyYSBsaWZlY3ljbGUgZXZlbnRzIG9yIGNyZWF0ZSB5b3VyIG93biwgc3VjaCBhcyBmb3IgW1BsdWdpbnNdKGFwaS9wbHVnaW4pLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBvbiwgb2ZmLCBlbWl0IH0gZnJvbSAna29udHJhJztcbiAqXG4gKiBmdW5jdGlvbiBjYWxsYmFjayhhLCBiLCBjKSB7XG4gKiAgIGNvbnNvbGUubG9nKHthLCBiLCBjfSk7XG4gKiB9KTtcbiAqXG4gKiBvbignbXlFdmVudCcsIGNhbGxiYWNrKTtcbiAqIGVtaXQoJ215RXZlbnQnLCAxLCAyLCAzKTsgIC8vPT4ge2E6IDEsIGI6IDIsIGM6IDN9XG4gKiBvZmYoJ215RXZlbnQnLCBjYWxsYmFjayk7XG4gKiBgYGBcbiAqIEBzZWN0aW9uTmFtZSBFdmVudHNcbiAqL1xuXG4vLyBleHBvc2UgZm9yIHRlc3RpbmdcbmxldCBjYWxsYmFja3MgPSB7fTtcblxuLyoqXG4gKiBUaGVyZSBhcmUgY3VycmVudGx5IG9ubHkgdGhyZWUgbGlmZWN5Y2xlIGV2ZW50czpcbiAqIC0gYGluaXRgIC0gRW1pdHRlZCBhZnRlciBga29udHJhLmluaXQoKWAgaXMgY2FsbGVkLlxuICogLSBgdGlja2AgLSBFbWl0dGVkIGV2ZXJ5IGZyYW1lIG9mIFtHYW1lTG9vcF0oYXBpL2dhbWVMb29wKSBiZWZvcmUgdGhlIGxvb3BzIGB1cGRhdGUoKWAgYW5kIGByZW5kZXIoKWAgZnVuY3Rpb25zIGFyZSBjYWxsZWQuXG4gKiAtIGBhc3NldExvYWRlZGAgLSBFbWl0dGVkIGFmdGVyIGFuIGFzc2V0IGhhcyBmdWxseSBsb2FkZWQgdXNpbmcgdGhlIGFzc2V0IGxvYWRlci4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgYXNzZXQgYW5kIHRoZSB1cmwgb2YgdGhlIGFzc2V0IGFzIHBhcmFtZXRlcnMuXG4gKiBAc2VjdGlvbk5hbWUgTGlmZWN5Y2xlIEV2ZW50c1xuICovXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmb3IgYW4gZXZlbnQgdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBldmVudCBpcyBlbWl0dGVkLiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBwYXNzZWQgYWxsIGFyZ3VtZW50cyB1c2VkIGluIHRoZSBgZW1pdGAgY2FsbC5cbiAqIEBmdW5jdGlvbiBvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIE5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuXG4gKi9cbmZ1bmN0aW9uIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICBjYWxsYmFja3NbZXZlbnRdID0gY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbiAgY2FsbGJhY2tzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBjYWxsYmFjayBmb3IgYW4gZXZlbnQuXG4gKiBAZnVuY3Rpb24gb2ZmXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gTmFtZSBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0aGF0IHdhcyBwYXNzZWQgZHVyaW5nIHJlZ2lzdHJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gb2ZmKGV2ZW50LCBjYWxsYmFjaykge1xuICBjYWxsYmFja3NbZXZlbnRdID0gKGNhbGxiYWNrc1tldmVudF0gfHwgW10pLmZpbHRlcihmbiA9PiBmbiAhPSBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogQ2FsbCBhbGwgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgZXZlbnQuIEFsbCBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIEBmdW5jdGlvbiBlbWl0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gTmFtZSBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgLSBDb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIGFsbCBjYWxsYmFja3MuXG4gKi9cbmZ1bmN0aW9uIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgKGNhbGxiYWNrc1tldmVudF0gfHwgW10pLm1hcChmbiA9PiBmbiguLi5hcmdzKSk7XG59XG5cbi8qKlxuICogRnVuY3Rpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIEtvbnRyYSBsaWJyYXJ5IGFuZCBnZXR0aW5nIHRoZSBjYW52YXMgYW5kIGNvbnRleHRcbiAqIG9iamVjdHMuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IGdldENhbnZhcywgZ2V0Q29udGV4dCwgaW5pdCB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogbGV0IHsgY2FudmFzLCBjb250ZXh0IH0gPSBpbml0KCk7XG4gKlxuICogLy8gb3IgY2FuIGdldCBjYW52YXMgYW5kIGNvbnRleHQgdGhyb3VnaCBmdW5jdGlvbnNcbiAqIGNhbnZhcyA9IGdldENhbnZhcygpO1xuICogY29udGV4dCA9IGdldENvbnRleHQoKTtcbiAqIGBgYFxuICogQHNlY3Rpb25OYW1lIENvcmVcbiAqL1xuXG5sZXQgY2FudmFzRWwsIGNvbnRleHQ7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjYW52YXMgZWxlbWVudC5cbiAqIEBmdW5jdGlvbiBnZXRDYW52YXNcbiAqXG4gKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9IFRoZSBjYW52YXMgZWxlbWVudCBmb3IgdGhlIGdhbWUuXG4gKi9cbmZ1bmN0aW9uIGdldENhbnZhcygpIHtcbiAgcmV0dXJuIGNhbnZhc0VsO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgY29udGV4dCBvYmplY3QuXG4gKiBAZnVuY3Rpb24gZ2V0Q29udGV4dFxuICpcbiAqIEByZXR1cm5zIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjb250ZXh0IG9iamVjdCB0aGUgZ2FtZSBkcmF3cyB0by5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgbGlicmFyeSBhbmQgc2V0IHVwIHRoZSBjYW52YXMuIFR5cGljYWxseSB5b3Ugd2lsbCBjYWxsIGBpbml0KClgIGFzIHRoZSBmaXJzdCB0aGluZyBhbmQgZ2l2ZSBpdCB0aGUgY2FudmFzIHRvIHVzZS4gVGhpcyB3aWxsIGFsbG93IGFsbCBLb250cmEgb2JqZWN0cyB0byByZWZlcmVuY2UgdGhlIGNhbnZhcyB3aGVuIGNyZWF0ZWQuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IGluaXQgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIGxldCB7IGNhbnZhcywgY29udGV4dCB9ID0gaW5pdCgnZ2FtZScpO1xuICogYGBgXG4gKiBAZnVuY3Rpb24gaW5pdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEhUTUxDYW52YXNFbGVtZW50fSBbY2FudmFzXSAtIFRoZSBjYW52YXMgZm9yIEtvbnRyYSB0byB1c2UuIENhbiBlaXRoZXIgYmUgdGhlIElEIG9mIHRoZSBjYW52YXMgZWxlbWVudCBvciB0aGUgY2FudmFzIGVsZW1lbnQgaXRzZWxmLiBEZWZhdWx0cyB0byB1c2luZyB0aGUgZmlyc3QgY2FudmFzIGVsZW1lbnQgb24gdGhlIHBhZ2UuXG4gKlxuICogQHJldHVybnMge3tjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9fSBBbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGBjYW52YXNgIGFuZCBgY29udGV4dGAuIGBjYW52YXNgIGl0IHRoZSBjYW52YXMgZWxlbWVudCBmb3IgdGhlIGdhbWUgYW5kIGBjb250ZXh0YCBpcyB0aGUgY29udGV4dCBvYmplY3QgdGhlIGdhbWUgZHJhd3MgdG8uXG4gKi9cbmZ1bmN0aW9uIGluaXQoY2FudmFzKSB7XG5cbiAgLy8gY2hlY2sgaWYgY2FudmFzIGlzIGEgc3RyaW5nIGZpcnN0LCBhbiBlbGVtZW50IG5leHQsIG9yIGRlZmF1bHQgdG8gZ2V0dGluZ1xuICAvLyBmaXJzdCBjYW52YXMgb24gcGFnZVxuICBjYW52YXNFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcykgfHxcbiAgICAgICAgICAgICBjYW52YXMgfHxcbiAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcblxuICAvLyBAaWZkZWYgREVCVUdcbiAgaWYgKCFjYW52YXNFbCkge1xuICAgIHRocm93IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGEgY2FudmFzIGVsZW1lbnQgZm9yIHRoZSBnYW1lJyk7XG4gIH1cbiAgLy8gQGVuZGlmXG5cbiAgY29udGV4dCA9IGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG5cbiAgZW1pdCgnaW5pdCcpO1xuXG4gIHJldHVybiB7IGNhbnZhczogY2FudmFzRWwsIGNvbnRleHQgfTtcbn1cblxuLyoqXG4gKiBBbiBvYmplY3QgZm9yIGRyYXdpbmcgc3ByaXRlIHNoZWV0IGFuaW1hdGlvbnMuXG4gKlxuICogQW4gYW5pbWF0aW9uIGRlZmluZXMgdGhlIHNlcXVlbmNlIG9mIGZyYW1lcyB0byB1c2UgZnJvbSBhIHNwcml0ZSBzaGVldC4gSXQgYWxzbyBkZWZpbmVzIGF0IHdoYXQgc3BlZWQgdGhlIGFuaW1hdGlvbiBzaG91bGQgcnVuIHVzaW5nIGBmcmFtZVJhdGVgLlxuICpcbiAqIFR5cGljYWxseSB5b3UgZG9uJ3QgY3JlYXRlIGFuIEFuaW1hdGlvbiBkaXJlY3RseSwgYnV0IHJhdGhlciB5b3Ugd291bGQgY3JlYXRlIHRoZW0gZnJvbSBhIFtTcHJpdGVTaGVldF0oYXBpL3Nwcml0ZVNoZWV0KSBieSBwYXNzaW5nIHRoZSBgYW5pbWF0aW9uc2AgYXJndW1lbnQuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IFNwcml0ZVNoZWV0LCBBbmltYXRpb24gfSBmcm9tICdrb250cmEnO1xuICpcbiAqIGxldCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICogaW1hZ2Uuc3JjID0gJ2Fzc2V0cy9pbWdzL2NoYXJhY3Rlcl93YWxrX3NoZWV0LnBuZyc7XG4gKiBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAqICAgbGV0IHNwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXQoe1xuICogICAgIGltYWdlOiBpbWFnZSxcbiAqICAgICBmcmFtZVdpZHRoOiA3MixcbiAqICAgICBmcmFtZUhlaWdodDogOTdcbiAqICAgfSk7XG4gKlxuICogICAvLyB5b3UgdHlwaWNhbGx5IHdvdWxkbid0IGNyZWF0ZSBhbiBBbmltYXRpb24gdGhpcyB3YXlcbiAqICAgbGV0IGFuaW1hdGlvbiA9IEFuaW1hdGlvbih7XG4gKiAgICAgc3ByaXRlU2hlZXQ6IHNwcml0ZVNoZWV0LFxuICogICAgIGZyYW1lczogWzEsMiwzLDZdLFxuICogICAgIGZyYW1lUmF0ZTogMzBcbiAqICAgfSk7XG4gKiB9O1xuICogYGBgXG4gKiBAY2xhc3MgQW5pbWF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBQcm9wZXJ0aWVzIG9mIHRoZSBhbmltYXRpb24uXG4gKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBwcm9wZXJ0aWVzLnNwcml0ZVNoZWV0IC0gU3ByaXRlIHNoZWV0IGZvciB0aGUgYW5pbWF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gcHJvcGVydGllcy5mcmFtZXMgLSBMaXN0IG9mIGZyYW1lcyBvZiB0aGUgYW5pbWF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9ICBwcm9wZXJ0aWVzLmZyYW1lUmF0ZSAtIE51bWJlciBvZiBmcmFtZXMgdG8gZGlzcGxheSBpbiBvbmUgc2Vjb25kLlxuICogQHBhcmFtIHtCb29sZWFufSBbcHJvcGVydGllcy5sb29wPXRydWVdIC0gSWYgdGhlIGFuaW1hdGlvbiBzaG91bGQgbG9vcC5cbiAqL1xuY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3Ioe3Nwcml0ZVNoZWV0LCBmcmFtZXMsIGZyYW1lUmF0ZSwgbG9vcCA9IHRydWV9KSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3ByaXRlIHNoZWV0IHRvIHVzZSBmb3IgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uXG4gICAgICogQHByb3BlcnR5IHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXRcbiAgICAgKi9cbiAgICB0aGlzLnNwcml0ZVNoZWV0ID0gc3ByaXRlU2hlZXQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXF1ZW5jZSBvZiBmcmFtZXMgdG8gdXNlIGZyb20gdGhlIHNwcml0ZSBzaGVldC5cbiAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJbXX0gZnJhbWVzXG4gICAgICovXG4gICAgdGhpcy5mcmFtZXMgPSBmcmFtZXM7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgZnJhbWVzIHRvIGRpc3BsYXkgcGVyIHNlY29uZC4gQWRqdXN0aW5nIHRoaXMgdmFsdWUgd2lsbCBjaGFuZ2UgdGhlIHNwZWVkIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICogQG1lbWJlcm9mIEFuaW1hdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBmcmFtZVJhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lUmF0ZSA9IGZyYW1lUmF0ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBhbmltYXRpb24gc2hvdWxkIGxvb3AgYmFjayB0byB0aGUgYmVnaW5uaW5nIG9uY2UgY29tcGxldGVkLlxuICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGxvb3BcbiAgICAgKi9cbiAgICB0aGlzLmxvb3AgPSBsb29wO1xuXG4gICAgbGV0IHsgd2lkdGgsIGhlaWdodCwgbWFyZ2luID0gMCB9ID0gc3ByaXRlU2hlZXQuZnJhbWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgYW4gaW5kaXZpZHVhbCBmcmFtZS4gVGFrZW4gZnJvbSB0aGUgW2ZyYW1lIHdpZHRoIHZhbHVlXShhcGkvc3ByaXRlU2hlZXQjZnJhbWUpIG9mIHRoZSBzcHJpdGUgc2hlZXQuXG4gICAgICogQG1lbWJlcm9mIEFuaW1hdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB3aWR0aFxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgYW4gaW5kaXZpZHVhbCBmcmFtZS4gVGFrZW4gZnJvbSB0aGUgW2ZyYW1lIGhlaWdodCB2YWx1ZV0oYXBpL3Nwcml0ZVNoZWV0I2ZyYW1lKSBvZiB0aGUgc3ByaXRlIHNoZWV0LlxuICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3BhY2UgYmV0d2VlbiBlYWNoIGZyYW1lLiBUYWtlbiBmcm9tIHRoZSBbZnJhbWUgbWFyZ2luIHZhbHVlXShhcGkvc3ByaXRlU2hlZXQjZnJhbWUpIG9mIHRoZSBzcHJpdGUgc2hlZXQuXG4gICAgICogQG1lbWJlcm9mIEFuaW1hdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXJnaW5cbiAgICAgKi9cbiAgICB0aGlzLm1hcmdpbiA9IG1hcmdpbjtcblxuICAgIC8vIGYgPSBmcmFtZSwgYSA9IGFjY3VtdWxhdG9yXG4gICAgdGhpcy5fZiA9IDA7XG4gICAgdGhpcy5fYSA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgYW4gYW5pbWF0aW9uIHNvIGl0IGNhbiBiZSB1c2VkIG1vcmUgdGhhbiBvbmNlLiBCeSBkZWZhdWx0IGFuaW1hdGlvbnMgcGFzc2VkIHRvIFtTcHJpdGVdKGFwaS9zcHJpdGUpIHdpbGwgYmUgY2xvbmVkIHNvIG5vIHR3byBzcHJpdGVzIHVwZGF0ZSB0aGUgc2FtZSBhbmltYXRpb24uIE90aGVyd2lzZSB0d28gc3ByaXRlcyB3aG8gc2hhcmVkIHRoZSBzYW1lIGFuaW1hdGlvbiB3b3VsZCBtYWtlIGl0IHVwZGF0ZSB0d2ljZSBhcyBmYXN0LlxuICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uXG4gICAqIEBmdW5jdGlvbiBjbG9uZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QW5pbWF0aW9ufSBBIG5ldyBBbmltYXRpb24gaW5zdGFuY2UuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvbih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBhbiBhbmltYXRpb24gdG8gdGhlIGZpcnN0IGZyYW1lLlxuICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uXG4gICAqIEBmdW5jdGlvbiByZXNldFxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fZiA9IDA7XG4gICAgdGhpcy5fYSA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhbmltYXRpb24uXG4gICAqIEBtZW1iZXJvZiBBbmltYXRpb25cbiAgICogQGZ1bmN0aW9uIHVwZGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R0PTEvNjBdIC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZShkdCA9IDEvNjApIHtcblxuICAgIC8vIGlmIHRoZSBhbmltYXRpb24gZG9lc24ndCBsb29wIHdlIHN0b3AgYXQgdGhlIGxhc3QgZnJhbWVcbiAgICBpZiAoIXRoaXMubG9vcCAmJiB0aGlzLl9mID09IHRoaXMuZnJhbWVzLmxlbmd0aC0xKSByZXR1cm47XG5cbiAgICB0aGlzLl9hICs9IGR0O1xuXG4gICAgLy8gdXBkYXRlIHRvIHRoZSBuZXh0IGZyYW1lIGlmIGl0J3MgdGltZVxuICAgIHdoaWxlICh0aGlzLl9hICogdGhpcy5mcmFtZVJhdGUgPj0gMSkge1xuICAgICAgdGhpcy5fZiA9ICsrdGhpcy5fZiAlIHRoaXMuZnJhbWVzLmxlbmd0aDtcbiAgICAgIHRoaXMuX2EgLT0gMSAvIHRoaXMuZnJhbWVSYXRlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3IHRoZSBjdXJyZW50IGZyYW1lIG9mIHRoZSBhbmltYXRpb24uXG4gICAqIEBtZW1iZXJvZiBBbmltYXRpb25cbiAgICogQGZ1bmN0aW9uIHJlbmRlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIFByb3BlcnRpZXMgdG8gZHJhdyB0aGUgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy54IC0gWCBwb3NpdGlvbiB0byBkcmF3IHRoZSBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLnkgLSBZIHBvc2l0aW9uIHRvIGRyYXcgdGhlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wZXJ0aWVzLndpZHRoXSAtIHdpZHRoIG9mIHRoZSBzcHJpdGUuIERlZmF1bHRzIHRvIFtBbmltYXRpb24ud2lkdGhdKGFwaS9hbmltYXRpb24jd2lkdGgpLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Byb3BlcnRpZXMuaGVpZ2h0XSAtIGhlaWdodCBvZiB0aGUgc3ByaXRlLiBEZWZhdWx0cyB0byBbQW5pbWF0aW9uLmhlaWdodF0oYXBpL2FuaW1hdGlvbiNoZWlnaHQpLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW3Byb3BlcnRpZXMuY29udGV4dF0gLSBUaGUgY29udGV4dCB0aGUgYW5pbWF0aW9uIHNob3VsZCBkcmF3IHRvLiBEZWZhdWx0cyB0byBbY29yZS5nZXRDb250ZXh0KCldKGFwaS9jb3JlI2dldENvbnRleHQpLlxuICAgKi9cbiAgcmVuZGVyKHt4LCB5LCB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0LCBjb250ZXh0ID0gZ2V0Q29udGV4dCgpfSkge1xuXG4gICAgLy8gZ2V0IHRoZSByb3cgYW5kIGNvbCBvZiB0aGUgZnJhbWVcbiAgICBsZXQgcm93ID0gdGhpcy5mcmFtZXNbdGhpcy5fZl0gLyB0aGlzLnNwcml0ZVNoZWV0Ll9mIHwgMDtcbiAgICBsZXQgY29sID0gdGhpcy5mcmFtZXNbdGhpcy5fZl0gJSB0aGlzLnNwcml0ZVNoZWV0Ll9mIHwgMDtcblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgdGhpcy5zcHJpdGVTaGVldC5pbWFnZSxcbiAgICAgIGNvbCAqIHRoaXMud2lkdGggKyAoY29sICogMiArIDEpICogdGhpcy5tYXJnaW4sXG4gICAgICByb3cgKiB0aGlzLmhlaWdodCArIChyb3cgKiAyICsgMSkgKiB0aGlzLm1hcmdpbixcbiAgICAgIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LFxuICAgICAgeCwgeSxcbiAgICAgIHdpZHRoLCBoZWlnaHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZhY3RvcnkoKSB7XG4gIHJldHVybiBuZXcgQW5pbWF0aW9uKC4uLmFyZ3VtZW50cyk7XG59XG5mYWN0b3J5LnByb3RvdHlwZSA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5mYWN0b3J5LmNsYXNzID0gQW5pbWF0aW9uO1xuXG4vKipcbiAqIEEgcHJvbWlzZSBiYXNlZCBhc3NldCBsb2FkZXIgZm9yIGxvYWRpbmcgaW1hZ2VzLCBhdWRpbywgYW5kIGRhdGEgZmlsZXMuIEFuIGBhc3NldExvYWRlZGAgZXZlbnQgaXMgZW1pdHRlZCBhZnRlciBlYWNoIGFzc2V0IGlzIGZ1bGx5IGxvYWRlZC4gVGhlIGNhbGxiYWNrIGZvciB0aGUgZXZlbnQgaXMgcGFzc2VkIHRoZSBhc3NldCBhbmQgdGhlIHVybCB0byB0aGUgYXNzZXQgYXMgcGFyYW1ldGVycy5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgbG9hZCwgb24gfSBmcm9tICdrb250cmEnO1xuICpcbiAqIGxldCBudW1Bc3NldHMgPSAzO1xuICogbGV0IGFzc2V0c0xvYWRlZCA9IDA7XG4gKiBvbignYXNzZXRMb2FkZWQnLCAoYXNzZXQsIHVybCkgPT4ge1xuICogICBhc3NldHNMb2FkZWQrKztcbiAqXG4gKiAgIC8vIGluZm9ybSB1c2VyIG9yIHVwZGF0ZSBwcm9ncmVzcyBiYXJcbiAqIH0pO1xuICpcbiAqIGxvYWQoXG4gKiAgICdhc3NldHMvaW1ncy9jaGFyYWN0ZXIucG5nJyxcbiAqICAgJ2Fzc2V0cy9kYXRhL3RpbGVfZW5naW5lX2Jhc2ljLmpzb24nLFxuICogICBbJy9hdWRpby9tdXNpYy5vZ2cnLCAnL2F1ZGlvL211c2ljLm1wMyddXG4gKiApLnRoZW4oZnVuY3Rpb24oYXNzZXRzKSB7XG4gKiAgIC8vIGFsbCBhc3NldHMgaGF2ZSBsb2FkZWRcbiAqIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICogICAvLyBlcnJvciBsb2FkaW5nIGFuIGFzc2V0XG4gKiB9KTtcbiAqIGBgYFxuICogQHNlY3Rpb25OYW1lIEFzc2V0c1xuICovXG5cbmxldCBpbWFnZVJlZ2V4ID0gLyhqcGVnfGpwZ3xnaWZ8cG5nfHdlYnApJC87XG5sZXQgYXVkaW9SZWdleCA9IC8od2F2fG1wM3xvZ2d8YWFjKSQvO1xubGV0IGxlYWRpbmdTbGFzaCA9IC9eXFwvLztcbmxldCB0cmFpbGluZ1NsYXNoID0gL1xcLyQvO1xubGV0IGRhdGFNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5sZXQgaW1hZ2VQYXRoID0gJyc7XG5sZXQgYXVkaW9QYXRoID0gJyc7XG5sZXQgZGF0YVBhdGggPSAnJztcblxuLyoqXG4gKiBHZXQgdGhlIGZ1bGwgVVJMIGZyb20gdGhlIGJhc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFRoZSBVUkwgdG8gdGhlIGFzc2V0LlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgLSBCYXNlIFVSTC5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRVcmwodXJsLCBiYXNlKSB7XG4gIHJldHVybiBuZXcgVVJMKHVybCwgYmFzZSkuaHJlZjtcbn1cblxuLyoqXG4gKiBKb2luIGEgYmFzZSBwYXRoIGFuZCBhc3NldCBwYXRoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIC0gVGhlIGFzc2V0IGJhc2UgcGF0aC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgVVJMIHRvIHRoZSBhc3NldC5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBqb2luUGF0aChiYXNlLCB1cmwpIHtcbiAgcmV0dXJuIFtiYXNlLnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgJycpLCBiYXNlID8gdXJsLnJlcGxhY2UobGVhZGluZ1NsYXNoLCAnJykgOiB1cmxdXG4gICAgLmZpbHRlcihzID0+IHMpXG4gICAgLmpvaW4oJy8nKVxufVxuXG4vKipcbiAqIEdldCB0aGUgZXh0ZW5zaW9uIG9mIGFuIGFzc2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBUaGUgVVJMIHRvIHRoZSBhc3NldC5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRFeHRlbnNpb24odXJsKSB7XG4gIHJldHVybiB1cmwuc3BsaXQoJy4nKS5wb3AoKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgYW4gYXNzZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFRoZSBVUkwgdG8gdGhlIGFzc2V0LlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldE5hbWUodXJsKSB7XG4gIGxldCBuYW1lID0gdXJsLnJlcGxhY2UoJy4nICsgZ2V0RXh0ZW5zaW9uKHVybCksICcnKTtcblxuICAvLyByZW1vdmUgbGVhZGluZyBzbGFzaCBpZiB0aGVyZSBpcyBubyBmb2xkZXIgaW4gdGhlIHBhdGhcbiAgLy8gQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTA1OTI2MjkvMjEyNDI1NFxuICByZXR1cm4gbmFtZS5zcGxpdCgnLycpLmxlbmd0aCA9PSAyID8gbmFtZS5yZXBsYWNlKGxlYWRpbmdTbGFzaCwgJycpIDogbmFtZTtcbn1cblxuLyoqXG4gKiBHZXQgYnJvd3NlciBhdWRpbyBwbGF5YWJpbGl0eS5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2F1ZGlvLmpzXG4gKlxuICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBhdWRpbyAtIEF1ZGlvIGVsZW1lbnQuXG4gKlxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FuUGxheShhdWRpbykge1xuICByZXR1cm4ge1xuICAgIHdhdjogYXVkaW8uY2FuUGxheVR5cGUoJ2F1ZGlvL3dhdjsgY29kZWNzPVwiMVwiJyksXG4gICAgbXAzOiBhdWRpby5jYW5QbGF5VHlwZSgnYXVkaW8vbXBlZzsnKSxcbiAgICBvZ2c6IGF1ZGlvLmNhblBsYXlUeXBlKCdhdWRpby9vZ2c7IGNvZGVjcz1cInZvcmJpc1wiJyksXG4gICAgYWFjOiBhdWRpby5jYW5QbGF5VHlwZSgnYXVkaW8vYWFjOycpXG4gIH07XG59XG5cbi8qKlxuICogT2JqZWN0IG9mIGFsbCBsb2FkZWQgaW1hZ2UgYXNzZXRzIGJ5IGJvdGggZmlsZSBuYW1lIGFuZCBwYXRoLiBJZiB0aGUgYmFzZSBbaW1hZ2UgcGF0aF0oYXBpL2Fzc2V0cyNzZXRJbWFnZVBhdGgpIHdhcyBzZXQgYmVmb3JlIHRoZSBpbWFnZSB3YXMgbG9hZGVkLCB0aGUgZmlsZSBuYW1lIGFuZCBwYXRoIHdpbGwgbm90IGluY2x1ZGUgdGhlIGJhc2UgaW1hZ2UgcGF0aC5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgbG9hZCwgc2V0SW1hZ2VQYXRoLCBpbWFnZUFzc2V0cyB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogbG9hZCgnYXNzZXRzL2ltZ3MvY2hhcmFjdGVyLnBuZycpLnRoZW4oZnVuY3Rpb24oKSB7XG4gKiAgIC8vIEltYWdlIGFzc2V0IGNhbiBiZSBhY2Nlc3NlZCBieSBib3RoXG4gKiAgIC8vIG5hbWU6IGltYWdlQXNzZXRzWydhc3NldHMvaW1ncy9jaGFyYWN0ZXInXVxuICogICAvLyBwYXRoOiBpbWFnZUFzc2V0c1snYXNzZXRzL2ltZ3MvY2hhcmFjdGVyLnBuZyddXG4gKiB9KTtcbiAqXG4gKiBzZXRJbWFnZVBhdGgoJ2Fzc2V0cy9pbWdzJyk7XG4gKiBsb2FkKCdjaGFyYWN0ZXJfd2Fsa19zaGVldC5wbmcnKS50aGVuKGZ1bmN0aW9uKCkge1xuICogICAvLyBJbWFnZSBhc3NldCBjYW4gYmUgYWNjZXNzZWQgYnkgYm90aFxuICogICAvLyBuYW1lOiBpbWFnZUFzc2V0c1snY2hhcmFjdGVyX3dhbGtfc2hlZXQnXVxuICogICAvLyBwYXRoOiBpbWFnZUFzc2V0c1snY2hhcmFjdGVyX3dhbGtfc2hlZXQucG5nJ11cbiAqIH0pO1xuICogYGBgXG4gKiBAcHJvcGVydHkge3tbbmFtZTogU3RyaW5nXTogSFRNTEltYWdlRWxlbWVudH19IGltYWdlQXNzZXRzXG4gKi9cbmxldCBpbWFnZUFzc2V0cyA9IHt9O1xuXG4vKipcbiAqIE9iamVjdCBvZiBhbGwgbG9hZGVkIGF1ZGlvIGFzc2V0cyBieSBib3RoIGZpbGUgbmFtZSBhbmQgcGF0aC4gSWYgdGhlIGJhc2UgW2F1ZGlvIHBhdGhdKGFwaS9hc3NldHMjc2V0QXVkaW9QYXRoKSB3YXMgc2V0IGJlZm9yZSB0aGUgYXVkaW8gd2FzIGxvYWRlZCwgdGhlIGZpbGUgbmFtZSBhbmQgcGF0aCB3aWxsIG5vdCBpbmNsdWRlIHRoZSBiYXNlIGF1ZGlvIHBhdGguXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IGxvYWQsIHNldEF1ZGlvUGF0aCwgYXVkaW9Bc3NldHMgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIGxvYWQoJy9hdWRpby9tdXNpYy5vZ2cnKS50aGVuKGZ1bmN0aW9uKCkge1xuICogICAvLyBBdWRpbyBhc3NldCBjYW4gYmUgYWNjZXNzZWQgYnkgYm90aFxuICogICAvLyBuYW1lOiBhdWRpb0Fzc2V0c1snL2F1ZGlvL211c2ljJ11cbiAqICAgLy8gcGF0aDogYXVkaW9Bc3NldHNbJy9hdWRpby9tdXNpYy5vZ2cnXVxuICogfSk7XG4gKlxuICogc2V0QXVkaW9QYXRoKCcvYXVkaW8nKTtcbiAqIGxvYWQoJ3NvdW5kLm9nZycpLnRoZW4oZnVuY3Rpb24oKSB7XG4gKiAgIC8vIEF1ZGlvIGFzc2V0IGNhbiBiZSBhY2Nlc3NlZCBieSBib3RoXG4gKiAgIC8vIG5hbWU6IGF1ZGlvQXNzZXRzWydzb3VuZCddXG4gKiAgIC8vIHBhdGg6IGF1ZGlvQXNzZXRzWydzb3VuZC5vZ2cnXVxuICogfSk7XG4gKiBgYGBcbiAqIEBwcm9wZXJ0eSB7e1tuYW1lOiBTdHJpbmddOiBIVE1MQXVkaW9FbGVtZW50fX0gYXVkaW9Bc3NldHNcbiAqL1xubGV0IGF1ZGlvQXNzZXRzID0ge307XG5cbi8qKlxuICogT2JqZWN0IG9mIGFsbCBsb2FkZWQgZGF0YSBhc3NldHMgYnkgYm90aCBmaWxlIG5hbWUgYW5kIHBhdGguIElmIHRoZSBiYXNlIFtkYXRhIHBhdGhdKGFwaS9hc3NldHMjc2V0RGF0YVBhdGgpIHdhcyBzZXQgYmVmb3JlIHRoZSBkYXRhIHdhcyBsb2FkZWQsIHRoZSBmaWxlIG5hbWUgYW5kIHBhdGggd2lsbCBub3QgaW5jbHVkZSB0aGUgYmFzZSBkYXRhIHBhdGguXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IGxvYWQsIHNldERhdGFQYXRoLCBkYXRhQXNzZXRzIH0gZnJvbSAna29udHJhJztcbiAqXG4gKiBsb2FkKCdhc3NldHMvZGF0YS9maWxlLnR4dCcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gKiAgIC8vIEF1ZGlvIGFzc2V0IGNhbiBiZSBhY2Nlc3NlZCBieSBib3RoXG4gKiAgIC8vIG5hbWU6IGRhdGFBc3NldHNbJ2Fzc2V0cy9kYXRhL2ZpbGUnXVxuICogICAvLyBwYXRoOiBkYXRhQXNzZXRzWydhc3NldHMvZGF0YS9maWxlLnR4dCddXG4gKiB9KTtcbiAqXG4gKiBzZXREYXRhUGF0aCgnYXNzZXRzL2RhdGEnKTtcbiAqIGxvYWQoJ2luZm8uanNvbicpLnRoZW4oZnVuY3Rpb24oKSB7XG4gKiAgIC8vIEF1ZGlvIGFzc2V0IGNhbiBiZSBhY2Nlc3NlZCBieSBib3RoXG4gKiAgIC8vIG5hbWU6IGRhdGFBc3NldHNbJ2luZm8nXVxuICogICAvLyBwYXRoOiBkYXRhQXNzZXRzWydpbmZvLmpzb24nXVxuICogfSk7XG4gKiBgYGBcbiAqIEBwcm9wZXJ0eSB7e1tuYW1lOiBTdHJpbmddOiBhbnl9fSBkYXRhQXNzZXRzXG4gKi9cbmxldCBkYXRhQXNzZXRzID0ge307XG5cbi8qKlxuICogQWRkIGEgZ2xvYmFsIGtvbnRyYSBvYmplY3Qgc28gVGlsZUVuZ2luZSBjYW4gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogbG9hZGVkIGFzc2V0cyB3aGVuIGtvbnRyYSBpcyBsb2FkZWQgaW4gcGFydHMgcmF0aGVyIHRoYW4gYXMgYSB3aG9sZSAoZS5nLlxuICogYGltcG9ydCB7IGxvYWQsIFRpbGVFbmdpbmUgfSBmcm9tICdrb250cmEnO2ApXG4gKi9cbmZ1bmN0aW9uIGFkZEdsb2JhbCgpIHtcbiAgaWYgKCF3aW5kb3cuX19rKSB7XG4gICAgd2luZG93Ll9fayA9IHtcbiAgICAgIGRtOiBkYXRhTWFwLFxuICAgICAgdTogZ2V0VXJsLFxuICAgICAgZDogZGF0YUFzc2V0cyxcbiAgICAgIGk6IGltYWdlQXNzZXRzXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIGJhc2UgcGF0aCBmb3IgYWxsIGltYWdlIGFzc2V0cy4gSWYgYSBiYXNlIHBhdGggaXMgc2V0LCBhbGwgbG9hZCBjYWxscyBmb3IgaW1hZ2UgYXNzZXRzIHdpbGwgcHJlcGVuZCB0aGUgYmFzZSBwYXRoIHRvIHRoZSBVUkwuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IHNldEltYWdlUGF0aCwgbG9hZCB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogc2V0SW1hZ2VQYXRoKCcvaW1ncycpO1xuICogbG9hZCgnY2hhcmFjdGVyLnBuZycpOyAgLy8gbG9hZHMgJy9pbWdzL2NoYXJhY3Rlci5wbmcnXG4gKiBgYGBcbiAqIEBmdW5jdGlvbiBzZXRJbWFnZVBhdGhcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIEJhc2UgaW1hZ2UgcGF0aC5cbiAqL1xuZnVuY3Rpb24gc2V0SW1hZ2VQYXRoKHBhdGgpIHtcbiAgaW1hZ2VQYXRoID0gcGF0aDtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBiYXNlIHBhdGggZm9yIGFsbCBhdWRpbyBhc3NldHMuIElmIGEgYmFzZSBwYXRoIGlzIHNldCwgYWxsIGxvYWQgY2FsbHMgZm9yIGF1ZGlvIGFzc2V0cyB3aWxsIHByZXBlbmQgdGhlIGJhc2UgcGF0aCB0byB0aGUgVVJMLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBzZXRBdWRpb1BhdGgsIGxvYWQgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIHNldEF1ZGlvUGF0aCgnL2F1ZGlvJyk7XG4gKiBsb2FkKCdtdXNpYy5vZ2cnKTsgIC8vIGxvYWRzICcvYXVkaW8vbXVzaWMub2dnJ1xuICogYGBgXG4gKiBAZnVuY3Rpb24gc2V0QXVkaW9QYXRoXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBCYXNlIGF1ZGlvIHBhdGguXG4gKi9cbmZ1bmN0aW9uIHNldEF1ZGlvUGF0aChwYXRoKSB7XG4gIGF1ZGlvUGF0aCA9IHBhdGg7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYmFzZSBwYXRoIGZvciBhbGwgZGF0YSBhc3NldHMuIElmIGEgYmFzZSBwYXRoIGlzIHNldCwgYWxsIGxvYWQgY2FsbHMgZm9yIGRhdGEgYXNzZXRzIHdpbGwgcHJlcGVuZCB0aGUgYmFzZSBwYXRoIHRvIHRoZSBVUkwuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IHNldERhdGFQYXRoLCBsb2FkIH0gZnJvbSAna29udHJhJztcbiAqXG4gKiBzZXREYXRhUGF0aCgnL2RhdGEnKTtcbiAqIGxvYWQoJ2ZpbGUuanNvbicpOyAgLy8gbG9hZHMgJy9kYXRhL2ZpbGUuanNvbidcbiAqIGBgYFxuICogQGZ1bmN0aW9uIHNldERhdGFQYXRoXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBCYXNlIGRhdGEgcGF0aC5cbiAqL1xuZnVuY3Rpb24gc2V0RGF0YVBhdGgocGF0aCkge1xuICBkYXRhUGF0aCA9IHBhdGg7XG59XG5cbi8qKlxuICogTG9hZCBhIHNpbmdsZSBJbWFnZSBhc3NldC4gVXNlcyB0aGUgYmFzZSBbaW1hZ2UgcGF0aF0oYXBpL2Fzc2V0cyNzZXRJbWFnZVBhdGgpIHRvIHJlc29sdmUgdGhlIFVSTC5cbiAqXG4gKiBPbmNlIGxvYWRlZCwgdGhlIGFzc2V0IHdpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgdGhlIFtpbWFnZUFzc2V0c10oYXBpL2Fzc2V0cyNpbWFnZUFzc2V0cykgcHJvcGVydHkuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IGxvYWRJbWFnZSB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogbG9hZEltYWdlKCdjYXIucG5nJykudGhlbihmdW5jdGlvbihpbWFnZSkge1xuICogICBjb25zb2xlLmxvZyhpbWFnZS5zcmMpOyAgLy89PiAnY2FyLnBuZydcbiAqIH0pXG4gKiBgYGBcbiAqIEBmdW5jdGlvbiBsb2FkSW1hZ2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byB0aGUgSW1hZ2UgZmlsZS5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxIVE1MSW1hZ2VFbGVtZW50Pn0gQSBkZWZlcnJlZCBwcm9taXNlLiBQcm9taXNlIHJlc29sdmVzIHdpdGggdGhlIEltYWdlLlxuICovXG5mdW5jdGlvbiBsb2FkSW1hZ2UodXJsKSB7XG4gIGFkZEdsb2JhbCgpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IHJlc29sdmVkVXJsLCBpbWFnZSwgZnVsbFVybDtcblxuICAgIHJlc29sdmVkVXJsID0gam9pblBhdGgoaW1hZ2VQYXRoLCB1cmwpO1xuICAgIGlmIChpbWFnZUFzc2V0c1tyZXNvbHZlZFVybF0pIHJldHVybiByZXNvbHZlKGltYWdlQXNzZXRzW3Jlc29sdmVkVXJsXSk7XG5cbiAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gbG9hZEltYWdlT25Mb2FkKCkge1xuICAgICAgZnVsbFVybCA9IGdldFVybChyZXNvbHZlZFVybCwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgaW1hZ2VBc3NldHNbIGdldE5hbWUodXJsKSBdID0gaW1hZ2VBc3NldHNbcmVzb2x2ZWRVcmxdID0gaW1hZ2VBc3NldHNbZnVsbFVybF0gPSB0aGlzO1xuICAgICAgZW1pdCgnYXNzZXRMb2FkZWQnLCB0aGlzLCB1cmwpO1xuICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uIGxvYWRJbWFnZU9uRXJyb3IoKSB7XG4gICAgICByZWplY3QoLyogQGlmZGVmIERFQlVHICovICdVbmFibGUgdG8gbG9hZCBpbWFnZSAnICsgLyogQGVuZGlmICovIHJlc29sdmVkVXJsKTtcbiAgICB9O1xuXG4gICAgaW1hZ2Uuc3JjID0gcmVzb2x2ZWRVcmw7XG4gIH0pO1xufVxuXG4vKipcbiAqIExvYWQgYSBzaW5nbGUgQXVkaW8gYXNzZXQuIFN1cHBvcnRzIGxvYWRpbmcgbXVsdGlwbGUgYXVkaW8gZm9ybWF0cyB3aGljaCB0aGUgbG9hZGVyIHdpbGwgdXNlIHRvIGxvYWQgdGhlIGZpcnN0IGF1ZGlvIGZvcm1hdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIgaW4gdGhlIG9yZGVyIGxpc3RlZC4gVXNlcyB0aGUgYmFzZSBbYXVkaW8gcGF0aF0oYXBpL2Fzc2V0cyNzZXRBdWRpb1BhdGgpIHRvIHJlc29sdmUgdGhlIFVSTC5cbiAqXG4gKiBPbmNlIGxvYWRlZCwgdGhlIGFzc2V0IHdpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgdGhlIFthdWRpb0Fzc2V0c10oYXBpL2Fzc2V0cyNhdWRpb0Fzc2V0cykgcHJvcGVydHkuIFNpbmNlIHRoZSBsb2FkZXIgZGV0ZXJtaW5lcyB3aGljaCBhdWRpbyBhc3NldCB0byBsb2FkIGJhc2VkIG9uIGJyb3dzZXIgc3VwcG9ydCwgeW91IHNob3VsZCBvbmx5IHJlZmVyZW5jZSB0aGUgYXVkaW8gYnkgaXRzIG5hbWUgYW5kIG5vdCBieSBpdHMgZmlsZSBwYXRoIHNpbmNlIHRoZXJlJ3Mgbm8gZ3VhcmFudGVlIHdoaWNoIGFzc2V0IHdhcyBsb2FkZWQuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IGxvYWRBdWRpbywgYXVkaW9Bc3NldHMgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIGxvYWRBdWRpbyhbXG4gKiAgICcvYXVkaW8vbXVzaWMubXAzJyxcbiAqICAgJy9hdWRpby9tdXNpYy5vZ2cnXG4gKiBdKS50aGVuKGZ1bmN0aW9uKGF1ZGlvKSB7XG4gKlxuICogICAvLyBhY2Nlc3MgYXVkaW8gYnkgaXRzIG5hbWUgb25seSAobm90IGJ5IGl0cyAubXAzIG9yIC5vZ2cgcGF0aClcbiAqICAgYXVkaW9Bc3NldHNbJy9hdWRpby9tdXNpYyddLnBsYXkoKTtcbiAqIH0pXG4gKiBgYGBcbiAqIEBmdW5jdGlvbiBsb2FkQXVkaW9cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byB0aGUgQXVkaW8gZmlsZS5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxIVE1MQXVkaW9FbGVtZW50Pn0gQSBkZWZlcnJlZCBwcm9taXNlLiBQcm9taXNlIHJlc29sdmVzIHdpdGggdGhlIEF1ZGlvLlxuICovXG5mdW5jdGlvbiBsb2FkQXVkaW8odXJsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IF91cmwgPSB1cmwsIGF1ZGlvRWwsIGNhblBsYXksIHJlc29sdmVkVXJsLCBmdWxsVXJsO1xuXG4gICAgYXVkaW9FbCA9IG5ldyBBdWRpbygpO1xuICAgIGNhblBsYXkgPSBnZXRDYW5QbGF5KGF1ZGlvRWwpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBmaXJzdCBhdWRpbyBmb3JtYXQgdGhlIGJyb3dzZXIgY2FuIHBsYXlcbiAgICB1cmwgPSBbXS5jb25jYXQodXJsKVxuICAgICAgICAgICAgLnJlZHVjZSgocGxheWFibGVTb3VyY2UsIHNvdXJjZSkgPT4gcGxheWFibGVTb3VyY2VcbiAgICAgICAgICAgICAgPyBwbGF5YWJsZVNvdXJjZVxuICAgICAgICAgICAgICA6IGNhblBsYXlbIGdldEV4dGVuc2lvbihzb3VyY2UpIF1cbiAgICAgICAgICAgICAgICA/IHNvdXJjZVxuICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgLCAwKTsgIC8vIDAgaXMgdGhlIHNob3J0ZXN0IGZhbHN5IHZhbHVlXG5cbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIHJlamVjdCgvKiBAaWZkZWYgREVCVUcgKi8gJ2Nhbm5vdCBwbGF5IGFueSBvZiB0aGUgYXVkaW8gZm9ybWF0cyBwcm92aWRlZCAnICsgLyogQGVuZGlmICovIF91cmwpO1xuICAgIH1cblxuICAgIHJlc29sdmVkVXJsID0gam9pblBhdGgoYXVkaW9QYXRoLCB1cmwpO1xuICAgIGlmIChhdWRpb0Fzc2V0c1tyZXNvbHZlZFVybF0pIHJldHVybiByZXNvbHZlKGF1ZGlvQXNzZXRzW3Jlc29sdmVkVXJsXSk7XG5cbiAgICBhdWRpb0VsLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBmdW5jdGlvbiBsb2FkQXVkaW9PbkxvYWQoKSB7XG4gICAgICBmdWxsVXJsID0gZ2V0VXJsKHJlc29sdmVkVXJsLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICBhdWRpb0Fzc2V0c1sgZ2V0TmFtZSh1cmwpIF0gPSBhdWRpb0Fzc2V0c1tyZXNvbHZlZFVybF0gPSBhdWRpb0Fzc2V0c1tmdWxsVXJsXSA9IHRoaXM7XG4gICAgICBlbWl0KCdhc3NldExvYWRlZCcsIHRoaXMsIHVybCk7XG4gICAgICByZXNvbHZlKHRoaXMpO1xuICAgIH0pO1xuXG4gICAgYXVkaW9FbC5vbmVycm9yID0gZnVuY3Rpb24gbG9hZEF1ZGlvT25FcnJvcigpIHtcbiAgICAgIHJlamVjdCgvKiBAaWZkZWYgREVCVUcgKi8gJ1VuYWJsZSB0byBsb2FkIGF1ZGlvICcgKyAvKiBAZW5kaWYgKi8gcmVzb2x2ZWRVcmwpO1xuICAgIH07XG5cbiAgICBhdWRpb0VsLnNyYyA9IHJlc29sdmVkVXJsO1xuICAgIGF1ZGlvRWwubG9hZCgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBMb2FkIGEgc2luZ2xlIERhdGEgYXNzZXQuIFVzZXMgdGhlIGJhc2UgW2RhdGEgcGF0aF0oYXBpL2Fzc2V0cyNzZXREYXRhUGF0aCkgdG8gcmVzb2x2ZSB0aGUgVVJMLlxuICpcbiAqIE9uY2UgbG9hZGVkLCB0aGUgYXNzZXQgd2lsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSB0aGUgW2RhdGFBc3NldHNdKGFwaS9hc3NldHMjZGF0YUFzc2V0cykgcHJvcGVydHkuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IGxvYWREYXRhIH0gZnJvbSAna29udHJhJztcbiAqXG4gKiBsb2FkRGF0YSgnYXNzZXRzL2RhdGEvdGlsZV9lbmdpbmVfYmFzaWMuanNvbicpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICogICAvLyBkYXRhIGNvbnRhaW5zIHRoZSBwYXJzZWQgSlNPTiBkYXRhXG4gKiB9KVxuICogYGBgXG4gKiBAZnVuY3Rpb24gbG9hZERhdGFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byB0aGUgRGF0YSBmaWxlLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBBIGRlZmVycmVkIHByb21pc2UuIFByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUuIElmIHRoZSBmaWxlIGlzIGEgSlNPTiBmaWxlLCB0aGUgY29udGVudHMgd2lsbCBiZSBwYXJzZWQgYXMgSlNPTi5cbiAqL1xuZnVuY3Rpb24gbG9hZERhdGEodXJsKSB7XG4gIGFkZEdsb2JhbCgpO1xuICBsZXQgcmVzb2x2ZWRVcmwsIGZ1bGxVcmw7XG5cbiAgcmVzb2x2ZWRVcmwgPSBqb2luUGF0aChkYXRhUGF0aCwgdXJsKTtcbiAgaWYgKGRhdGFBc3NldHNbcmVzb2x2ZWRVcmxdKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGFBc3NldHNbcmVzb2x2ZWRVcmxdKTtcblxuICByZXR1cm4gZmV0Y2gocmVzb2x2ZWRVcmwpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IHJlc3BvbnNlO1xuICAgIHJldHVybiByZXNwb25zZS5jbG9uZSgpLmpzb24oKS5jYXRjaCgoKSA9PiByZXNwb25zZS50ZXh0KCkpXG4gIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgIGZ1bGxVcmwgPSBnZXRVcmwocmVzb2x2ZWRVcmwsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09PSAnb2JqZWN0Jykge1xuICAgICAgZGF0YU1hcC5zZXQocmVzcG9uc2UsIGZ1bGxVcmwpO1xuICAgIH1cblxuICAgIGRhdGFBc3NldHNbIGdldE5hbWUodXJsKSBdID0gZGF0YUFzc2V0c1tyZXNvbHZlZFVybF0gPSBkYXRhQXNzZXRzW2Z1bGxVcmxdID0gcmVzcG9uc2U7XG4gICAgZW1pdCgnYXNzZXRMb2FkZWQnLCByZXNwb25zZSwgdXJsKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0pO1xufVxuXG4vKipcbiAqIExvYWQgSW1hZ2UsIEF1ZGlvLCBvciBkYXRhIGZpbGVzLiBVc2VzIHRoZSBbbG9hZEltYWdlXShhcGkvYXNzZXRzI2xvYWRJbWFnZSksIFtsb2FkQXVkaW9dKGFwaS9hc3NldHMjbG9hZEF1ZGlvKSwgYW5kIFtsb2FkRGF0YV0oYXBpL2Fzc2V0cyNsb2FkRGF0YSkgZnVuY3Rpb25zIHRvIGxvYWQgZWFjaCBhc3NldCB0eXBlLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBsb2FkIH0gZnJvbSAna29udHJhJztcbiAqXG4gKiBsb2FkKFxuICogICAnYXNzZXRzL2ltZ3MvY2hhcmFjdGVyLnBuZycsXG4gKiAgICdhc3NldHMvZGF0YS90aWxlX2VuZ2luZV9iYXNpYy5qc29uJyxcbiAqICAgWycvYXVkaW8vbXVzaWMub2dnJywgJy9hdWRpby9tdXNpYy5tcDMnXVxuICogKS50aGVuKGZ1bmN0aW9uKGFzc2V0cykge1xuICogICAvLyBhbGwgYXNzZXRzIGhhdmUgbG9hZGVkXG4gKiB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAqICAgLy8gZXJyb3IgbG9hZGluZyBhbiBhc3NldFxuICogfSk7XG4gKiBgYGBcbiAqIEBmdW5jdGlvbiBsb2FkXG4gKlxuICogQHBhcmFtIHsuLi5TdHJpbmdbXX0gdXJscyAtIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGFzc2V0IHVybHMgdG8gbG9hZC5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnlbXT59IEEgZGVmZXJyZWQgcHJvbWlzZS4gUmVzb2x2ZXMgd2l0aCBhbGwgdGhlIGxvYWRlZCBhc3NldHMuXG4gKi9cbmZ1bmN0aW9uIGxvYWQoLi4udXJscykge1xuICBhZGRHbG9iYWwoKTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgdXJscy5tYXAoYXNzZXQgPT4ge1xuICAgICAgLy8gYWNjb3VudCBmb3IgYSBzdHJpbmcgb3IgYW4gYXJyYXkgZm9yIHRoZSB1cmxcbiAgICAgIGxldCBleHRlbnNpb24gPSBnZXRFeHRlbnNpb24oIFtdLmNvbmNhdChhc3NldClbMF0gKTtcblxuICAgICAgcmV0dXJuIGV4dGVuc2lvbi5tYXRjaChpbWFnZVJlZ2V4KVxuICAgICAgICA/IGxvYWRJbWFnZShhc3NldClcbiAgICAgICAgOiBleHRlbnNpb24ubWF0Y2goYXVkaW9SZWdleClcbiAgICAgICAgICA/IGxvYWRBdWRpbyhhc3NldClcbiAgICAgICAgICA6IGxvYWREYXRhKGFzc2V0KTtcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEEgZ3JvdXAgb2YgaGVscGZ1bCBmdW5jdGlvbnMgdGhhdCBhcmUgY29tbW9ubHkgdXNlZCBmb3IgZ2FtZSBkZXZlbG9wbWVudC4gSW5jbHVkZXMgdGhpbmdzIHN1Y2ggYXMgY29udmVydGluZyBiZXR3ZWVuIHJhZGlhbnMgYW5kIGRlZ3JlZXMgYW5kIGdldHRpbmcgcmFuZG9tIGludGVnZXJzLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBkZWdUb1JhZCB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogbGV0IHJhZGlhbnMgPSBkZWdUb1JhZCgxODApOyAgLy8gPT4gMy4xNFxuICogYGBgXG4gKiBAc2VjdGlvbk5hbWUgSGVscGVyc1xuICovXG5cbi8qKlxuICogQ29udmVydCBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gKiBAZnVuY3Rpb24gZGVnVG9SYWRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVnIC0gRGVncmVlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB2YWx1ZSBpbiByYWRpYW5zLlxuICovXG5mdW5jdGlvbiBkZWdUb1JhZChkZWcpIHtcbiAgcmV0dXJuIGRlZyAqIE1hdGguUEkgLyAxODA7XG59XG5cbi8qKlxuICogQ29udmVydCByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gKiBAZnVuY3Rpb24gcmFkVG9EZWdcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIC0gUmFkaWFucyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB2YWx1ZSBpbiBkZWdyZWVzLlxuICovXG5mdW5jdGlvbiByYWRUb0RlZyhyYWQpIHtcbiAgcmV0dXJuIHJhZCAqIDE4MCAvIE1hdGguUEk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBhbmdsZSBpbiByYWRpYW5zIGZyb20gb25lIHBvaW50IHRvIGFub3RoZXIgcG9pbnQuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IGFuZ2xlVG9UYXJnZXQsIFNwcml0ZSB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogbGV0IHNwcml0ZSA9IFNwcml0ZSh7XG4gKiAgIHg6IDEwLFxuICogICB5OiAxMCxcbiAqICAgd2lkdGg6IDIwLFxuICogICBoZWlnaHQ6IDQwLFxuICogICBjb2xvcjogJ2JsdWUnXG4gKiB9KTtcbiAqXG4gKiBzcHJpdGUucm90YXRpb24gPSBhbmdsZVRvVGFyZ2V0KHNwcml0ZSwge3g6IDEwMCwgeTogMzB9KTtcbiAqXG4gKiBsZXQgc3ByaXRlMiA9IFNwcml0ZSh7XG4gKiAgIHg6IDEwMCxcbiAqICAgeTogMzAsXG4gKiAgIHdpZHRoOiAyMCxcbiAqICAgaGVpZ2h0OiA0MCxcbiAqICAgY29sb3I6ICdyZWQnLFxuICogfSk7XG4gKlxuICogc3ByaXRlMi5yb3RhdGlvbiA9IGFuZ2xlVG9UYXJnZXQoc3ByaXRlMiwgc3ByaXRlKTtcbiAqIGBgYFxuICogQGZ1bmN0aW9uIGFuZ2xlVG9UYXJnZXRcbiAqXG4gKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHNvdXJjZSAtIFRoZSB7eCx5fSBzb3VyY2UgcG9pbnQuXG4gKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHRhcmdldCAtIFRoZSB7eCx5fSB0YXJnZXQgcG9pbnQuXG4gKlxuICogQHJldHVybnMge051bWJlcn0gQW5nbGUgKGluIHJhZGlhbnMpIGZyb20gdGhlIHNvdXJjZSBwb2ludCB0byB0aGUgdGFyZ2V0IHBvaW50LlxuICovXG5mdW5jdGlvbiBhbmdsZVRvVGFyZ2V0KHNvdXJjZSwgdGFyZ2V0KSB7XG5cbiAgLy8gYXRhbjIgcmV0dXJucyB0aGUgY291bnRlci1jbG9ja3dpc2UgYW5nbGUgaW4gcmVzcGVjdCB0byB0aGUgeC1heGlzLCBidXRcbiAgLy8gdGhlIGNhbnZhcyByb3RhdGlvbiBzeXN0ZW0gaXMgYmFzZWQgb24gdGhlIHktYXhpcyAocm90YXRpb24gb2YgMCA9IHVwKS5cbiAgLy8gc28gd2UgbmVlZCB0byBhZGQgYSBxdWFydGVyIHJvdGF0aW9uIHRvIHJldHVybiBhIGNvdW50ZXItY2xvY2t3aXNlXG4gIC8vIHJvdGF0aW9uIGluIHJlc3BlY3QgdG8gdGhlIHktYXhpc1xuICByZXR1cm4gTWF0aC5hdGFuMih0YXJnZXQueSAtIHNvdXJjZS55LCB0YXJnZXQueCAtIHNvdXJjZS54KSArIE1hdGguUEkgLyAyO1xufVxuXG4vKipcbiAqIFJvdGF0ZSBhIHBvaW50IGJ5IGFuIGFuZ2xlLlxuICogQGZ1bmN0aW9uIHJvdGF0ZVBvaW50XG4gKlxuICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb2ludCAtIFRoZSB7eCx5fSBwb2ludCB0byByb3RhdGUuXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgLSBBbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlLlxuICpcbiAqIEByZXR1cm5zIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBUaGUgbmV3IHggYW5kIHkgY29vcmRpbmF0ZXMgYWZ0ZXIgcm90YXRpb24uXG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVBvaW50KHBvaW50LCBhbmdsZSkge1xuICBsZXQgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICBsZXQgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICBsZXQgeCA9IHBvaW50LnggKiBjb3MgLSBwb2ludC55ICogc2luO1xuICBsZXQgeSA9IHBvaW50LnggKiBzaW4gKyBwb2ludC55ICogY29zO1xuXG4gIHJldHVybiB7eCwgeX07XG59XG5cbi8qKlxuICogUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBhIG1pbmltdW0gKGluY2x1c2l2ZSkgYW5kIG1heGltdW0gKGluY2x1c2l2ZSkgaW50ZWdlci5cbiAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1Mjc4MjAvMjEyNDI1NFxuICogQGZ1bmN0aW9uIHJhbmRJbnRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWluIC0gTWluIGludGVnZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IC0gTWF4IGludGVnZXIuXG4gKlxuICogQHJldHVybnMge051bWJlcn0gUmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHJhbmRJbnQobWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc2VlZGVkIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBzZWVkUmFuZCB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogbGV0IHJhbmQgPSBzZWVkUmFuZCgna29udHJhJyk7XG4gKiBjb25zb2xlLmxvZyhyYW5kKCkpOyAgLy8gPT4gYWx3YXlzIDAuMzM3NjE5NTkwNTczMDEyODNcbiAqIGBgYFxuICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDc1OTMzMTYvMjEyNDI1NFxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJ5Yy9jb2RlL2Jsb2IvbWFzdGVyL2pzaGFzaC9QUk5Hcy5tZFxuICpcbiAqIEBmdW5jdGlvbiBzZWVkUmFuZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gc2VlZCB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuXG4gKlxuICogQHJldHVybnMgeygpID0+IE51bWJlcn0gU2VlZGVkIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICovXG4gZnVuY3Rpb24gc2VlZFJhbmQoc3RyKSB7XG4gIC8vIGJhc2VkIG9uIHRoZSBhYm92ZSByZWZlcmVuY2VzLCB0aGlzIHdhcyB0aGUgc21hbGxlc3QgY29kZSB5ZXQgZGVjZW50XG4gIC8vIHF1YWxpdHkgc2VlZCByYW5kb20gZnVuY3Rpb25cblxuICAvLyBmaXJzdCBjcmVhdGUgYSBzdWl0YWJsZSBoYXNoIG9mIHRoZSBzZWVkIHN0cmluZyB1c2luZyB4Zm52MWFcbiAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJ5Yy9jb2RlL2Jsb2IvbWFzdGVyL2pzaGFzaC9QUk5Hcy5tZCNhZGRlbmR1bS1hLXNlZWQtZ2VuZXJhdGluZy1mdW5jdGlvbnNcbiAgZm9yKHZhciBpID0gMCwgaCA9IDIxNjYxMzYyNjEgPj4+IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBoID0gTWF0aC5pbXVsKGggXiBzdHIuY2hhckNvZGVBdChpKSwgMTY3Nzc2MTkpO1xuICB9XG4gIGggKz0gaCA8PCAxMzsgaCBePSBoID4+PiA3O1xuICBoICs9IGggPDwgMzsgIGggXj0gaCA+Pj4gMTc7XG4gIGxldCBzZWVkID0gKGggKz0gaCA8PCA1KSA+Pj4gMDtcblxuICAvLyB0aGVuIHJldHVybiB0aGUgc2VlZCBmdW5jdGlvbiBhbmQgZGlzY2FyZCB0aGUgZmlyc3QgcmVzdWx0XG4gIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JyeWMvY29kZS9ibG9iL21hc3Rlci9qc2hhc2gvUFJOR3MubWQjbGNnLWxlaG1lci1ybmdcbiAgbGV0IHJhbmQgPSAoKSA9PiAoMiAqKiAzMSAtIDEgJiAoc2VlZCA9IE1hdGguaW11bCg0ODI3MSwgc2VlZCkpKSAvIDIgKiogMzE7XG4gIHJhbmQoKTtcbiAgcmV0dXJuIHJhbmQ7XG59XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGUgYmV0d2VlbiB0d28gdmFsdWVzLiBUaGUgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgbnVtYmVyIGJldHdlZW4gdHdvIHZhbHVlcyBiYXNlZCBvbiBhIHBlcmNlbnQuIEdyZWF0IGZvciBzbW9vdGggdHJhbnNpdGlvbnMuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IGxlcnAgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIGNvbnNvbGUubG9nKCBsZXJwKDEwLCAyMCwgMC41KSApOyAgLy8gPT4gMTVcbiAqIGNvbnNvbGUubG9nKCBsZXJwKDEwLCAyMCwgMikgKTsgIC8vID0+IDMwXG4gKiBgYGBcbiAqIEBmdW5jdGlvbiBsZXJwXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IC0gU3RhcnQgdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kIC0gRW5kIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBlcmNlbnQgLSBQZXJjZW50IHRvIGludGVycG9sYXRlLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEludGVycG9sYXRlZCBudW1iZXIgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gbGVycChzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gIHJldHVybiBzdGFydCAqICgxIC0gcGVyY2VudCkgKyBlbmQgKiBwZXJjZW50O1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbGluZWFyIGludGVycG9sYXRpb24gcGVyY2VudCBiZXR3ZWVuIHR3byB2YWx1ZXMuIFRoZSBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBwZXJjZW50IGJldHdlZW4gdHdvIHZhbHVlcyBvZiBhIGdpdmVuIHZhbHVlLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBpbnZlcnNlTGVycCB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogY29uc29sZS5sb2coIGludmVyc2VMZXJwKDEwLCAyMCwgMTUpICk7ICAvLyA9PiAwLjVcbiAqIGNvbnNvbGUubG9nKCBpbnZlcnNlTGVycCgxMCwgMjAsIDMwKSApOyAgLy8gPT4gMlxuICogYGBgXG4gKiBAZnVuY3Rpb24gaW52ZXJzZUxlcnBcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgLSBTdGFydCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgLSBFbmQgdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBWYWx1ZSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQuXG4gKlxuICogQHJldHVybnMge051bWJlcn0gUGVyY2VudCBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBpbnZlcnNlTGVycChzdGFydCwgZW5kLCB2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlIC0gc3RhcnQpIC8gKGVuZCAtIHN0YXJ0KTtcbn1cblxuLyoqXG4gKiBDbGFtcCBhIG51bWJlciBiZXR3ZWVuIHR3byB2YWx1ZXMsIHByZXZlbnRpbmcgaXQgZnJvbSBnb2luZyBiZWxvdyBvciBhYm92ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMuXG4gKiBAZnVuY3Rpb24gY2xhbXBcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWluIC0gTWluIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCAtIE1heCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFZhbHVlIHRvIGNsYW1wLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFZhbHVlIGNsYW1wZWQgYmV0d2VlbiBtaW4gYW5kIG1heC5cbiAqL1xuZnVuY3Rpb24gY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1pbiggTWF0aC5tYXgobWluLCB2YWx1ZSksIG1heCApO1xufVxuXG4vKipcbiAqIFNhdmUgYW4gaXRlbSB0byBsb2NhbFN0b3JhZ2UuIEEgdmFsdWUgb2YgYHVuZGVmaW5lZGAgd2lsbCByZW1vdmUgdGhlIGl0ZW0gZnJvbSBsb2NhbFN0b3JhZ2UuXG4gKiBAZnVuY3Rpb24gc2V0U3RvcmVJdGVtXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0b3JlLlxuICovXG5mdW5jdGlvbiBzZXRTdG9yZUl0ZW0oa2V5LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICB9XG59XG5cbi8qKlxuICogUmV0cmlldmUgYW4gaXRlbSBmcm9tIGxvY2FsU3RvcmFnZSBhbmQgY29udmVydCBpdCBiYWNrIHRvIGl0cyBvcmlnaW5hbCB0eXBlLlxuICpcbiAqIE5vcm1hbGx5IHdoZW4geW91IHNhdmUgYSB2YWx1ZSB0byBMb2NhbFN0b3JhZ2UgaXQgY29udmVydHMgaXQgaW50byBhIHN0cmluZy4gU28gaWYgeW91IHdlcmUgdG8gc2F2ZSBhIG51bWJlciwgaXQgd291bGQgYmUgc2F2ZWQgYXMgYFwiMTJcImAgaW5zdGVhZCBvZiBgMTJgLiBUaGlzIGZ1bmN0aW9uIGVuYWJsZXMgdGhlIHZhbHVlIHRvIGJlIHJldHVybmVkIGFzIGAxMmAuXG4gKiBAZnVuY3Rpb24gZ2V0U3RvcmVJdGVtXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIE5hbWUgb2YgdGhlIGtleSBvZiB0aGUgaXRlbSB0byByZXRyaWV2ZS5cbiAqXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJldHJpZXZlZCBpdGVtLlxuICovXG5mdW5jdGlvbiBnZXRTdG9yZUl0ZW0oa2V5KSB7XG4gIGxldCB2YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICB9XG4gIGNhdGNoKGUpIHt9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdHdvIG9iamVjdHMgY29sbGlkZS4gVXNlcyBhIHNpbXBsZSBbQXhpcy1BbGlnbmVkIEJvdW5kaW5nIEJveCAoQUFCQikgY29sbGlzaW9uIGNoZWNrXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dhbWVzL1RlY2huaXF1ZXMvMkRfY29sbGlzaW9uX2RldGVjdGlvbiNBeGlzLUFsaWduZWRfQm91bmRpbmdfQm94KS4gVGFrZXMgaW50byBhY2NvdW50IHRoZSBzcHJpdGVzIFthbmNob3JdKGFwaS9nYW1lT2JqZWN0I2FuY2hvcikgYW5kIFtzY2FsZV0oYXBpL2dhbWVPYmplY3Qjc2NhbGUpLlxuICpcbiAqICoqTk9URToqKiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBvYmplY3Qgcm90YXRpb24uIElmIHlvdSBuZWVkIGNvbGxpc2lvbiBkZXRlY3Rpb24gYmV0d2VlbiByb3RhdGVkIG9iamVjdHMgeW91IHdpbGwgbmVlZCB0byBpbXBsZW1lbnQgeW91ciBvd24gYGNvbGxpZGVzKClgIGZ1bmN0aW9uLiBJIHN1Z2dlc3QgbG9va2luZyBhdCB0aGUgU2VwYXJhdGUgQXhpcyBUaGVvcmVtLlxuICpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgU3ByaXRlLCBjb2xsaWRlcyB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogbGV0IHNwcml0ZSA9IFNwcml0ZSh7XG4gKiAgIHg6IDEwMCxcbiAqICAgeTogMjAwLFxuICogICB3aWR0aDogMjAsXG4gKiAgIGhlaWdodDogNDBcbiAqIH0pO1xuICpcbiAqIGxldCBzcHJpdGUyID0gU3ByaXRlKHtcbiAqICAgeDogMTUwLFxuICogICB5OiAyMDAsXG4gKiAgIHdpZHRoOiAyMCxcbiAqICAgaGVpZ2h0OiAyMFxuICogfSk7XG4gKlxuICogY29sbGlkZXMoc3ByaXRlLCBzcHJpdGUyKTsgIC8vPT4gZmFsc2VcbiAqXG4gKiBzcHJpdGUyLnggPSAxMTU7XG4gKlxuICogY29sbGlkZXMoc3ByaXRlLCBzcHJpdGUyKTsgIC8vPT4gdHJ1ZVxuICogYGBgXG4gKiBAZnVuY3Rpb24gY29sbGlkZXNcbiAqXG4gKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fHt3b3JsZDoge3g6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19fSBvYmoxIC0gT2JqZWN0IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn18e3dvcmxkOiB7eDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX19IG9iajIgLSBPYmplY3QgdG8gY2hlY2sgY29sbGlzaW9uIGFnYWluc3QuXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW58bnVsbH0gYHRydWVgIGlmIHRoZSBvYmplY3RzIGNvbGxpZGUsIGBmYWxzZWAgb3RoZXJ3aXNlLiBXaWxsIHJldHVybiBgbnVsbGAgaWYgdGhlIGVpdGhlciBvZiB0aGUgdHdvIG9iamVjdHMgYXJlIHJvdGF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbGxpZGVzKG9iajEsIG9iajIpIHtcbiAgaWYgKG9iajEucm90YXRpb24gfHwgb2JqMi5yb3RhdGlvbikgcmV0dXJuIG51bGw7XG5cbiAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfU0NBTEV8fEdBTUVPQkpFQ1RfQU5DSE9SXG4gIC8vIGRlc3RydWN0dXJlIHJlc3VsdHMgdG8gb2JqMSBhbmQgb2JqMlxuICBbb2JqMSwgb2JqMl0gPSBbb2JqMSwgb2JqMl0ubWFwKG9iaiA9PiBnZXRXb3JsZFJlY3Qob2JqKSk7XG4gIC8vIEBlbmRpZlxuXG4gIHJldHVybiBvYmoxLnggPCBvYmoyLnggKyBvYmoyLndpZHRoICYmXG4gICAgICAgICBvYmoxLnggKyBvYmoxLndpZHRoID4gb2JqMi54ICYmXG4gICAgICAgICBvYmoxLnkgPCBvYmoyLnkgKyBvYmoyLmhlaWdodCAmJlxuICAgICAgICAgb2JqMS55ICsgb2JqMS5oZWlnaHQgPiBvYmoyLnk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSB3b3JsZCByZWN0IG9mIGFuIG9iamVjdC4gVGhlIHJlY3QgaXMgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIG9iamVjdCBhbmQgaXRzIHNpemUuIFRha2VzIGludG8gYWNjb3VudCB0aGUgb2JqZWN0cyBhbmNob3IgYW5kIHNjYWxlLlxuICogQGZ1bmN0aW9uIGdldFdvcmxkUmVjdFxuICpcbiAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn18e3dvcmxkOiB7eDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX18e21hcHdpZHRoOiBudW1iZXIsIG1hcGhlaWdodDogbnVtYmVyfX0gb2JqIC0gT2JqZWN0IHRvIGdldCB3b3JsZCByZWN0IG9mLlxuICpcbiAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gVGhlIHdvcmxkIGB4YCwgYHlgLCBgd2lkdGhgLCBhbmQgYGhlaWdodGAgb2YgdGhlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0V29ybGRSZWN0KG9iaikge1xuICBsZXQge1xuICAgIHggPSAwLFxuICAgIHkgPSAwLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gb2JqLndvcmxkIHx8IG9iajtcblxuICAvLyB0YWtlIGludG8gYWNjb3VudCB0aWxlRW5naW5lXG4gIGlmIChvYmoubWFwd2lkdGgpIHtcbiAgICB3aWR0aCA9IG9iai5tYXB3aWR0aDtcbiAgICBoZWlnaHQgPSBvYmoubWFwaGVpZ2h0O1xuICB9XG5cbiAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfQU5DSE9SXG4gIC8vIGFjY291bnQgZm9yIGFuY2hvclxuICBpZiAob2JqLmFuY2hvcikge1xuICAgIHggLT0gd2lkdGggKiBvYmouYW5jaG9yLng7XG4gICAgeSAtPSBoZWlnaHQgKiBvYmouYW5jaG9yLnk7XG4gIH1cbiAgLy8gQGVuZGlmXG5cbiAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfU0NBTEVcbiAgLy8gYWNjb3VudCBmb3IgbmVnYXRpdmUgc2NhbGVzXG4gIGlmICh3aWR0aCA8IDApIHtcbiAgICB4ICs9IHdpZHRoO1xuICAgIHdpZHRoICo9IC0xO1xuICB9XG4gIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgeSArPSBoZWlnaHQ7XG4gICAgaGVpZ2h0ICo9IC0xO1xuICB9XG4gIC8vIEBlbmRpZlxuXG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIDJkIHZlY3RvciBvYmplY3QuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IFZlY3RvciB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogbGV0IHZlY3RvciA9IFZlY3RvcigxMDAsIDIwMCk7XG4gKiBgYGBcbiAqIEBjbGFzcyBWZWN0b3JcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gLSBYIGNvb3JkaW5hdGUgb2YgdGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFkgY29vcmRpbmF0ZSBvZiB0aGUgdmVjdG9yLlxuICovXG5jbGFzcyBWZWN0b3Ige1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHZlYyA9IHt9KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuXG4gICAgLy8gQGlmZGVmIFZFQ1RPUl9DTEFNUFxuICAgIC8vIHByZXNlcnZlIHZlY3RvciBjbGFtcGluZyB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzXG4gICAgaWYgKHZlYy5fYykge1xuICAgICAgdGhpcy5jbGFtcCh2ZWMuX2EsIHZlYy5fYiwgdmVjLl9kLCB2ZWMuX2UpO1xuXG4gICAgICAvLyByZXNldCB4IGFuZCB5IHNvIGNsYW1waW5nIHRha2VzIGVmZmVjdFxuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxuICAgIC8vIEBlbmRpZlxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgdmVjdG9yIHdpdGggdGhlIGdpdmVuIHZlY3Rvci5cbiAgICogQG1lbWJlcm9mIFZlY3RvclxuICAgKiBAZnVuY3Rpb24gYWRkXG4gICAqXG4gICAqIEBwYXJhbSB7VmVjdG9yfHt4OiBudW1iZXIsIHk6IG51bWJlcn19IHZlY3RvciAtIFZlY3RvciB0byBhZGQgdG8gdGhlIGN1cnJlbnQgVmVjdG9yLlxuICAgKlxuICAgKiBAcmV0dXJucyB7VmVjdG9yfSBBIG5ldyBWZWN0b3IgaW5zdGFuY2Ugd2hvc2UgdmFsdWUgaXMgdGhlIGFkZGl0aW9uIG9mIHRoZSB0d28gdmVjdG9ycy5cbiAgICovXG4gIGFkZCh2ZWMpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcihcbiAgICAgIHRoaXMueCArIHZlYy54LFxuICAgICAgdGhpcy55ICsgdmVjLnksXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8vIEBpZmRlZiBWRUNUT1JfU1VCVFJBQ1RcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgc3VidHJhY3Rpb24gb2YgdGhlIGN1cnJlbnQgdmVjdG9yIHdpdGggdGhlIGdpdmVuIHZlY3Rvci5cbiAgICogQG1lbWJlcm9mIFZlY3RvclxuICAgKiBAZnVuY3Rpb24gc3VidHJhY3RcbiAgICpcbiAgICogQHBhcmFtIHtWZWN0b3J8e3g6IG51bWJlciwgeTogbnVtYmVyfX0gdmVjdG9yIC0gVmVjdG9yIHRvIHN1YnRyYWN0IGZyb20gdGhlIGN1cnJlbnQgVmVjdG9yLlxuICAgKlxuICAgKiBAcmV0dXJucyB7VmVjdG9yfSBBIG5ldyBWZWN0b3IgaW5zdGFuY2Ugd2hvc2UgdmFsdWUgaXMgdGhlIHN1YnRyYWN0aW9uIG9mIHRoZSB0d28gdmVjdG9ycy5cbiAgICovXG4gICBzdWJ0cmFjdCh2ZWMpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcihcbiAgICAgIHRoaXMueCAtIHZlYy54LFxuICAgICAgdGhpcy55IC0gdmVjLnksXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuICAvLyBAZW5kaWZcblxuICAvLyBAaWZkZWYgVkVDVE9SX1NDQUxFXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG11bHRpcGxlIG9mIHRoZSBjdXJyZW50IHZlY3RvciBieSBhIHZhbHVlLlxuICAgKiBAbWVtYmVyb2YgVmVjdG9yXG4gICAqIEBmdW5jdGlvbiBzY2FsZVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBWYWx1ZSB0byBzY2FsZSB0aGUgY3VycmVudCBWZWN0b3IuXG4gICAqXG4gICAqIEByZXR1cm5zIHtWZWN0b3J9IEEgbmV3IFZlY3RvciBpbnN0YW5jZSB3aG9zZSB2YWx1ZSBpcyBtdWx0aXBsaWVkIGJ5IHRoZSBzY2FsYXIuXG4gICAqL1xuICBzY2FsZSh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yKFxuICAgICAgdGhpcy54ICogdmFsdWUsXG4gICAgICB0aGlzLnkgKiB2YWx1ZVxuICAgICk7XG4gIH1cbiAgLy8gQGVuZGlmXG5cbiAgLy8gQGlmZGVmIFZFQ1RPUl9OT1JNQUxJWkVcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgY3VycmVudCB2ZWN0b3IuIFJlcXVpcmVzIHRoZSBWZWN0b3IgW2xlbmd0aF0oYXBpL3ZlY3RvciNsZW5ndGgpIGZ1bmN0aW9uLlxuICAgKiBAbWVtYmVyb2YgVmVjdG9yXG4gICAqIEBmdW5jdGlvbiBub3JtYWxpemVcbiAgICpcbiAgICogQHJldHVybnMge1ZlY3Rvcn0gQSBuZXcgVmVjdG9yIGluc3RhbmNlIHdob3NlIHZhbHVlIGlzIHRoZSBub3JtYWxpemVkIHZlY3Rvci5cbiAgICovXG4gIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2plZC8xNDBieXRlcy93aWtpL0J5dGUtc2F2aW5nLXRlY2huaXF1ZXMjdXNlLXBsYWNlaG9sZGVyLWFyZ3VtZW50cy1pbnN0ZWFkLW9mLXZhclxuICBub3JtYWxpemUobGVuZ3RoID0gdGhpcy5sZW5ndGgoKSkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yKFxuICAgICAgdGhpcy54IC8gbGVuZ3RoLFxuICAgICAgdGhpcy55IC8gbGVuZ3RoXG4gICAgKTtcbiAgfVxuICAvLyBAZW5kaWZcblxuICAvLyBAaWZkZWYgVkVDVE9SX0RPVHx8VkVDVE9SX0FOR0xFXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGRvdCBwcm9kdWN0IG9mIHRoZSBjdXJyZW50IHZlY3RvciB3aXRoIHRoZSBnaXZlbiB2ZWN0b3IuXG4gICAqIEBtZW1iZXJvZiBWZWN0b3JcbiAgICogQGZ1bmN0aW9uIGRvdFxuICAgKlxuICAgKiBAcGFyYW0ge1ZlY3Rvcnx7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSB2ZWN0b3IgLSBWZWN0b3IgdG8gZG90IHByb2R1Y3QgYWdhaW5zdC5cbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIGRvdCBwcm9kdWN0IG9mIHRoZSB2ZWN0b3JzLlxuICAgKi9cbiAgZG90KHZlYykge1xuICAgIHJldHVybiB0aGlzLnggKiB2ZWMueCArIHRoaXMueSAqIHZlYy55O1xuICB9XG4gIC8vIEBlbmRpZlxuXG4gIC8vIEBpZmRlZiBWRUNUT1JfTEVOR1RIfHxWRUNUT1JfTk9STUFMSVpFfHxWRUNUT1JfQU5HTEVcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIChtYWduaXR1ZGUpIG9mIHRoZSBWZWN0b3IuXG4gICAqIEBtZW1iZXJvZiBWZWN0b3JcbiAgICogQGZ1bmN0aW9uIGxlbmd0aFxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IuXG4gICAqL1xuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIE1hdGguaHlwb3QodGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIC8vIEBlbmRpZlxuXG4gIC8vIEBpZmRlZiBWRUNUT1JfRElTVEFOQ0VcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCB2ZWN0b3IgYW5kIHRoZSBnaXZlbiB2ZWN0b3IuXG4gICAqIEBtZW1iZXJvZiBWZWN0b3JcbiAgICogQGZ1bmN0aW9uIGRpc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7VmVjdG9yfHt4OiBudW1iZXIsIHk6IG51bWJlcn19IHZlY3RvciAtIFZlY3RvciB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4uXG4gICAqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gdmVjdG9ycy5cbiAgICovXG4gIGRpc3RhbmNlKHZlYykge1xuICAgIHJldHVybiBNYXRoLmh5cG90KHRoaXMueCAtIHZlYy54LCB0aGlzLnkgLSB2ZWMueSk7XG4gIH1cbiAgLy8gQGVuZGlmXG5cbiAgLy8gQGlmZGVmIFZFQ1RPUl9BTkdMRVxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBhbmdsZSAoaW4gcmFkaWFucykgYmV0d2VlbiB0aGUgY3VycmVudCB2ZWN0b3IgYW5kIHRoZSBnaXZlbiB2ZWN0b3IuIFJlcXVpcmVzIHRoZSBWZWN0b3IgW2RvdF0oYXBpL3ZlY3RvciNkb3QpIGFuZCBbbGVuZ3RoXShhcGkvdmVjdG9yI2xlbmd0aCkgZnVuY3Rpb25zLlxuICAgKiBAbWVtYmVyb2YgVmVjdG9yXG4gICAqIEBmdW5jdGlvbiBhbmdsZVxuICAgKlxuICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yIC0gVmVjdG9yIHRvIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2Vlbi5cbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIChpbiByYWRpYW5zKSBiZXR3ZWVuIHRoZSB0d28gdmVjdG9ycy5cbiAgICovXG4gIGFuZ2xlKHZlYykge1xuICAgIHJldHVybiBNYXRoLmFjb3ModGhpcy5kb3QodmVjKSAvICh0aGlzLmxlbmd0aCgpICogdmVjLmxlbmd0aCgpKSk7XG4gIH1cbiAgLy8gQGVuZGlmXG5cbiAgLy8gQGlmZGVmIFZFQ1RPUl9DTEFNUFxuICAvKipcbiAgICogQ2xhbXAgdGhlIFZlY3RvciBiZXR3ZWVuIHR3byBwb2ludHMsIHByZXZlbnRpbmcgYHhgIGFuZCBgeWAgZnJvbSBnb2luZyBiZWxvdyBvciBhYm92ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMuIFBlcmZlY3QgZm9yIGtlZXBpbmcgYSBzcHJpdGUgZnJvbSBnb2luZyBvdXRzaWRlIHRoZSBnYW1lIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IFZlY3RvciB9IGZyb20gJ2tvbnRyYSc7XG4gICAqXG4gICAqIGxldCB2ZWN0b3IgPSBWZWN0b3IoMTAwLCAyMDApO1xuICAgKiB2ZWN0b3IuY2xhbXAoMCwgMCwgMjAwLCAzMDApO1xuICAgKlxuICAgKiB2ZWN0b3IueCArPSAyMDA7XG4gICAqIGNvbnNvbGUubG9nKHZlY3Rvci54KTsgIC8vPT4gMjAwXG4gICAqXG4gICAqIHZlY3Rvci55IC09IDMwMDtcbiAgICogY29uc29sZS5sb2codmVjdG9yLnkpOyAgLy89PiAwXG4gICAqXG4gICAqIHZlY3Rvci5hZGQoe3g6IC01MDAsIHk6IDUwMH0pO1xuICAgKiBjb25zb2xlLmxvZyh2ZWN0b3IpOyAgICAvLz0+IHt4OiAwLCB5OiAzMDB9XG4gICAqIGBgYFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yXG4gICAqIEBmdW5jdGlvbiBjbGFtcFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0geE1pbiAtIE1pbmltdW0geCB2YWx1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlNaW4gLSBNaW5pbXVtIHkgdmFsdWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4TWF4IC0gTWF4aW11bSB4IHZhbHVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geU1heCAtIE1heGltdW0geSB2YWx1ZS5cbiAgICovXG4gIGNsYW1wKHhNaW4sIHlNaW4sIHhNYXgsIHlNYXgpIHtcbiAgICB0aGlzLl9jID0gdHJ1ZTtcbiAgICB0aGlzLl9hID0geE1pbjtcbiAgICB0aGlzLl9iID0geU1pbjtcbiAgICB0aGlzLl9kID0geE1heDtcbiAgICB0aGlzLl9lID0geU1heDtcbiAgfVxuXG4gIC8qKlxuICAgKiBYIGNvb3JkaW5hdGUgb2YgdGhlIHZlY3Rvci5cbiAgICogQG1lbWJlcm9mIFZlY3RvclxuICAgKiBAcHJvcGVydHkge051bWJlcn0geFxuICAgKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3g7XG4gIH1cblxuICAvKipcbiAgICogWSBjb29yZGluYXRlIG9mIHRoZSB2ZWN0b3IuXG4gICAqIEBtZW1iZXJvZiBWZWN0b3JcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHlcbiAgICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLl95O1xuICB9XG5cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLl94ID0gKHRoaXMuX2MgPyBjbGFtcCh0aGlzLl9hLCB0aGlzLl9kLCB2YWx1ZSkgOiB2YWx1ZSk7XG4gIH1cblxuICBzZXQgeSh2YWx1ZSkge1xuICAgIHRoaXMuX3kgPSAodGhpcy5fYyA/IGNsYW1wKHRoaXMuX2IsIHRoaXMuX2UsIHZhbHVlKSA6IHZhbHVlKTtcbiAgfVxuICAvLyBAZW5kaWZcbn1cblxuZnVuY3Rpb24gZmFjdG9yeSQxKCkge1xuICByZXR1cm4gbmV3IFZlY3RvciguLi5hcmd1bWVudHMpO1xufVxuZmFjdG9yeSQxLnByb3RvdHlwZSA9IFZlY3Rvci5wcm90b3R5cGU7XG5mYWN0b3J5JDEuY2xhc3MgPSBWZWN0b3I7XG5cbi8qKlxuICogVGhpcyBpcyBhIHByaXZhdGUgY2xhc3MgdGhhdCBpcyB1c2VkIGp1c3QgdG8gaGVscCBtYWtlIHRoZSBHYW1lT2JqZWN0IGNsYXNzIG1vcmUgbWFuYWdlYWJsZSBhbmQgc21hbGxlci5cbiAqXG4gKiBJdCBtYWludGFpbnMgZXZlcnl0aGluZyB0aGF0IGNhbiBiZSBjaGFuZ2VkIGluIHRoZSB1cGRhdGUgZnVuY3Rpb246XG4gKiBwb3NpdGlvblxuICogdmVsb2NpdHlcbiAqIGFjY2VsZXJhdGlvblxuICogdHRsXG4gKi9cbmNsYXNzIFVwZGF0YWJsZSB7XG5cbiAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgIHJldHVybiB0aGlzLmluaXQocHJvcGVydGllcyk7XG4gIH1cblxuICBpbml0KHByb3BlcnRpZXMgPSB7fSkge1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBkZWZhdWx0c1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ2FtZSBvYmplY3RzIHBvc2l0aW9uIHZlY3Rvci4gUmVwcmVzZW50cyB0aGUgbG9jYWwgcG9zaXRpb24gb2YgdGhlIG9iamVjdCBhcyBvcHBvc2VkIHRvIHRoZSBbd29ybGRdKGFwaS9nYW1lT2JqZWN0I3dvcmxkKSBwb3NpdGlvbi5cbiAgICAgKiBAcHJvcGVydHkge1ZlY3Rvcn0gcG9zaXRpb25cbiAgICAgKiBAbWVtYmVyb2YgR2FtZU9iamVjdFxuICAgICAqIEBwYWdlIEdhbWVPYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gZmFjdG9yeSQxKCk7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIG9wdGlvbmFsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9WRUxPQ0lUWVxuICAgIC8qKlxuICAgICAqIFRoZSBnYW1lIG9iamVjdHMgdmVsb2NpdHkgdmVjdG9yLlxuICAgICAqIEBtZW1iZXJvZiBHYW1lT2JqZWN0XG4gICAgICogQHByb3BlcnR5IHtWZWN0b3J9IHZlbG9jaXR5XG4gICAgICogQHBhZ2UgR2FtZU9iamVjdFxuICAgICAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSBmYWN0b3J5JDEoKTtcbiAgICAvLyBAZW5kaWZcblxuICAgIC8vIEBpZmRlZiBHQU1FT0JKRUNUX0FDQ0VMRVJBVElPTlxuICAgIC8qKlxuICAgICAqIFRoZSBnYW1lIG9iamVjdHMgYWNjZWxlcmF0aW9uIHZlY3Rvci5cbiAgICAgKiBAbWVtYmVyb2YgR2FtZU9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7VmVjdG9yfSBhY2NlbGVyYXRpb25cbiAgICAgKiBAcGFnZSBHYW1lT2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5hY2NlbGVyYXRpb24gPSBmYWN0b3J5JDEoKTtcbiAgICAvLyBAZW5kaWZcblxuICAgIC8vIEBpZmRlZiBHQU1FT0JKRUNUX1RUTFxuICAgIC8qKlxuICAgICAqIEhvdyBtYXkgZnJhbWVzIHRoZSBnYW1lIG9iamVjdCBzaG91bGQgYmUgYWxpdmUuXG4gICAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdHRsXG4gICAgICogQHBhZ2UgR2FtZU9iamVjdFxuICAgICAqL1xuICAgIHRoaXMudHRsID0gSW5maW5pdHk7XG4gICAgLy8gQGVuZGlmXG5cbiAgICAvLyBhZGQgYWxsIHByb3BlcnRpZXMgdG8gdGhlIG9iamVjdCwgb3ZlcnJpZGluZyBhbnkgZGVmYXVsdHNcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BlcnRpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdhbWUgb2JqZWN0IGFuZCBhbGwgY2hpbGRyZW4gdXNpbmcgdGhlaXIgdmVsb2NpdHkgYW5kIGFjY2VsZXJhdGlvbi4gQ2FsbHMgdGhlIGdhbWUgb2JqZWN0cyBbYWR2YW5jZSgpXShhcGkvZ2FtZU9iamVjdCNhZHZhbmNlKSBmdW5jdGlvbi5cbiAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICogQGZ1bmN0aW9uIHVwZGF0ZVxuICAgKiBAcGFnZSBHYW1lT2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZHRdIC0gVGltZSBzaW5jZSBsYXN0IHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZShkdCkge1xuICAgIHRoaXMuYWR2YW5jZShkdCk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgZ2FtZSBvYmplY3QgYnkgaXRzIGFjY2VsZXJhdGlvbiBhbmQgdmVsb2NpdHkuIElmIHlvdSBwYXNzIGBkdGAgaXQgd2lsbCBtdWx0aXBseSB0aGUgdmVjdG9yIGFuZCBhY2NlbGVyYXRpb24gYnkgdGhhdCBudW1iZXIuIFRoaXMgbWVhbnMgdGhlIGBkeGAsIGBkeWAsIGBkZHhgIGFuZCBgZGR5YCBzaG91bGQgYmUgdGhlIGhvdyBmYXIgeW91IHdhbnQgdGhlIG9iamVjdCB0byBtb3ZlIGluIDEgc2Vjb25kIHJhdGhlciB0aGFuIGluIDEgZnJhbWUuXG4gICAqXG4gICAqIElmIHlvdSBvdmVycmlkZSB0aGUgZ2FtZSBvYmplY3RzIFt1cGRhdGUoKV0oYXBpL2dhbWVPYmplY3QjdXBkYXRlKSBmdW5jdGlvbiB3aXRoIHlvdXIgb3duIHVwZGF0ZSBmdW5jdGlvbiwgeW91IGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gbW92ZSB0aGUgZ2FtZSBvYmplY3Qgbm9ybWFsbHkuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IEdhbWVPYmplY3QgfSBmcm9tICdrb250cmEnO1xuICAgKlxuICAgKiBsZXQgZ2FtZU9iamVjdCA9IEdhbWVPYmplY3Qoe1xuICAgKiAgIHg6IDEwMCxcbiAgICogICB5OiAyMDAsXG4gICAqICAgd2lkdGg6IDIwLFxuICAgKiAgIGhlaWdodDogNDAsXG4gICAqICAgZHg6IDUsXG4gICAqICAgZHk6IDIsXG4gICAqICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICogICAgIC8vIG1vdmUgdGhlIGdhbWUgb2JqZWN0IG5vcm1hbGx5XG4gICAqICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICpcbiAgICogICAgIC8vIGNoYW5nZSB0aGUgdmVsb2NpdHkgYXQgdGhlIGVkZ2VzIG9mIHRoZSBjYW52YXNcbiAgICogICAgIGlmICh0aGlzLnggPCAwIHx8XG4gICAqICAgICAgICAgdGhpcy54ICsgdGhpcy53aWR0aCA+IHRoaXMuY29udGV4dC5jYW52YXMud2lkdGgpIHtcbiAgICogICAgICAgdGhpcy5keCA9IC10aGlzLmR4O1xuICAgKiAgICAgfVxuICAgKiAgICAgaWYgKHRoaXMueSA8IDAgfHxcbiAgICogICAgICAgICB0aGlzLnkgKyB0aGlzLmhlaWdodCA+IHRoaXMuY29udGV4dC5jYW52YXMuaGVpZ2h0KSB7XG4gICAqICAgICAgIHRoaXMuZHkgPSAtdGhpcy5keTtcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICogQGZ1bmN0aW9uIGFkdmFuY2VcbiAgICogQHBhZ2UgR2FtZU9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R0XSAtIFRpbWUgc2luY2UgbGFzdCB1cGRhdGUuXG4gICAqXG4gICAqL1xuICBhZHZhbmNlKGR0KSB7XG4gICAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfVkVMT0NJVFlcbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9BQ0NFTEVSQVRJT05cbiAgICBsZXQgYWNjZWxlcmF0aW9uID0gdGhpcy5hY2NlbGVyYXRpb247XG5cbiAgICAvLyBAaWZkZWYgVkVDVE9SX1NDQUxFXG4gICAgaWYgKGR0KSB7XG4gICAgICBhY2NlbGVyYXRpb24gPSBhY2NlbGVyYXRpb24uc2NhbGUoZHQpO1xuICAgIH1cbiAgICAvLyBAZW5kaWZcblxuICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5LmFkZChhY2NlbGVyYXRpb24pO1xuICAgIC8vIEBlbmRpZlxuICAgIC8vIEBlbmRpZlxuXG4gICAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfVkVMT0NJVFlcbiAgICBsZXQgdmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5O1xuXG4gICAgLy8gQGlmZGVmIFZFQ1RPUl9TQ0FMRVxuICAgIGlmIChkdCkge1xuICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eS5zY2FsZShkdCk7XG4gICAgfVxuICAgIC8vIEBlbmRpZlxuXG4gICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24uYWRkKHZlbG9jaXR5KTtcbiAgICB0aGlzLl9wYygpO1xuICAgIC8vIEBlbmRpZlxuXG4gICAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfVFRMXG4gICAgdGhpcy50dGwtLTtcbiAgICAvLyBAZW5kaWZcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHZlbG9jaXR5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfVkVMT0NJVFlcbiAgLyoqXG4gICAqIFggY29vcmRpbmF0ZSBvZiB0aGUgdmVsb2NpdHkgdmVjdG9yLlxuICAgKiBAbWVtYmVyb2YgR2FtZU9iamVjdFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gZHhcbiAgICogQHBhZ2UgR2FtZU9iamVjdFxuICAgKi9cbiAgZ2V0IGR4KCkge1xuICAgIHJldHVybiB0aGlzLnZlbG9jaXR5Lng7XG4gIH1cblxuICAvKipcbiAgICogWSBjb29yZGluYXRlIG9mIHRoZSB2ZWxvY2l0eSB2ZWN0b3IuXG4gICAqIEBtZW1iZXJvZiBHYW1lT2JqZWN0XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkeVxuICAgKiBAcGFnZSBHYW1lT2JqZWN0XG4gICAqL1xuICBnZXQgZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkueTtcbiAgfVxuXG4gIHNldCBkeCh2YWx1ZSkge1xuICAgIHRoaXMudmVsb2NpdHkueCA9IHZhbHVlO1xuICB9XG5cbiAgc2V0IGR5KHZhbHVlKSB7XG4gICAgdGhpcy52ZWxvY2l0eS55ID0gdmFsdWU7XG4gIH1cbiAgLy8gQGVuZGlmXG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gYWNjZWxlcmF0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfQUNDRUxFUkFUSU9OXG4gIC8qKlxuICAgKiBYIGNvb3JkaW5hdGUgb2YgdGhlIGFjY2VsZXJhdGlvbiB2ZWN0b3IuXG4gICAqIEBtZW1iZXJvZiBHYW1lT2JqZWN0XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZHhcbiAgICogQHBhZ2UgR2FtZU9iamVjdFxuICAgKi9cbiAgZ2V0IGRkeCgpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NlbGVyYXRpb24ueDtcbiAgfVxuXG4gIC8qKlxuICAgKiBZIGNvb3JkaW5hdGUgb2YgdGhlIGFjY2VsZXJhdGlvbiB2ZWN0b3IuXG4gICAqIEBtZW1iZXJvZiBHYW1lT2JqZWN0XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZHlcbiAgICogQHBhZ2UgR2FtZU9iamVjdFxuICAgKi9cbiAgZ2V0IGRkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NlbGVyYXRpb24ueTtcbiAgfVxuXG4gIHNldCBkZHgodmFsdWUpIHtcbiAgICB0aGlzLmFjY2VsZXJhdGlvbi54ID0gdmFsdWU7XG4gIH1cblxuICBzZXQgZGR5KHZhbHVlKSB7XG4gICAgdGhpcy5hY2NlbGVyYXRpb24ueSA9IHZhbHVlO1xuICB9XG4gIC8vIEBlbmRpZlxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHR0bFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEBpZmRlZiBHQU1FT0JKRUNUX1RUTFxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGdhbWUgb2JqZWN0IGlzIGFsaXZlLlxuICAgKiBAbWVtYmVyb2YgR2FtZU9iamVjdFxuICAgKiBAZnVuY3Rpb24gaXNBbGl2ZVxuICAgKiBAcGFnZSBHYW1lT2JqZWN0XG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdhbWUgb2JqZWN0cyBbdHRsXShhcGkvZ2FtZU9iamVjdCN0dGwpIHByb3BlcnR5IGlzIGFib3ZlIGAwYCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBpc0FsaXZlKCkge1xuICAgIHJldHVybiB0aGlzLnR0bCA+IDA7XG4gIH1cbiAgLy8gQGVuZGlmXG5cbiAgX3BjKCkge31cbn1cblxuLy8gbm9vcCBmdW5jdGlvblxubGV0IG5vb3AgPSAoKSA9PiB7fTtcblxuLy8gc3R5bGUgdXNlZCBmb3IgRE9NIG5vZGVzIG5lZWRlZCBmb3Igc2NyZWVuIHJlYWRlcnNcbmxldCBzck9ubHlTdHlsZSA9ICdwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxcHg7aGVpZ2h0OjFweDtvdmVyZmxvdzpoaWRkZW47JztcblxuLy8gYXBwZW5kIGEgbm9kZSBkaXJlY3RseSBhZnRlciB0aGUgY2FudmFzIGFuZCBhcyB0aGUgbGFzdFxuLy8gZWxlbWVudCBvZiBvdGhlciBrb250cmEgbm9kZXNcbmZ1bmN0aW9uIGFkZFRvRG9tKG5vZGUsIGNhbnZhcykge1xuICBsZXQgY29udGFpbmVyID0gY2FudmFzLnBhcmVudE5vZGU7XG5cbiAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEta29udHJhJywgJycpO1xuICBpZiAoY29udGFpbmVyKSB7XG4gICAgbGV0IHRhcmdldCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdbZGF0YS1rb250cmFdOmxhc3Qtb2YtdHlwZScpIHx8IGNhbnZhcztcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5uZXh0U2libGluZyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIG9mIG1vc3QgcmVuZGVyYWJsZSBjbGFzc2VzLiBIYW5kbGVzIHRoaW5ncyBzdWNoIGFzIHBvc2l0aW9uLCByb3RhdGlvbiwgYW5jaG9yLCBhbmQgdGhlIHVwZGF0ZSBhbmQgcmVuZGVyIGxpZmUgY3ljbGUuXG4gKlxuICogVHlwaWNhbGx5IHlvdSBkb24ndCBjcmVhdGUgYSBHYW1lT2JqZWN0IGRpcmVjdGx5LCBidXQgcmF0aGVyIGV4dGVuZCBpdCBmb3IgbmV3IGNsYXNzZXMuXG4gKiBAY2xhc3MgR2FtZU9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gLSBQcm9wZXJ0aWVzIG9mIHRoZSBnYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvcGVydGllcy54XSAtIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb24gdmVjdG9yLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wZXJ0aWVzLnldIC0gWSBjb29yZGluYXRlIG9mIHRoZSBwb3NpdGlvbiB2ZWN0b3IuXG4gKiBAcGFyYW0ge051bWJlcn0gW3Byb3BlcnRpZXMud2lkdGhdIC0gV2lkdGggb2YgdGhlIGdhbWUgb2JqZWN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wZXJ0aWVzLmhlaWdodF0gLSBIZWlnaHQgb2YgdGhlIGdhbWUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbcHJvcGVydGllcy5jb250ZXh0XSAtIFRoZSBjb250ZXh0IHRoZSBnYW1lIG9iamVjdCBzaG91bGQgZHJhdyB0by4gRGVmYXVsdHMgdG8gW2NvcmUuZ2V0Q29udGV4dCgpXShhcGkvY29yZSNnZXRDb250ZXh0KS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW3Byb3BlcnRpZXMuZHhdIC0gWCBjb29yZGluYXRlIG9mIHRoZSB2ZWxvY2l0eSB2ZWN0b3IuXG4gKiBAcGFyYW0ge051bWJlcn0gW3Byb3BlcnRpZXMuZHldIC0gWSBjb29yZGluYXRlIG9mIHRoZSB2ZWxvY2l0eSB2ZWN0b3IuXG4gKiBAcGFyYW0ge051bWJlcn0gW3Byb3BlcnRpZXMuZGR4XSAtIFggY29vcmRpbmF0ZSBvZiB0aGUgYWNjZWxlcmF0aW9uIHZlY3Rvci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvcGVydGllcy5kZHldIC0gWSBjb29yZGluYXRlIG9mIHRoZSBhY2NlbGVyYXRpb24gdmVjdG9yLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wZXJ0aWVzLnR0bD1JbmZpbml0eV0gLSBIb3cgbWFueSBmcmFtZXMgdGhlIGdhbWUgb2JqZWN0IHNob3VsZCBiZSBhbGl2ZS4gVXNlZCBieSBbUG9vbF0oYXBpL3Bvb2wpLlxuICpcbiAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gW3Byb3BlcnRpZXMuYW5jaG9yPXt4OjAseTowfV0gLSBUaGUgeCBhbmQgeSBvcmlnaW4gb2YgdGhlIGdhbWUgb2JqZWN0LiB7eDowLCB5OjB9IGlzIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGdhbWUgb2JqZWN0LCB7eDoxLCB5OjF9IGlzIHRoZSBib3R0b20gcmlnaHQgY29ybmVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wZXJ0aWVzLnN4PTBdIC0gVGhlIHggY2FtZXJhIHBvc2l0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wZXJ0aWVzLnN5PTBdIC0gVGhlIHkgY2FtZXJhIHBvc2l0aW9uLlxuICogQHBhcmFtIHtHYW1lT2JqZWN0W119IFtwcm9wZXJ0aWVzLmNoaWxkcmVuXSAtIENoaWxkcmVuIHRvIGFkZCB0byB0aGUgZ2FtZSBvYmplY3QuXG4gKiBAcGFyYW0ge051bWJlcn0gW3Byb3BlcnRpZXMub3BhY2l0eT0xXSAtIFRoZSBvcGFjaXR5IG9mIHRoZSBnYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvcGVydGllcy5yb3RhdGlvbj0wXSAtIFRoZSByb3RhdGlvbiBhcm91bmQgdGhlIGFuY2hvciBpbiByYWRpYW5zLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wZXJ0aWVzLnNjYWxlWD0xXSAtIFRoZSB4IHNjYWxlIG9mIHRoZSBnYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvcGVydGllcy5zY2FsZVk9MV0gLSBUaGUgeSBzY2FsZSBvZiB0aGUgZ2FtZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsoZHQ/OiBudW1iZXIpID0+IHZvaWR9IFtwcm9wZXJ0aWVzLnVwZGF0ZV0gLSBGdW5jdGlvbiBjYWxsZWQgZXZlcnkgZnJhbWUgdG8gdXBkYXRlIHRoZSBnYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wZXJ0aWVzLnJlbmRlcl0gLSBGdW5jdGlvbiBjYWxsZWQgZXZlcnkgZnJhbWUgdG8gcmVuZGVyIHRoZSBnYW1lIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gey4uLip9IHByb3BlcnRpZXMucHJvcHMgLSBBbnkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHlvdSBuZWVkIGFkZGVkIHRvIHRoZSBnYW1lIG9iamVjdC4gRm9yIGV4YW1wbGUsIGlmIHlvdSBwYXNzIGBnYW1lT2JqZWN0KHt0eXBlOiAncGxheWVyJ30pYCB0aGVuIHRoZSBnYW1lIG9iamVjdCB3aWxsIGFsc28gaGF2ZSBhIHByb3BlcnR5IG9mIHRoZSBzYW1lIG5hbWUgYW5kIHZhbHVlLiBZb3UgY2FuIHBhc3MgYXMgbWFueSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXMgeW91IHdhbnQuXG4gKi9cbmNsYXNzIEdhbWVPYmplY3QgZXh0ZW5kcyBVcGRhdGFibGUge1xuICAvKipcbiAgICogQGRvY3MgZG9jcy9hcGlfZG9jcy9nYW1lT2JqZWN0LmpzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBmdW5jdGlvbiB0byByZWluaXRpYWxpemUgYSBnYW1lIG9iamVjdC4gSXQgdGFrZXMgdGhlIHNhbWUgcHJvcGVydGllcyBvYmplY3QgYXMgdGhlIGNvbnN0cnVjdG9yLiBVc2VmdWwgaXQgeW91IHdhbnQgdG8gcmVwdXJwb3NlIGEgZ2FtZSBvYmplY3QuXG4gICAqIEBtZW1iZXJvZiBHYW1lT2JqZWN0XG4gICAqIEBmdW5jdGlvbiBpbml0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gUHJvcGVydGllcyBvZiB0aGUgZ2FtZSBvYmplY3QuXG4gICAqL1xuICBpbml0KHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZGVmYXVsdHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBnYW1lIG9iamVjdC4gUmVwcmVzZW50cyB0aGUgbG9jYWwgd2lkdGggb2YgdGhlIG9iamVjdCBhcyBvcHBvc2VkIHRvIHRoZSBbd29ybGRdKGFwaS9nYW1lT2JqZWN0I3dvcmxkKSB3aWR0aC5cbiAgICAgKiBAbWVtYmVyb2YgR2FtZU9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB3aWR0aFxuICAgICAqL1xuICAgIHdpZHRoID0gMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGdhbWUgb2JqZWN0LiBSZXByZXNlbnRzIHRoZSBsb2NhbCBoZWlnaHQgb2YgdGhlIG9iamVjdCBhcyBvcHBvc2VkIHRvIHRoZSBbd29ybGRdKGFwaS9nYW1lT2JqZWN0I3dvcmxkKSBoZWlnaHQuXG4gICAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gaGVpZ2h0XG4gICAgICovXG4gICAgaGVpZ2h0ID0gMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZXh0IHRoZSBnYW1lIG9iamVjdCB3aWxsIGRyYXcgdG8uXG4gICAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICAgKiBAcHJvcGVydHkge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuICAgICAqL1xuICAgIGNvbnRleHQgPSBnZXRDb250ZXh0KCksXG5cbiAgICByZW5kZXIgPSB0aGlzLmRyYXcsXG4gICAgdXBkYXRlID0gdGhpcy5hZHZhbmNlLFxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBvcHRpb25hbHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfR1JPVVBcbiAgICAvKipcbiAgICAgKiBUaGUgZ2FtZSBvYmplY3RzIHBhcmVudCBvYmplY3QuXG4gICAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICAgKiBAcHJvcGVydHkge0dhbWVPYmplY3R8bnVsbH0gcGFyZW50XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ2FtZSBvYmplY3RzIGNoaWxkcmVuIG9iamVjdHMuXG4gICAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICAgKiBAcHJvcGVydHkge0dhbWVPYmplY3RbXX0gY2hpbGRyZW5cbiAgICAgKi9cbiAgICBjaGlsZHJlbiA9IFtdLFxuICAgIC8vIEBlbmRpZlxuXG4gICAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfQU5DSE9SXG4gICAgLyoqXG4gICAgICogVGhlIHggYW5kIHkgb3JpZ2luIG9mIHRoZSBnYW1lIG9iamVjdC4ge3g6MCwgeTowfSBpcyB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBnYW1lIG9iamVjdCwge3g6MSwgeToxfSBpcyB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lci5cbiAgICAgKiBAbWVtYmVyb2YgR2FtZU9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gYW5jaG9yXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGV4Y2x1ZGUtY29kZTpzdGFydFxuICAgICAqIGxldCB7IEdhbWVPYmplY3QgfSA9IGtvbnRyYTtcbiAgICAgKiAvLyBleGNsdWRlLWNvZGU6ZW5kXG4gICAgICogLy8gZXhjbHVkZS1zY3JpcHQ6c3RhcnRcbiAgICAgKiBpbXBvcnQgeyBHYW1lT2JqZWN0IH0gZnJvbSAna29udHJhJztcbiAgICAgKiAvLyBleGNsdWRlLXNjcmlwdDplbmRcbiAgICAgKlxuICAgICAqIGxldCBnYW1lT2JqZWN0ID0gR2FtZU9iamVjdCh7XG4gICAgICogICB4OiAxNTAsXG4gICAgICogICB5OiAxMDAsXG4gICAgICogICB3aWR0aDogNTAsXG4gICAgICogICBoZWlnaHQ6IDUwLFxuICAgICAqICAgY29sb3I6ICdyZWQnLFxuICAgICAqICAgLy8gZXhjbHVkZS1jb2RlOnN0YXJ0XG4gICAgICogICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAqICAgLy8gZXhjbHVkZS1jb2RlOmVuZFxuICAgICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICogICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCgwLCAwLCB0aGlzLmhlaWdodCwgdGhpcy53aWR0aCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkcmF3T3JpZ2luKGdhbWVPYmplY3QpIHtcbiAgICAgKiAgIGdhbWVPYmplY3QuY29udGV4dC5maWxsU3R5bGUgPSAneWVsbG93JztcbiAgICAgKiAgIGdhbWVPYmplY3QuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgKiAgIGdhbWVPYmplY3QuY29udGV4dC5hcmMoZ2FtZU9iamVjdC54LCBnYW1lT2JqZWN0LnksIDMsIDAsIDIqTWF0aC5QSSk7XG4gICAgICogICBnYW1lT2JqZWN0LmNvbnRleHQuZmlsbCgpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGdhbWVPYmplY3QucmVuZGVyKCk7XG4gICAgICogZHJhd09yaWdpbihnYW1lT2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGdhbWVPYmplY3QuYW5jaG9yID0ge3g6IDAuNSwgeTogMC41fTtcbiAgICAgKiBnYW1lT2JqZWN0LnggPSAzMDA7XG4gICAgICogZ2FtZU9iamVjdC5yZW5kZXIoKTtcbiAgICAgKiBkcmF3T3JpZ2luKGdhbWVPYmplY3QpO1xuICAgICAqXG4gICAgICogZ2FtZU9iamVjdC5hbmNob3IgPSB7eDogMSwgeTogMX07XG4gICAgICogZ2FtZU9iamVjdC54ID0gNDUwO1xuICAgICAqIGdhbWVPYmplY3QucmVuZGVyKCk7XG4gICAgICogZHJhd09yaWdpbihnYW1lT2JqZWN0KTtcbiAgICAgKi9cbiAgICBhbmNob3IgPSB7eDogMCwgeTogMH0sXG4gICAgLy8gQGVuZGlmXG5cbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9DQU1FUkFcbiAgICAvKipcbiAgICAgKiBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjYW1lcmEuXG4gICAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3hcbiAgICAgKi9cbiAgICBzeCA9IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjYW1lcmEuXG4gICAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3lcbiAgICAgKi9cbiAgICBzeSA9IDAsXG4gICAgLy8gQGVuZGlmXG5cbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9PUEFDSVRZXG4gICAgLyoqXG4gICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIG9iamVjdC4gUmVwcmVzZW50cyB0aGUgbG9jYWwgb3BhY2l0eSBvZiB0aGUgb2JqZWN0IGFzIG9wcG9zZWQgdG8gdGhlIFt3b3JsZF0oYXBpL2dhbWVPYmplY3Qjd29ybGQpIG9wYWNpdHkuXG4gICAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gb3BhY2l0eVxuICAgICAqL1xuICAgIG9wYWNpdHkgPSAxLFxuICAgIC8vIEBlbmRpZlxuXG4gICAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfUk9UQVRJT05cbiAgICAvKipcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIGdhbWUgb2JqZWN0IGFyb3VuZCB0aGUgYW5jaG9yIGluIHJhZGlhbnMuIFJlcHJlc2VudHMgdGhlIGxvY2FsIHJvdGF0aW9uIG9mIHRoZSBvYmplY3QgYXMgb3Bwb3NlZCB0byB0aGUgW3dvcmxkXShhcGkvZ2FtZU9iamVjdCN3b3JsZCkgcm90YXRpb24uXG4gICAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcm90YXRpb25cbiAgICAgKi9cbiAgICByb3RhdGlvbiA9IDAsXG4gICAgLy8gQGVuZGlmXG5cbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9TQ0FMRVxuICAgIC8qKlxuICAgICAqIFRoZSB4IHNjYWxlIG9mIHRoZSBvYmplY3QuIFJlcHJlc2VudHMgdGhlIGxvY2FsIHggc2NhbGUgb2YgdGhlIG9iamVjdCBhcyBvcHBvc2VkIHRvIHRoZSBbd29ybGRdKGFwaS9nYW1lT2JqZWN0I3dvcmxkKSB4IHNjYWxlLlxuICAgICAqIEBtZW1iZXJvZiBHYW1lT2JqZWN0XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjYWxlWFxuICAgICAqL1xuICAgIHNjYWxlWCA9IDEsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgeSBzY2FsZSBvZiB0aGUgb2JqZWN0LiBSZXByZXNlbnRzIHRoZSBsb2NhbCB5IHNjYWxlIG9mIHRoZSBvYmplY3QgYXMgb3Bwb3NlZCB0byB0aGUgW3dvcmxkXShhcGkvZ2FtZU9iamVjdCN3b3JsZCkgeSBzY2FsZS5cbiAgICAgKiBAbWVtYmVyb2YgR2FtZU9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY2FsZVlcbiAgICAgKi9cbiAgICBzY2FsZVkgPSAxLFxuICAgIC8vIEBlbmRpZlxuXG4gICAgLi4ucHJvcHNcbiAgfSA9IHt9KSB7XG5cbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9HUk9VUFxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAvLyBAZW5kaWZcblxuICAgIC8vIGJ5IHNldHRpbmcgZGVmYXVsdHMgdG8gdGhlIHBhcmFtZXRlcnMgYW5kIHBhc3NpbmcgdGhlbSBpbnRvXG4gICAgLy8gdGhlIGluaXQsIHdlIGNhbiBlbnN1cmUgdGhhdCBhIHBhcmVudCBjbGFzcyBjYW4gc2V0IG92ZXJyaWRpbmdcbiAgICAvLyBkZWZhdWx0cyBhbmQgdGhlIEdhbWVPYmplY3Qgd29uJ3QgdW5kbyBpdCAoaWYgd2Ugc2V0XG4gICAgLy8gYHRoaXMud2lkdGhgIHRoZW4gbm8gcGFyZW50IGNvdWxkIHByb3ZpZGUgYSBkZWZhdWx0IHZhbHVlIGZvclxuICAgIC8vIHdpZHRoKVxuICAgIHN1cGVyLmluaXQoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBjb250ZXh0LFxuXG4gICAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9BTkNIT1JcbiAgICAgIGFuY2hvcixcbiAgICAgIC8vIEBlbmRpZlxuXG4gICAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9DQU1FUkFcbiAgICAgIHN4LFxuICAgICAgc3ksXG4gICAgICAvLyBAZW5kaWZcblxuICAgICAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfT1BBQ0lUWVxuICAgICAgb3BhY2l0eSxcbiAgICAgIC8vIEBlbmRpZlxuXG4gICAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9ST1RBVElPTlxuICAgICAgcm90YXRpb24sXG4gICAgICAvLyBAZW5kaWZcblxuICAgICAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfU0NBTEVcbiAgICAgIHNjYWxlWCxcbiAgICAgIHNjYWxlWSxcbiAgICAgIC8vIEBlbmRpZlxuXG4gICAgICAuLi5wcm9wc1xuICAgIH0pO1xuXG4gICAgLy8gZGkgPSBkb25lIGluaXRcbiAgICB0aGlzLl9kaSA9IHRydWU7XG4gICAgdGhpcy5fdXcoKTtcblxuICAgIC8vIEBpZmRlZiBHQU1FT0JKRUNUX0dST1VQXG4gICAgY2hpbGRyZW4ubWFwKGNoaWxkID0+IHRoaXMuYWRkQ2hpbGQoY2hpbGQpKTtcbiAgICAvLyBAZW5kaWZcblxuICAgIC8vIHJmID0gcmVuZGVyIGZ1bmN0aW9uXG4gICAgdGhpcy5fcmYgPSByZW5kZXI7XG5cbiAgICAvLyB1ZiA9IHVwZGF0ZSBmdW5jdGlvblxuICAgIHRoaXMuX3VmID0gdXBkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbGwgY2hpbGRyZW5cbiAgICovXG4gIHVwZGF0ZShkdCkge1xuICAgIHRoaXMuX3VmKGR0KTtcblxuICAgIC8vIEBpZmRlZiBHQU1FT0JKRUNUX0dST1VQXG4gICAgdGhpcy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudXBkYXRlICYmIGNoaWxkLnVwZGF0ZShkdCkpO1xuICAgIC8vIEBlbmRpZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgZ2FtZSBvYmplY3QgYW5kIGFsbCBjaGlsZHJlbi4gQ2FsbHMgdGhlIGdhbWUgb2JqZWN0cyBbZHJhdygpXShhcGkvZ2FtZU9iamVjdCNkcmF3KSBmdW5jdGlvbi5cbiAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICogQGZ1bmN0aW9uIHJlbmRlclxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZmlsdGVyT2JqZWN0c10gLSBbQXJyYXkucHJvdG90eXBlLmZpbHRlcigpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXIpIGZ1bmN0aW9uIHdoaWNoIGlzIHVzZWQgdG8gZmlsdGVyIHdoaWNoIGNoaWxkcmVuIHRvIHJlbmRlci5cbiAgICovXG4gIHJlbmRlcihmaWx0ZXJPYmplY3RzKSB7XG4gICAgbGV0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAvLyAxKSB0cmFuc2xhdGUgdG8gcG9zaXRpb25cbiAgICAvL1xuICAgIC8vIGl0J3MgZmFzdGVyIHRvIG9ubHkgdHJhbnNsYXRlIGlmIG9uZSBvZiB0aGUgdmFsdWVzIGlzIG5vbi16ZXJvXG4gICAgLy8gcmF0aGVyIHRoYW4gYWx3YXlzIHRyYW5zbGF0aW5nXG4gICAgLy8gQHNlZSBodHRwczovL2pzcGVyZi5jb20vdHJhbnNsYXRlLW9yLWlmLXN0YXRlbWVudC8yXG4gICAgaWYgKHRoaXMueCB8fCB0aGlzLnkpIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG5cbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9ST1RBVElPTlxuICAgIC8vIDIpIHJvdGF0ZSBhcm91bmQgdGhlIGFuY2hvclxuICAgIC8vXG4gICAgLy8gaXQncyBmYXN0ZXIgdG8gb25seSByb3RhdGUgd2hlbiBzZXQgcmF0aGVyIHRoYW4gYWx3YXlzIHJvdGF0aW5nXG4gICAgLy8gQHNlZSBodHRwczovL2pzcGVyZi5jb20vcm90YXRlLW9yLWlmLXN0YXRlbWVudC8yXG4gICAgaWYgKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNvbnRleHQucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgIH1cbiAgICAvLyBAZW5kaWZcblxuICAgIC8vIEBpZmRlZiBHQU1FT0JKRUNUX0NBTUVSQVxuICAgIC8vIDMpIHRyYW5zbGF0ZSB0byB0aGUgY2FtZXJhIHBvc2l0aW9uIGFmdGVyIHJvdGF0aW9uIHNvIGNhbWVyYVxuICAgIC8vIHZhbHVlcyBhcmUgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgcm90YXRpb24gcmF0aGVyIHRoYW4gYWx3YXlzXG4gICAgLy8gYWxvbmcgdGhlIHgveSBheGlzXG4gICAgaWYgKHRoaXMuc3ggfHwgdGhpcy5zeSkge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLXRoaXMuc3gsIC10aGlzLnN5KTtcbiAgICB9XG4gICAgLy8gQGVuZGlmXG5cbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9TQ0FMRVxuICAgIC8vIDQpIHNjYWxlIGFmdGVyIHRyYW5zbGF0aW9uIHRvIHBvc2l0aW9uIHNvIG9iamVjdCBjYW4gYmVcbiAgICAvLyBzY2FsZWQgaW4gcGxhY2UgKHJhdGhlciB0aGFuIHNjYWxpbmcgcG9zaXRpb24gYXMgd2VsbCkuXG4gICAgLy9cbiAgICAvLyBpdCdzIGZhc3RlciB0byBvbmx5IHNjYWxlIGlmIG9uZSBvZiB0aGUgdmFsdWVzIGlzIG5vdCAxXG4gICAgLy8gcmF0aGVyIHRoYW4gYWx3YXlzIHNjYWxpbmdcbiAgICAvLyBAc2VlIGh0dHBzOi8vanNwZXJmLmNvbS9zY2FsZS1vci1pZi1zdGF0ZW1lbnQvNFxuICAgIGlmICh0aGlzLnNjYWxlWCAhPSAxIHx8IHRoaXMuc2NhbGVZICE9IDEpIHtcbiAgICAgIGNvbnRleHQuc2NhbGUodGhpcy5zY2FsZVgsIHRoaXMuc2NhbGVZKTtcbiAgICB9XG4gICAgLy8gQGVuZGlmXG5cbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9BTkNIT1JcbiAgICAvLyA1KSB0cmFuc2xhdGUgdG8gdGhlIGFuY2hvciBzbyAoMCwwKSBpcyB0aGUgdG9wIGxlZnQgY29ybmVyXG4gICAgLy8gZm9yIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICBsZXQgYW5jaG9yWCA9IC10aGlzLndpZHRoICogdGhpcy5hbmNob3IueDtcbiAgICBsZXQgYW5jaG9yWSA9IC10aGlzLmhlaWdodCAqIHRoaXMuYW5jaG9yLnk7XG5cbiAgICBpZiAoYW5jaG9yWCB8fCBhbmNob3JZKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShhbmNob3JYLCBhbmNob3JZKTtcbiAgICB9XG4gICAgLy8gQGVuZGlmXG5cbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9PUEFDSVRZXG4gICAgLy8gaXQncyBub3QgcmVhbGx5IGFueSBmYXN0ZXIgdG8gZ2F0ZSB0aGUgZ2xvYmFsIGFscGhhXG4gICAgLy8gQHNlZSBodHRwczovL2pzcGVyZi5jb20vZ2xvYmFsLWFscGhhLW9yLWlmLXN0YXRlbWVudC8xXG4gICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5O1xuICAgIC8vIEBlbmRpZlxuXG4gICAgdGhpcy5fcmYoKTtcblxuICAgIC8vIEBpZmRlZiBHQU1FT0JKRUNUX0FOQ0hPUlxuICAgIC8vIDcpIHRyYW5zbGF0ZSBiYWNrIHRvIHRoZSBhbmNob3Igc28gY2hpbGRyZW4gdXNlIHRoZSBjb3JyZWN0XG4gICAgLy8geC95IHZhbHVlIGZyb20gdGhlIGFuY2hvclxuICAgIGlmIChhbmNob3JYIHx8IGFuY2hvclkpIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1hbmNob3JYLCAtYW5jaG9yWSk7XG4gICAgfVxuICAgIC8vIEBlbmRpZlxuXG4gICAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfR1JPVVBcbiAgICAvLyBwZXJmb3JtIGFsbCB0cmFuc2Zvcm1zIG9uIHRoZSBwYXJlbnQgYmVmb3JlIHJlbmRlcmluZyB0aGUgY2hpbGRyZW5cbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIGlmIChmaWx0ZXJPYmplY3RzKSB7XG4gICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmaWx0ZXJPYmplY3RzKTtcbiAgICB9XG4gICAgY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnJlbmRlciAmJiBjaGlsZC5yZW5kZXIoKSk7XG4gICAgLy8gQGVuZGlmXG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3IHRoZSBnYW1lIG9iamVjdCBhdCBpdHMgWCBhbmQgWSBwb3NpdGlvbiwgdGFraW5nIGludG8gYWNjb3VudCByb3RhdGlvbiwgc2NhbGUsIGFuZCBhbmNob3IuXG4gICAqXG4gICAqIERvIG5vdGUgdGhhdCB0aGUgY2FudmFzIGhhcyBiZWVuIHJvdGF0ZWQgYW5kIHRyYW5zbGF0ZWQgdG8gdGhlIG9iamVjdHMgcG9zaXRpb24gKHRha2luZyBpbnRvIGFjY291bnQgYW5jaG9yKSwgc28gezAsMH0gd2lsbCBiZSB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBnYW1lIG9iamVjdCB3aGVuIGRyYXdpbmcuXG4gICAqXG4gICAqIElmIHlvdSBvdmVycmlkZSB0aGUgZ2FtZSBvYmplY3RzIGByZW5kZXIoKWAgZnVuY3Rpb24gd2l0aCB5b3VyIG93biByZW5kZXIgZnVuY3Rpb24sIHlvdSBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGRyYXcgdGhlIGdhbWUgb2JqZWN0IG5vcm1hbGx5LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBsZXQgeyBHYW1lT2JqZWN0IH0gPSBrb250cmE7XG4gICAqXG4gICAqIGxldCBnYW1lT2JqZWN0ID0gR2FtZU9iamVjdCh7XG4gICAqICB4OiAyOTAsXG4gICAqICB5OiA4MCxcbiAgICogIHdpZHRoOiAyMCxcbiAgICogIGhlaWdodDogNDAsXG4gICAqXG4gICAqICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAvLyBkcmF3IHRoZSBnYW1lIG9iamVjdCBub3JtYWxseSAocGVyZm9ybSByb3RhdGlvbiBhbmQgb3RoZXIgdHJhbnNmb3JtcylcbiAgICogICAgdGhpcy5kcmF3KCk7XG4gICAqXG4gICAqICAgIC8vIG91dGxpbmUgdGhlIGdhbWUgb2JqZWN0XG4gICAqICAgIHRoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9ICd5ZWxsb3cnO1xuICAgKiAgICB0aGlzLmNvbnRleHQubGluZVdpZHRoID0gMjtcbiAgICogICAgdGhpcy5jb250ZXh0LnN0cm9rZVJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgKiAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogZ2FtZU9iamVjdC5yZW5kZXIoKTtcbiAgICogYGBgXG4gICAqIEBtZW1iZXJvZiBHYW1lT2JqZWN0XG4gICAqIEBmdW5jdGlvbiBkcmF3XG4gICAqL1xuICBkcmF3KCkge31cblxuICAvKipcbiAgICogU3luYyBwcm9wZXJ0eSBjaGFuZ2VzIGZyb20gdGhlIHBhcmVudCB0byB0aGUgY2hpbGRcbiAgICovXG4gIF9wYyhwcm9wLCB2YWx1ZSkge1xuICAgIHRoaXMuX3V3KCk7XG5cbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9HUk9VUFxuICAgIHRoaXMuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLl9wYygpKTtcbiAgICAvLyBAZW5kaWZcbiAgfVxuXG4gIC8qKlxuICAgKiBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvc2l0aW9uIHZlY3Rvci5cbiAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHhcbiAgICovXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XG4gIH1cblxuICAvKipcbiAgICogWSBjb29yZGluYXRlIG9mIHRoZSBwb3NpdGlvbiB2ZWN0b3IuXG4gICAqIEBtZW1iZXJvZiBHYW1lT2JqZWN0XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB5XG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xuICB9XG5cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLnBvc2l0aW9uLnggPSB2YWx1ZTtcblxuICAgIC8vIHBjID0gcHJvcGVydHkgY2hhbmdlZFxuICAgIHRoaXMuX3BjKCk7XG4gIH1cblxuICBzZXQgeSh2YWx1ZSkge1xuICAgIHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xuICAgIHRoaXMuX3BjKCk7XG4gIH1cblxuICBnZXQgd2lkdGgoKSB7XG4gICAgLy8gdyA9IHdpZHRoXG4gICAgcmV0dXJuIHRoaXMuX3c7XG4gIH1cblxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl93ID0gdmFsdWU7XG4gICAgdGhpcy5fcGMoKTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgLy8gaCA9IGhlaWdodFxuICAgIHJldHVybiB0aGlzLl9oO1xuICB9XG5cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2ggPSB2YWx1ZTtcbiAgICB0aGlzLl9wYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB3b3JsZCBwcm9wZXJ0aWVzXG4gICAqL1xuICBfdXcoKSB7XG4gICAgLy8gZG9uJ3QgdXBkYXRlIHdvcmxkIHByb3BlcnRpZXMgdW50aWwgYWZ0ZXIgdGhlIGluaXQgaGFzIGZpbmlzaGVkXG4gICAgaWYgKCF0aGlzLl9kaSkgcmV0dXJuO1xuXG4gICAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfR1JPVVB8fEdBTUVPQkpFQ1RfT1BBQ0lUWXx8R0FNRU9CSkVDVF9ST1RBVElPTnx8R0FNRU9CSkVDVF9TQ0FMRVxuICAgIGxldCB7XG4gICAgICBfd3ggPSAwLFxuICAgICAgX3d5ID0gMCxcblxuICAgICAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfT1BBQ0lUWVxuICAgICAgX3dvID0gMSxcbiAgICAgIC8vIEBlbmRpZlxuXG4gICAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9ST1RBVElPTlxuICAgICAgX3dyID0gMCxcbiAgICAgIC8vIEBlbmRpZlxuXG4gICAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9TQ0FMRVxuICAgICAgX3dzeCA9IDEsXG4gICAgICBfd3N5ID0gMVxuICAgICAgLy8gQGVuZGlmXG4gICAgfSA9ICh0aGlzLnBhcmVudCB8fCB7fSk7XG4gICAgLy8gQGVuZGlmXG5cbiAgICAvLyB3eCA9IHdvcmxkIHgsIHd5ID0gd29ybGQgeVxuICAgIHRoaXMuX3d4ID0gdGhpcy54O1xuICAgIHRoaXMuX3d5ID0gdGhpcy55O1xuXG4gICAgLy8gd3cgPSB3b3JsZCB3aWR0aCwgd2ggPSB3b3JsZCBoZWlnaHRcbiAgICB0aGlzLl93dyA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy5fd2ggPSB0aGlzLmhlaWdodDtcblxuICAgIC8vIEBpZmRlZiBHQU1FT0JKRUNUX09QQUNJVFlcbiAgICAvLyB3byA9IHdvcmxkIG9wYWNpdHlcbiAgICB0aGlzLl93byA9IF93byAqIHRoaXMub3BhY2l0eTtcbiAgICAvLyBAZW5kaWZcblxuICAgIC8vIEBpZmRlZiBHQU1FT0JKRUNUX1JPVEFUSU9OXG4gICAgLy8gd3IgPSB3b3JsZCByb3RhdGlvblxuICAgIHRoaXMuX3dyID0gX3dyICsgdGhpcy5yb3RhdGlvbjtcblxuICAgIGxldCB7eCwgeX0gPSByb3RhdGVQb2ludCh7eDogdGhpcy54LCB5OiB0aGlzLnl9LCBfd3IpO1xuICAgIHRoaXMuX3d4ID0geDtcbiAgICB0aGlzLl93eSA9IHk7XG4gICAgLy8gQGVuZGlmXG5cbiAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9TQ0FMRVxuICAgIC8vIHdzeCA9IHdvcmxkIHNjYWxlIHgsIHdzeSA9IHdvcmxkIHNjYWxlIHlcbiAgICB0aGlzLl93c3ggPSBfd3N4ICogdGhpcy5zY2FsZVg7XG4gICAgdGhpcy5fd3N5ID0gX3dzeSAqIHRoaXMuc2NhbGVZO1xuXG4gICAgdGhpcy5fd3ggPSB0aGlzLnggKiBfd3N4O1xuICAgIHRoaXMuX3d5ID0gdGhpcy55ICogX3dzeTtcbiAgICB0aGlzLl93dyA9IHRoaXMud2lkdGggKiB0aGlzLl93c3g7XG4gICAgdGhpcy5fd2ggPSB0aGlzLmhlaWdodCAqIHRoaXMuX3dzeTtcbiAgICAvLyBAZW5kaWZcblxuICAgIC8vIEBpZmRlZiBHQU1FT0JKRUNUX0dST1VQXG4gICAgdGhpcy5fd3ggKz0gX3d4O1xuICAgIHRoaXMuX3d5ICs9IF93eTtcbiAgICAvLyBAZW5kaWZcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgd29ybGQgcG9zaXRpb24sIHdpZHRoLCBoZWlnaHQsIG9wYWNpdHksIHJvdGF0aW9uLCBhbmQgc2NhbGUuIFRoZSB3b3JsZCBwcm9wZXJ0eSBpcyB0aGUgdHJ1ZSBwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCwgZXRjLiBvZiB0aGUgb2JqZWN0LCB0YWtpbmcgaW50byBhY2NvdW50IGFsbCBwYXJlbnRzLlxuICAgKlxuICAgKiBUaGUgd29ybGQgcHJvcGVydHkgZG9lcyBub3QgYWRqdXN0IGZvciBhbmNob3Igb3Igc2NhbGUsIHNvIGlmIHlvdSBzZXQgYSBuZWdhdGl2ZSBzY2FsZSB0aGUgd29ybGQgd2lkdGggb3IgaGVpZ2h0IGNvdWxkIGJlIG5lZ2F0aXZlLiBVc2UgW2dldFdvcmxkUmVjdF0oL2FwaS9oZWxwZXJzI2dldFdvcmxkUmVjdCkgdG8gZ2V0IHRoZSB3b3JsZCBwb3NpdGlvbiBhbmQgc2l6ZSBhZGp1c3RlZCBmb3IgYW5jaG9yIGFuZCBzY2FsZS5cbiAgICogQHByb3BlcnR5IHt7eDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBvcGFjaXR5OiBudW1iZXIsIHJvdGF0aW9uOiBudW1iZXIsIHNjYWxlWDogbnVtYmVyLCBzY2FsZVk6IG51bWJlcn19IHdvcmxkXG4gICAqIEBtZW1iZXJvZiBHYW1lT2JqZWN0XG4gICAqL1xuICBnZXQgd29ybGQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMuX3d4LFxuICAgICAgeTogdGhpcy5fd3ksXG4gICAgICB3aWR0aDogdGhpcy5fd3csXG4gICAgICBoZWlnaHQ6IHRoaXMuX3doLFxuXG4gICAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9PUEFDSVRZXG4gICAgICBvcGFjaXR5OiB0aGlzLl93byxcbiAgICAgIC8vIEBlbmRpZlxuXG4gICAgICAvLyBAaWZkZWYgR0FNRU9CSkVDVF9ST1RBVElPTlxuICAgICAgcm90YXRpb246IHRoaXMuX3dyLFxuICAgICAgLy8gQGVuZGlmXG5cbiAgICAgIC8vIEBpZmRlZiBHQU1FT0JKRUNUX1NDQUxFXG4gICAgICBzY2FsZVg6IHRoaXMuX3dzeCxcbiAgICAgIHNjYWxlWTogdGhpcy5fd3N5XG4gICAgICAvLyBAZW5kaWZcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBncm91cFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEBpZmRlZiBHQU1FT0JKRUNUX0dST1VQXG4gIC8qKlxuICAgKiBBZGQgYW4gb2JqZWN0IGFzIGEgY2hpbGQgdG8gdGhpcyBvYmplY3QuIFRoZSBjaGlsZHMgW3dvcmxkXShhcGkvZ2FtZU9iamVjdCN3b3JsZCkgcHJvcGVydHkgd2lsbCBiZSB1cGRhdGVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoaXMgb2JqZWN0IGFuZCBhbGwgb2YgaXRzIHBhcmVudHMuXG4gICAqIEBtZW1iZXJvZiBHYW1lT2JqZWN0XG4gICAqIEBmdW5jdGlvbiBhZGRDaGlsZFxuICAgKlxuICAgKiBAcGFyYW0ge0dhbWVPYmplY3R9IGNoaWxkIC0gT2JqZWN0IHRvIGFkZCBhcyBhIGNoaWxkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBleGNsdWRlLWNvZGU6c3RhcnRcbiAgICogbGV0IHsgR2FtZU9iamVjdCB9ID0ga29udHJhO1xuICAgKiAvLyBleGNsdWRlLWNvZGU6ZW5kXG4gICAqIC8vIGV4Y2x1ZGUtc2NyaXB0OnN0YXJ0XG4gICAqIGltcG9ydCB7IEdhbWVPYmplY3QgfSBmcm9tICdrb250cmEnO1xuICAgKiAvLyBleGNsdWRlLXNjcmlwdDplbmRcbiAgICpcbiAgICogZnVuY3Rpb24gY3JlYXRlT2JqZWN0KHgsIHksIGNvbG9yLCBzaXplID0gMSkge1xuICAgKiAgIHJldHVybiBHYW1lT2JqZWN0KHtcbiAgICogICAgIHgsXG4gICAqICAgICB5LFxuICAgKiAgICAgd2lkdGg6IDUwIC8gc2l6ZSxcbiAgICogICAgIGhlaWdodDogNTAgLyBzaXplLFxuICAgKiAgICAgYW5jaG9yOiB7eDogMC41LCB5OiAwLjV9LFxuICAgKiAgICAgY29sb3IsXG4gICAqICAgICAvLyBleGNsdWRlLWNvZGU6c3RhcnRcbiAgICogICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAqICAgICAvLyBleGNsdWRlLWNvZGU6ZW5kXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICogICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoKTtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogfVxuICAgKlxuICAgKiBsZXQgcGFyZW50ID0gY3JlYXRlT2JqZWN0KDMwMCwgMTAwLCAncmVkJyk7XG4gICAqIGxldCBjaGlsZCA9IGNyZWF0ZU9iamVjdCgyNSwgMjUsICd5ZWxsb3cnLCAyKTtcbiAgICpcbiAgICogcGFyZW50LmFkZENoaWxkKGNoaWxkKTtcbiAgICpcbiAgICogcGFyZW50LnJlbmRlcigpO1xuICAgKi9cbiAgYWRkQ2hpbGQoY2hpbGQsIHsgYWJzb2x1dGUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgY2hpbGQuX3BjID0gY2hpbGQuX3BjIHx8IG5vb3A7XG4gICAgY2hpbGQuX3BjKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIG9iamVjdCBhcyBhIGNoaWxkIG9mIHRoaXMgb2JqZWN0LiBUaGUgcmVtb3ZlZCBvYmplY3RzIFt3b3JsZF0oYXBpL2dhbWVPYmplY3Qjd29ybGQpIHByb3BlcnR5IHdpbGwgYmUgdXBkYXRlZCB0byBub3QgdGFrZSBpbnRvIGFjY291bnQgdGhpcyBvYmplY3QgYW5kIGFsbCBvZiBpdHMgcGFyZW50cy5cbiAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICogQGZ1bmN0aW9uIHJlbW92ZUNoaWxkXG4gICAqXG4gICAqIEBwYXJhbSB7R2FtZU9iamVjdH0gY2hpbGQgLSBPYmplY3QgdG8gcmVtb3ZlIGFzIGEgY2hpbGQuXG4gICAqL1xuICByZW1vdmVDaGlsZChjaGlsZCkge1xuICAgIGxldCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgIGNoaWxkLl9wYygpO1xuICAgIH1cbiAgfVxuICAvLyBAZW5kaWZcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBvcGFjaXR5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfT1BBQ0lUWVxuICBnZXQgb3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3BhO1xuICB9XG5cbiAgc2V0IG9wYWNpdHkodmFsdWUpIHtcbiAgICB0aGlzLl9vcGEgPSB2YWx1ZTtcbiAgICB0aGlzLl9wYygpO1xuICB9XG4gIC8vIEBlbmRpZlxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHJvdGF0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfUk9UQVRJT05cbiAgZ2V0IHJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3Q7XG4gIH1cblxuICBzZXQgcm90YXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9yb3QgPSB2YWx1ZTtcbiAgICB0aGlzLl9wYygpO1xuICB9XG4gIC8vIEBlbmRpZlxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHNjYWxlXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQGlmZGVmIEdBTUVPQkpFQ1RfU0NBTEVcbiAgLyoqXG4gICAqIFNldCB0aGUgeCBhbmQgeSBzY2FsZSBvZiB0aGUgb2JqZWN0LiBJZiBvbmx5IG9uZSB2YWx1ZSBpcyBwYXNzZWQsIGJvdGggYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZS5cbiAgICogQG1lbWJlcm9mIEdhbWVPYmplY3RcbiAgICogQGZ1bmN0aW9uIHNldFNjYWxlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gWCBzY2FsZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PXhdIC0gWSBzY2FsZSB2YWx1ZS5cbiAgICovXG4gIHNldFNjYWxlKHgsIHkgPSB4KSB7XG4gICAgdGhpcy5zY2FsZVggPSB4O1xuICAgIHRoaXMuc2NhbGVZID0geTtcbiAgfVxuXG4gIGdldCBzY2FsZVgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NjeDtcbiAgfVxuXG4gIHNldCBzY2FsZVgodmFsdWUpIHtcbiAgICB0aGlzLl9zY3ggPSB2YWx1ZTtcbiAgICB0aGlzLl9wYygpO1xuICB9XG5cbiAgZ2V0IHNjYWxlWSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2N5O1xuICB9XG5cbiAgc2V0IHNjYWxlWSh2YWx1ZSkge1xuICAgIHRoaXMuX3NjeSA9IHZhbHVlO1xuICAgIHRoaXMuX3BjKCk7XG4gIH1cbiAgLy8gQGVuZGlmXG59XG5cbmZ1bmN0aW9uIGZhY3RvcnkkMigpIHtcbiAgcmV0dXJuIG5ldyBHYW1lT2JqZWN0KC4uLmFyZ3VtZW50cyk7XG59XG5mYWN0b3J5JDIucHJvdG90eXBlID0gR2FtZU9iamVjdC5wcm90b3R5cGU7XG5mYWN0b3J5JDIuY2xhc3MgPSBHYW1lT2JqZWN0O1xuXG4vKipcbiAqIEEgdmVyc2F0aWxlIHdheSB0byB1cGRhdGUgYW5kIGRyYXcgeW91ciBzcHJpdGVzLiBJdCBjYW4gaGFuZGxlIHNpbXBsZSByZWN0YW5nbGVzLCBpbWFnZXMsIGFuZCBzcHJpdGUgc2hlZXQgYW5pbWF0aW9ucy4gSXQgY2FuIGJlIHVzZWQgZm9yIHlvdXIgbWFpbiBwbGF5ZXIgb2JqZWN0IGFzIHdlbGwgYXMgdGlueSBwYXJ0aWNsZXMgaW4gYSBwYXJ0aWNsZSBlbmdpbmUuXG4gKiBAY2xhc3MgU3ByaXRlXG4gKiBAZXh0ZW5kcyBHYW1lT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSAtIFByb3BlcnRpZXMgb2YgdGhlIHNwcml0ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydGllcy5jb2xvcl0gLSBGaWxsIGNvbG9yIGZvciB0aGUgZ2FtZSBvYmplY3QgaWYgbm8gaW1hZ2Ugb3IgYW5pbWF0aW9uIGlzIHByb3ZpZGVkLlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBbcHJvcGVydGllcy5pbWFnZV0gLSBVc2UgYW4gaW1hZ2UgdG8gZHJhdyB0aGUgc3ByaXRlLlxuICogQHBhcmFtIHt7W25hbWU6IHN0cmluZ10gOiBBbmltYXRpb259fSBbcHJvcGVydGllcy5hbmltYXRpb25zXSAtIEFuIG9iamVjdCBvZiBbQW5pbWF0aW9uc10oYXBpL2FuaW1hdGlvbikgZnJvbSBhIFtTcHJpdGVzaGVldF0oYXBpL3Nwcml0ZVNoZWV0KSB0byBhbmltYXRlIHRoZSBzcHJpdGUuXG4gKi9cbmNsYXNzIFNwcml0ZSBleHRlbmRzIGZhY3RvcnkkMi5jbGFzcyB7XG4gIC8qKlxuICAgKiBAZG9jcyBkb2NzL2FwaV9kb2NzL3Nwcml0ZS5qc1xuICAgKi9cblxuICBpbml0KHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29sb3Igb2YgdGhlIGdhbWUgb2JqZWN0IGlmIGl0IHdhcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQuXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZVxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjb2xvclxuICAgICAqL1xuXG4gICAgLy8gQGlmZGVmIFNQUklURV9JTUFHRVxuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgdXNlIHdoZW4gZHJhd24gaWYgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGVcbiAgICAgKiBAcHJvcGVydHkge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IGltYWdlXG4gICAgICovXG4gICAgaW1hZ2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZS4gSWYgdGhlIHNwcml0ZSBpcyBhIFtyZWN0YW5nbGUgc3ByaXRlXShhcGkvc3ByaXRlI3JlY3RhbmdsZS1zcHJpdGUpLCBpdCB1c2VzIHRoZSBwYXNzZWQgaW4gdmFsdWUuIEZvciBhbiBbaW1hZ2Ugc3ByaXRlXShhcGkvc3ByaXRlI2ltYWdlLXNwcml0ZSkgaXQgaXMgdGhlIHdpZHRoIG9mIHRoZSBpbWFnZS4gQW5kIGZvciBhbiBbYW5pbWF0aW9uIHNwcml0ZV0oYXBpL3Nwcml0ZSNhbmltYXRpb24tc3ByaXRlKSBpdCBpcyB0aGUgd2lkdGggb2YgYSBzaW5nbGUgZnJhbWUgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YgU3ByaXRlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHdpZHRoXG4gICAgICovXG4gICAgd2lkdGggPSBpbWFnZSA/IGltYWdlLndpZHRoIDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlLiBJZiB0aGUgc3ByaXRlIGlzIGEgW3JlY3RhbmdsZSBzcHJpdGVdKGFwaS9zcHJpdGUjcmVjdGFuZ2xlLXNwcml0ZSksIGl0IHVzZXMgdGhlIHBhc3NlZCBpbiB2YWx1ZS4gRm9yIGFuIFtpbWFnZSBzcHJpdGVdKGFwaS9zcHJpdGUjaW1hZ2Utc3ByaXRlKSBpdCBpcyB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZS4gQW5kIGZvciBhbiBbYW5pbWF0aW9uIHNwcml0ZV0oYXBpL3Nwcml0ZSNhbmltYXRpb24tc3ByaXRlKSBpdCBpcyB0aGUgaGVpZ2h0IG9mIGEgc2luZ2xlIGZyYW1lIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBoZWlnaHQgPSBpbWFnZSA/IGltYWdlLmhlaWdodCA6IHVuZGVmaW5lZCxcbiAgICAvLyBAZW5kaWZcblxuICAgIC4uLnByb3BzXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyLmluaXQoe1xuICAgICAgLy8gQGlmZGVmIFNQUklURV9JTUFHRVxuICAgICAgaW1hZ2UsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIC8vIEBlbmRpZlxuICAgICAgLi4ucHJvcHNcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEBpZmRlZiBTUFJJVEVfQU5JTUFUSU9OXG4gIC8qKlxuICAgKiBBbiBvYmplY3Qgb2YgW0FuaW1hdGlvbnNdKGFwaS9hbmltYXRpb24pIGZyb20gYSBbU3ByaXRlU2hlZXRdKGFwaS9zcHJpdGVTaGVldCkgdG8gYW5pbWF0ZSB0aGUgc3ByaXRlLiBFYWNoIGFuaW1hdGlvbiBpcyBuYW1lZCBzbyB0aGF0IGl0IGNhbiBjYW4gYmUgdXNlZCBieSBuYW1lIGZvciB0aGUgc3ByaXRlcyBbcGxheUFuaW1hdGlvbigpXShhcGkvc3ByaXRlI3BsYXlBbmltYXRpb24pIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyBTcHJpdGUsIFNwcml0ZVNoZWV0IH0gZnJvbSAna29udHJhJztcbiAgICpcbiAgICogbGV0IHNwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXQoe1xuICAgKiAgIC8vIC4uLlxuICAgKiAgIGFuaW1hdGlvbnM6IHtcbiAgICogICAgIGlkbGU6IHtcbiAgICogICAgICAgZnJhbWVzOiAxLFxuICAgKiAgICAgICBsb29wOiBmYWxzZSxcbiAgICogICAgIH0sXG4gICAqICAgICB3YWxrOiB7XG4gICAqICAgICAgIGZyYW1lczogWzEsMiwzXVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIGxldCBzcHJpdGUgPSBTcHJpdGUoe1xuICAgKiAgIHg6IDEwMCxcbiAgICogICB5OiAyMDAsXG4gICAqICAgYW5pbWF0aW9uczogc3ByaXRlU2hlZXQuYW5pbWF0aW9uc1xuICAgKiB9KTtcbiAgICpcbiAgICogc3ByaXRlLnBsYXlBbmltYXRpb24oJ2lkbGUnKTtcbiAgICogYGBgXG4gICAqIEBtZW1iZXJvZiBTcHJpdGVcbiAgICogQHByb3BlcnR5IHt7W25hbWU6IHN0cmluZ10gOiBBbmltYXRpb259fSBhbmltYXRpb25zXG4gICAqL1xuICBnZXQgYW5pbWF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fYTtcbiAgfVxuXG4gIHNldCBhbmltYXRpb25zKHZhbHVlKSB7XG4gICAgbGV0IHByb3AsIGZpcnN0QW5pbWF0aW9uO1xuICAgIC8vIGEgPSBhbmltYXRpb25zXG4gICAgdGhpcy5fYSA9IHt9O1xuXG4gICAgLy8gY2xvbmUgZWFjaCBhbmltYXRpb24gc28gbm8gc3ByaXRlIHNoYXJlcyBhbiBhbmltYXRpb25cbiAgICBmb3IgKHByb3AgaW4gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2FbcHJvcF0gPSB2YWx1ZVtwcm9wXS5jbG9uZSgpO1xuXG4gICAgICAvLyBkZWZhdWx0IHRoZSBjdXJyZW50IGFuaW1hdGlvbiB0byB0aGUgZmlyc3Qgb25lIGluIHRoZSBsaXN0XG4gICAgICBmaXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uIHx8IHRoaXMuX2FbcHJvcF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBwbGF5aW5nIEFuaW1hdGlvbiBvYmplY3QgaWYgYGFuaW1hdGlvbnNgIHdhcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQuXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZVxuICAgICAqIEBwcm9wZXJ0eSB7QW5pbWF0aW9ufSBjdXJyZW50QW5pbWF0aW9uXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XG4gICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgZmlyc3RBbmltYXRpb24ud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmhlaWdodCB8fCBmaXJzdEFuaW1hdGlvbi5oZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50bHkgcGxheWluZyBhbmltYXRpb24gb2YgYW4gYW5pbWF0aW9uIHNwcml0ZS5cbiAgICpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgU3ByaXRlLCBTcHJpdGVTaGVldCB9IGZyb20gJ2tvbnRyYSc7XG4gICAqXG4gICAqIGxldCBzcHJpdGVTaGVldCA9IFNwcml0ZVNoZWV0KHtcbiAgICogICAvLyAuLi5cbiAgICogICBhbmltYXRpb25zOiB7XG4gICAqICAgICBpZGxlOiB7XG4gICAqICAgICAgIGZyYW1lczogMVxuICAgKiAgICAgfSxcbiAgICogICAgIHdhbGs6IHtcbiAgICogICAgICAgZnJhbWVzOiBbMSwyLDNdXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogbGV0IHNwcml0ZSA9IFNwcml0ZSh7XG4gICAqICAgeDogMTAwLFxuICAgKiAgIHk6IDIwMCxcbiAgICogICBhbmltYXRpb25zOiBzcHJpdGVTaGVldC5hbmltYXRpb25zXG4gICAqIH0pO1xuICAgKlxuICAgKiBzcHJpdGUucGxheUFuaW1hdGlvbignaWRsZScpO1xuICAgKiBgYGBcbiAgICogQG1lbWJlcm9mIFNwcml0ZVxuICAgKiBAZnVuY3Rpb24gcGxheUFuaW1hdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBwbGF5LlxuICAgKi9cbiAgcGxheUFuaW1hdGlvbihuYW1lKSB7XG4gICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zW25hbWVdO1xuXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRBbmltYXRpb24ubG9vcCkge1xuICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLnJlc2V0KCk7XG4gICAgfVxuICB9XG5cbiAgYWR2YW5jZShkdCkge1xuICAgIHN1cGVyLmFkdmFuY2UoZHQpO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLnVwZGF0ZShkdCk7XG4gICAgfVxuICB9XG4gIC8vIEBlbmRpZlxuXG4gIGRyYXcoKSB7XG4gICAgLy8gQGlmZGVmIFNQUklURV9JTUFHRVxuICAgIGlmICh0aGlzLmltYWdlKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICB0aGlzLmltYWdlLFxuICAgICAgICAwLCAwLCB0aGlzLmltYWdlLndpZHRoLCB0aGlzLmltYWdlLmhlaWdodFxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gQGVuZGlmXG5cbiAgICAvLyBAaWZkZWYgU1BSSVRFX0FOSU1BVElPTlxuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbi5yZW5kZXIoe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gQGVuZGlmXG5cbiAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmYWN0b3J5JDMoKSB7XG4gIHJldHVybiBuZXcgU3ByaXRlKC4uLmFyZ3VtZW50cyk7XG59XG5mYWN0b3J5JDMucHJvdG90eXBlID0gU3ByaXRlLnByb3RvdHlwZTtcbmZhY3RvcnkkMy5jbGFzcyA9IFNwcml0ZTtcblxubGV0IGZvbnRTaXplUmVnZXggPSAvKFxcZCspKFxcdyspLztcblxuZnVuY3Rpb24gcGFyc2VGb250KGZvbnQpIHtcbiAgbGV0IG1hdGNoID0gZm9udC5tYXRjaChmb250U2l6ZVJlZ2V4KTtcblxuICAvLyBjb2VyY2Ugc3RyaW5nIHRvIG51bWJlclxuICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qZWQvMTQwYnl0ZXMvd2lraS9CeXRlLXNhdmluZy10ZWNobmlxdWVzI2NvZXJjaW9uLXRvLXRlc3QtZm9yLXR5cGVzXG4gIGxldCBzaXplID0gK21hdGNoWzFdO1xuICBsZXQgdW5pdCA9IG1hdGNoWzJdO1xuICBsZXQgY29tcHV0ZWQgPSBzaXplO1xuXG4gIC8vIGNvbXB1dGUgZm9udCBzaXplXG4gIC8vIHN3aXRjaCh1bml0KSB7XG4gIC8vICAgLy8gcHggZGVmYXVsdHMgdG8gdGhlIHNpemVcblxuICAvLyAgIC8vIGVtIHVzZXMgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyB3aGVuIGRlY2xhcmVkIChidXQgd29uJ3Qga2VlcCBpbiBzeW5jIHdpdGhcbiAgLy8gICAvLyBjaGFuZ2VzIHRvIHRoZSBjYW52YXMgZm9udC1zaXplKVxuICAvLyAgIGNhc2UgJ2VtJzoge1xuICAvLyAgICAgbGV0IGZvbnRTaXplID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZ2V0Q2FudmFzKCkpLmZvbnRTaXplO1xuICAvLyAgICAgbGV0IHBhcnNlZFNpemUgPSBwYXJzZUZvbnQoZm9udFNpemUpLnNpemU7XG4gIC8vICAgICBjb21wdXRlZCA9IHNpemUgKiBwYXJzZWRTaXplO1xuICAvLyAgIH1cblxuICAvLyAgIC8vIHJlbSB1c2VzIHRoZSBzaXplIG9mIHRoZSBIVE1MIGVsZW1lbnQgd2hlbiBkZWNsYXJlZCAoYnV0IHdvbid0IGtlZXAgaW5cbiAgLy8gICAvLyBzeW5jIHdpdGggY2hhbmdlcyB0byB0aGUgSFRNTCBlbGVtZW50IGZvbnQtc2l6ZSlcbiAgLy8gICBjYXNlICdyZW0nOiB7XG4gIC8vICAgICBsZXQgZm9udFNpemUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmZvbnRTaXplO1xuICAvLyAgICAgbGV0IHBhcnNlZFNpemUgPSBwYXJzZUZvbnQoZm9udFNpemUpLnNpemU7XG4gIC8vICAgICBjb21wdXRlZCA9IHNpemUgKiBwYXJzZWRTaXplO1xuICAvLyAgIH1cbiAgLy8gfVxuXG4gIHJldHVybiB7XG4gICAgc2l6ZSxcbiAgICB1bml0LFxuICAgIGNvbXB1dGVkXG4gIH07XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IGZvciBkcmF3aW5nIHRleHQgdG8gdGhlIHNjcmVlbi4gU3VwcG9ydHMgbmV3bGluZSBjaGFyYWN0ZXJzIGFzIHdlbGwgYXMgYXV0b21hdGljIG5ldyBsaW5lcyB3aGVuIHNldHRpbmcgdGhlIGB3aWR0aGAgcHJvcGVydHkuXG4gKlxuICogWW91IGNhbiBhbHNvIGRpc3BsYXkgUlRMIGxhbmd1YWdlcyBieSBzZXR0aW5nIHRoZSBhdHRyaWJ1dGUgYGRpcj1cInJ0bFwiYCBvbiB0aGUgbWFpbiBjYW52YXMgZWxlbWVudC4gRHVlIHRvIHRoZSBsaW1pdGVkIGJyb3dzZXIgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbCB0ZXh0IHRvIGhhdmUgUlRMIHNldHRpbmdzLCBpdCBtdXN0IGJlIHNldCBnbG9iYWxseSBmb3IgdGhlIGVudGlyZSBnYW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBleGNsdWRlLWNvZGU6c3RhcnRcbiAqIGxldCB7IFRleHQgfSA9IGtvbnRyYTtcbiAqIC8vIGV4Y2x1ZGUtY29kZTplbmRcbiAqIC8vIGV4Y2x1ZGUtc2NyaXB0OnN0YXJ0XG4gKiBpbXBvcnQgeyBUZXh0IH0gZnJvbSAna29udHJhJztcbiAqIC8vIGV4Y2x1ZGUtc2NyaXB0OmVuZFxuICpcbiAqIGxldCB0ZXh0ID0gVGV4dCh7XG4gKiAgIHRleHQ6ICdIZWxsbyBXb3JsZCFcXG5JIGNhbiBldmVuIGJlIG11bHRpbGluZSEnLFxuICogICBmb250OiAnMzJweCBBcmlhbCcsXG4gKiAgIGNvbG9yOiAnd2hpdGUnLFxuICogICB4OiAzMDAsXG4gKiAgIHk6IDEwMCxcbiAqICAgYW5jaG9yOiB7eDogMC41LCB5OiAwLjV9LFxuICogICB0ZXh0QWxpZ246ICdjZW50ZXInXG4gKiB9KTtcbiAqIC8vIGV4Y2x1ZGUtY29kZTpzdGFydFxuICogdGV4dC5jb250ZXh0ID0gY29udGV4dDtcbiAqIC8vIGV4Y2x1ZGUtY29kZTplbmRcbiAqXG4gKiB0ZXh0LnJlbmRlcigpO1xuICogQGNsYXNzIFRleHRcbiAqIEBleHRlbmRzIEdhbWVPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIFByb3BlcnRpZXMgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy50ZXh0IC0gVGhlIHRleHQgdG8gZGlzcGxheS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydGllcy5mb250XSAtIFRoZSBbZm9udF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9mb250KSBzdHlsZS4gRGVmYXVsdHMgdG8gdGhlIG1haW4gY29udGV4dCBmb250LlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0aWVzLmNvbG9yXSAtIEZpbGwgY29sb3IgZm9yIHRoZSB0ZXh0LiBEZWZhdWx0cyB0byB0aGUgbWFpbiBjb250ZXh0IGZpbGxTdHlsZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvcGVydGllcy53aWR0aF0gLSBTZXQgYSBmaXhlZCB3aWR0aCBmb3IgdGhlIHRleHQuIElmIHNldCwgdGhlIHRleHQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHNwbGl0IGludG8gbmV3IGxpbmVzIHRoYXQgd2lsbCBmaXQgdGhlIHNpemUgd2hlbiBwb3NzaWJsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydGllcy50ZXh0QWxpZ249J2xlZnQnXSAtIFRoZSBbdGV4dEFsaWduXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3RleHRBbGlnbikgZm9yIHRoZSBjb250ZXh0LiBJZiB0aGUgYGRpcmAgYXR0cmlidXRlIGlzIHNldCB0byBgcnRsYCBvbiB0aGUgbWFpbiBjYW52YXMsIHRoZSB0ZXh0IHdpbGwgYXV0b21hdGljYWxseSBiZSBhbGlnbmVkIHRvIHRoZSByaWdodCwgYnV0IHlvdSBjYW4gb3ZlcnJpZGUgdGhhdCBieSBzZXR0aW5nIHRoaXMgcHJvcGVydHkuXG4gKiBAcGFyYW0ge051bWJlcn0gW3Byb3BlcnRpZXMubGluZUhlaWdodD0xXSAtIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiB0ZXh0LlxuICovXG5jbGFzcyBUZXh0IGV4dGVuZHMgZmFjdG9yeSQyLmNsYXNzIHtcblxuICBpbml0KHtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZGVmYXVsdHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyBvZiB0ZXh0LiBVc2UgbmV3bGluZSBjaGFyYWN0ZXJzIHRvIGNyZWF0ZSBtdWx0aS1saW5lIHN0cmluZ3MuXG4gICAgICogQG1lbWJlcm9mIFRleHRcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gdGV4dFxuICAgICAqL1xuICAgIHRleHQgPSAnJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGFsaWdubWVudC5cbiAgICAgKiBAbWVtYmVyb2YgVGV4dFxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0ZXh0QWxpZ25cbiAgICAgKi9cbiAgICB0ZXh0QWxpZ24gPSAnJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiB0ZXh0LiBUaGUgdmFsdWUgaXMgbXVsdGlwbGllZCBieSB0aGUgdGV4dHMgZm9udCBzaXplLlxuICAgICAqIEBtZW1iZXJvZiBUZXh0XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxpbmVIZWlnaHRcbiAgICAgKi9cbiAgICBsaW5lSGVpZ2h0ID0gMSxcblxuICAgLyoqXG4gICAgKiBUaGUgZm9udCBzdHlsZS5cbiAgICAqIEBtZW1iZXJvZiBUZXh0XG4gICAgKiBAcHJvcGVydHkge1N0cmluZ30gZm9udFxuICAgICovXG4gICAgZm9udCA9IGdldENvbnRleHQoKS5mb250LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbG9yIG9mIHRoZSB0ZXh0LlxuICAgICAqIEBtZW1iZXJvZiBUZXh0XG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGNvbG9yXG4gICAgICovXG5cbiAgICAgLi4ucHJvcHNcbiAgfSA9IHt9KSB7XG4gICAgLy8gY2FzdCB0byBzdHJpbmdcbiAgICB0ZXh0ID0gJycgKyB0ZXh0O1xuXG4gICAgc3VwZXIuaW5pdCh7XG4gICAgICB0ZXh0LFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgbGluZUhlaWdodCxcbiAgICAgIGZvbnQsXG4gICAgICAuLi5wcm9wc1xuICAgIH0pO1xuXG4gICAgLy8gcCA9IHByZXJlbmRlclxuICAgIHRoaXMuX3AoKTtcbiAgfVxuXG4gIC8vIGtlZXAgd2lkdGggYW5kIGhlaWdodCBnZXR0ZXJzL3NldHRpbmdzIHNvIHdlIGNhbiBzZXQgX3cgYW5kIF9oIGFuZCBub3RcbiAgLy8gdHJpZ2dlciBpbmZpbml0ZSBjYWxsIGxvb3BzXG4gIGdldCB3aWR0aCgpIHtcbiAgICAvLyB3ID0gd2lkdGhcbiAgICByZXR1cm4gdGhpcy5fdztcbiAgfVxuXG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIC8vIGQgPSBkaXJ0eVxuICAgIHRoaXMuX2QgPSB0cnVlO1xuICAgIHRoaXMuX3cgPSB2YWx1ZTtcblxuICAgIC8vIGZ3ID0gZml4ZWQgd2lkdGhcbiAgICB0aGlzLl9mdyA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Q7XG4gIH1cblxuICBzZXQgdGV4dCh2YWx1ZSkge1xuICAgIHRoaXMuX2QgPSB0cnVlO1xuICAgIHRoaXMuX3QgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBmb250KCkge1xuICAgIHJldHVybiB0aGlzLl9mO1xuICB9XG5cbiAgc2V0IGZvbnQodmFsdWUpIHtcbiAgICB0aGlzLl9kID0gdHJ1ZTtcbiAgICB0aGlzLl9mID0gdmFsdWU7XG4gICAgdGhpcy5fZnMgPSBwYXJzZUZvbnQodmFsdWUpLmNvbXB1dGVkO1xuICB9XG5cbiAgZ2V0IGxpbmVIZWlnaHQoKSB7XG4gICAgLy8gbGggPSBsaW5lIGhlaWdodFxuICAgIHJldHVybiB0aGlzLl9saDtcbiAgfVxuXG4gIHNldCBsaW5lSGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5fZCA9IHRydWU7XG4gICAgdGhpcy5fbGggPSB2YWx1ZTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5fZCkge1xuICAgICAgdGhpcy5fcCgpO1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGZvbnQgd2lkdGgsIGhlaWdodCwgYW5kIHRleHQgc3RyaW5ncyBiZWZvcmUgcmVuZGVyaW5nLlxuICAgKi9cbiAgX3AoKSB7XG4gICAgLy8gcyA9IHN0cmluZ3NcbiAgICB0aGlzLl9zID0gW107XG4gICAgdGhpcy5fZCA9IGZhbHNlO1xuICAgIGxldCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgY29udGV4dC5mb250ID0gdGhpcy5mb250O1xuXG4gICAgLy8gQGlmZGVmIFRFWFRfQVVUT05FV0xJTkVcbiAgICBpZiAoIXRoaXMuX3MubGVuZ3RoICYmIHRoaXMuX2Z3KSB7XG4gICAgICBsZXQgcGFydHMgPSB0aGlzLnRleHQuc3BsaXQoJyAnKTtcbiAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICBsZXQgaSA9IDI7XG5cbiAgICAgIC8vIHNwbGl0IHRoZSBzdHJpbmcgaW50byBsaW5lcyB0aGF0IGFsbCBmaXQgd2l0aGluIHRoZSBmaXhlZCB3aWR0aFxuICAgICAgZm9yICg7IGkgPD0gcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHN0ciA9IHBhcnRzLnNsaWNlKHN0YXJ0LCBpKS5qb2luKCcgJyk7XG4gICAgICAgIGxldCB3aWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQoc3RyKS53aWR0aDtcblxuICAgICAgICBpZiAod2lkdGggPiB0aGlzLl9mdykge1xuICAgICAgICAgIHRoaXMuX3MucHVzaChwYXJ0cy5zbGljZShzdGFydCwgaSAtIDEpLmpvaW4oJyAnKSk7XG4gICAgICAgICAgc3RhcnQgPSBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zLnB1c2gocGFydHMuc2xpY2Uoc3RhcnQsIGkpLmpvaW4oJyAnKSk7XG4gICAgfVxuICAgIC8vIEBlbmRpZlxuXG4gICAgLy8gQGlmZGVmIFRFWFRfTkVXTElORVxuICAgIGlmICghdGhpcy5fcy5sZW5ndGggJiYgdGhpcy50ZXh0LmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgIHRoaXMudGV4dC5zcGxpdCgnXFxuJykubWFwKHN0ciA9PiB7XG4gICAgICAgIHRoaXMuX3MucHVzaChzdHIpO1xuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjb250ZXh0Lm1lYXN1cmVUZXh0KHN0cikud2lkdGgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3cgPSB0aGlzLl9mdyB8fCB3aWR0aDtcbiAgICB9XG4gICAgLy8gQGVuZGlmXG5cbiAgICBpZiAoIXRoaXMuX3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zLnB1c2godGhpcy50ZXh0KTtcbiAgICAgIHRoaXMuX3cgPSB0aGlzLl9mdyB8fCBjb250ZXh0Lm1lYXN1cmVUZXh0KHRoaXMudGV4dCkud2lkdGg7XG4gICAgfVxuXG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9mcyArICgodGhpcy5fcy5sZW5ndGggLSAxKSAqIHRoaXMuX2ZzICogdGhpcy5saW5lSGVpZ2h0KTtcbiAgICB0aGlzLl91dygpO1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBsZXQgYWxpZ25YID0gMDtcbiAgICBsZXQgdGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XG4gICAgbGV0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAvLyBAaWZkZWYgVEVYVF9SVExcbiAgICB0ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbiB8fCAoY29udGV4dC5jYW52YXMuZGlyID09PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgIC8vIEBlbmRpZlxuXG4gICAgLy8gQGlmZGVmIFRFWFRfQUxJR058fFRFWFRfUlRMXG4gICAgYWxpZ25YID0gdGV4dEFsaWduID09PSAncmlnaHQnXG4gICAgICA/IHRoaXMud2lkdGhcbiAgICAgIDogdGV4dEFsaWduID09PSAnY2VudGVyJ1xuICAgICAgICA/IHRoaXMud2lkdGggLyAyIHwgMFxuICAgICAgICA6IDA7XG4gICAgLy8gQGVuZGlmXG5cbiAgICB0aGlzLl9zLm1hcCgoc3RyLCBpbmRleCkgPT4ge1xuICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIGNvbnRleHQudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgY29udGV4dC5mb250ID0gdGhpcy5mb250O1xuICAgICAgY29udGV4dC5maWxsVGV4dChzdHIsIGFsaWduWCwgdGhpcy5fZnMgKiB0aGlzLmxpbmVIZWlnaHQgKiBpbmRleCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmFjdG9yeSQ0KCkge1xuICByZXR1cm4gbmV3IFRleHQoLi4uYXJndW1lbnRzKTtcbn1cbmZhY3RvcnkkNC5wcm90b3R5cGUgPSBUZXh0LnByb3RvdHlwZTtcbmZhY3RvcnkkNC5jbGFzcyA9IFRleHQ7XG5cbi8qKlxuICogQSBzaW1wbGUgcG9pbnRlciBBUEkuIFlvdSBjYW4gdXNlIGl0IG1vdmUgdGhlIG1haW4gc3ByaXRlIG9yIHJlc3BvbmQgdG8gYSBwb2ludGVyIGV2ZW50LiBXb3JrcyB3aXRoIGJvdGggbW91c2UgYW5kIHRvdWNoIGV2ZW50cy5cbiAqXG4gKiBQb2ludGVyIGV2ZW50cyBjYW4gYmUgYWRkZWQgb24gYSBnbG9iYWwgbGV2ZWwgb3Igb24gaW5kaXZpZHVhbCBzcHJpdGVzIG9yIG9iamVjdHMuIEJlZm9yZSBhbiBvYmplY3QgY2FuIHJlY2VpdmUgcG9pbnRlciBldmVudHMsIHlvdSBtdXN0IHRlbGwgdGhlIHBvaW50ZXIgd2hpY2ggb2JqZWN0cyB0byB0cmFjayBhbmQgdGhlIG9iamVjdCBtdXN0IGhhdmVuIGJlZW4gcmVuZGVyZWQgdG8gdGhlIGNhbnZhcyB1c2luZyBgb2JqZWN0LnJlbmRlcigpYC5cbiAqXG4gKiBBZnRlciBhbiBvYmplY3QgaXMgdHJhY2tlZCBhbmQgcmVuZGVyZWQsIHlvdSBjYW4gYXNzaWduIGl0IGFuIGBvbkRvd24oKWAsIGBvblVwKClgLCBgb25PdmVyKClgLCBvciBgb25PdXQoKWAgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgcG9pbnRlciBkb3duLCB1cCwgb3Zlciwgb3Igb3V0IGV2ZW50IGhhcHBlbnMgb24gdGhlIG9iamVjdC5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgaW5pdFBvaW50ZXIsIHRyYWNrLCBTcHJpdGUgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIC8vIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgZmlyc3QgYmVmb3JlIHBvaW50ZXJcbiAqIC8vIGZ1bmN0aW9ucyB3aWxsIHdvcmtcbiAqIGluaXRQb2ludGVyKCk7XG4gKlxuICogbGV0IHNwcml0ZSA9IFNwcml0ZSh7XG4gKiAgIG9uRG93bjogZnVuY3Rpb24oKSB7XG4gKiAgICAgLy8gaGFuZGxlIG9uIGRvd24gZXZlbnRzIG9uIHRoZSBzcHJpdGVcbiAqICAgfSxcbiAqICAgb25VcDogZnVuY3Rpb24oKSB7XG4gKiAgICAgLy8gaGFuZGxlIG9uIHVwIGV2ZW50cyBvbiB0aGUgc3ByaXRlXG4gKiAgIH0sXG4gKiAgIG9uT3ZlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgLy8gaGFuZGxlIG9uIG92ZXIgZXZlbnRzIG9uIHRoZSBzcHJpdGVcbiAqICAgfSxcbiAqICAgb25PdXQ6IGZ1bmN0aW9uKCkge1xuICogICAgIC8vIGhhbmRsZSBvbiBvdXQgZXZlbnRzIG9uIHRoZSBzcHJpdGVcbiAqICAgfVxuICogfSk7XG4gKlxuICogdHJhY2soc3ByaXRlKTtcbiAqIHNwcml0ZS5yZW5kZXIoKTtcbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBwb2ludGVyIGlzIHRyZWF0ZWQgYXMgYSBjaXJjbGUgYW5kIHdpbGwgY2hlY2sgZm9yIGNvbGxpc2lvbnMgYWdhaW5zdCBvYmplY3RzIGFzc3VtaW5nIHRoZXkgYXJlIHJlY3Rhbmd1bGFyIChoYXZlIGEgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0eSkuXG4gKlxuICogSWYgeW91IG5lZWQgdG8gcGVyZm9ybSBhIGRpZmZlcmVudCB0eXBlIG9mIGNvbGxpc2lvbiBkZXRlY3Rpb24sIGFzc2lnbiB0aGUgb2JqZWN0IGEgYGNvbGxpZGVzV2l0aFBvaW50ZXIoKWAgZnVuY3Rpb24gYW5kIGl0IHdpbGwgYmUgY2FsbGVkIGluc3RlYWQuIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHBvaW50ZXIgb2JqZWN0LiBVc2UgdGhpcyBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaG93IHRoZSBwb2ludGVyIGNpcmNsZSBzaG91bGQgY29sbGlkZSB3aXRoIHRoZSBvYmplY3QuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IFNwcml0ZSB9IGZyb20gJ2tvbnRyYSc7XG5cbiAqIGxldCBzcHJpdGUgPSBTcml0ZSh7XG4gKiAgIHg6IDEwLFxuICogICB5OiAxMCxcbiAqICAgcmFkaXVzOiAxMFxuICogICBjb2xsaWRlc1dpdGhQb2ludGVyOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gKiAgICAgLy8gcGVyZm9ybSBhIGNpcmNsZSB2IGNpcmNsZSBjb2xsaXNpb24gdGVzdFxuICogICAgIGxldCBkeCA9IHBvaW50ZXIueCAtIHRoaXMueDtcbiAqICAgICBsZXQgZHkgPSBwb2ludGVyLnkgLSB0aGlzLnk7XG4gKiAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgPCB0aGlzLnJhZGl1cztcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqIEBzZWN0aW9uTmFtZSBQb2ludGVyXG4gKi9cblxuLy8gc2F2ZSBlYWNoIG9iamVjdCBhcyB0aGV5IGFyZSByZW5kZXJlZCB0byBkZXRlcm1pbmUgd2hpY2ggb2JqZWN0XG4vLyBpcyBvbiB0b3Agd2hlbiBtdWx0aXBsZSBvYmplY3RzIGFyZSB0aGUgdGFyZ2V0IG9mIGFuIGV2ZW50LlxuLy8gd2UnbGwgYWx3YXlzIHVzZSB0aGUgbGFzdCBmcmFtZSdzIG9iamVjdCBvcmRlciBzbyB3ZSBrbm93XG4vLyB0aGUgZmluYWxpemVkIG9yZGVyIG9mIGFsbCBvYmplY3RzLCBvdGhlcndpc2UgYW4gb2JqZWN0IGNvdWxkIGFza1xuLy8gaWYgaXQncyBiZWluZyBob3ZlcmVkIHdoZW4gaXQncyByZW5kZXJlZCBmaXJzdCBldmVuIGlmIG90aGVyIG9iamVjdHNcbi8vIHdvdWxkIGJsb2NrIGl0IGxhdGVyIGluIHRoZSByZW5kZXIgb3JkZXJcbmxldCBwb2ludGVycyA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgY2FsbGJhY2tzJDEgPSB7fTtcbmxldCBwcmVzc2VkQnV0dG9ucyA9IHt9O1xuXG4vKipcbiAqIEJlbG93IGlzIGEgbGlzdCBvZiBidXR0b25zIHRoYXQgeW91IGNhbiB1c2UuXG4gKlxuICogLSBsZWZ0LCBtaWRkbGUsIHJpZ2h0XG4gKiBAc2VjdGlvbk5hbWUgQXZhaWxhYmxlIEJ1dHRvbnNcbiAqL1xubGV0IGJ1dHRvbk1hcCA9IHtcbiAgMDogJ2xlZnQnLFxuICAxOiAnbWlkZGxlJyxcbiAgMjogJ3JpZ2h0J1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHBvaW50ZXIgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBgcmFkaXVzYCwgY3VycmVudCBgeGAgYW5kIGB5YCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciByZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXMsIGFuZCB3aGljaCBgY2FudmFzYCB0aGUgcG9pbnRlciBhcHBsaWVzIHRvLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBpbml0UG9pbnRlciwgZ2V0UG9pbnRlciB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogaW5pdFBvaW50ZXIoKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhnZXRQb2ludGVyKCkpOyAgLy89PiB7IHg6IDEwMCwgeTogMjAwLCByYWRpdXM6IDUsIGNhbnZhczogPGNhbnZhcz4gfTtcbiAqIGBgYFxuICpcbiAqIEBmdW5jdGlvbiBnZXRQb2ludGVyXG4gKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW2NhbnZhc10gLSBUaGUgY2FudmFzIHdoaWNoIG1haW50YWlucyB0aGUgcG9pbnRlci4gRGVmYXVsdHMgdG8gW2NvcmUuZ2V0Q2FudmFzKCldKGFwaS9jb3JlI2dldENhbnZhcykuXG4gKlxuICogQHJldHVybnMge3t4OiBOdW1iZXIsIHk6IE51bWJlciwgcmFkaXVzOiBOdW1iZXIsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHRvdWNoZXM6IE9iamVjdH19IHBvaW50ZXIgd2l0aCBwcm9wZXJ0aWVzIGB4YCwgYHlgLCBhbmQgYHJhZGl1c2AuIElmIHVzaW5nIHRvdWNoIGV2ZW50cywgYWxzbyBoYXMgYSBgdG91Y2hlc2Agb2JqZWN0IHdpdGgga2V5cyBvZiB0aGUgdG91Y2ggaWRlbnRpZmllciBhbmQgdGhlIHgveSBwb3NpdGlvbiBvZiB0aGUgdG91Y2ggYXMgdGhlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRQb2ludGVyKGNhbnZhcyA9IGdldENhbnZhcygpKSB7XG4gIHJldHVybiBwb2ludGVycy5nZXQoY2FudmFzKTtcbn1cblxuLyoqXG4gKiBEZXRlY3Rpb24gY29sbGlzaW9uIGJldHdlZW4gYSByZWN0YW5nbGUgYW5kIGEgY2lyY2xlLlxuICogQHNlZSBodHRwczovL3lhbC5jYy9yZWN0YW5nbGUtY2lyY2xlLWludGVyc2VjdGlvbi10ZXN0L1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBPYmplY3QgdG8gY2hlY2sgY29sbGlzaW9uIGFnYWluc3QuXG4gKi9cbmZ1bmN0aW9uIGNpcmNsZVJlY3RDb2xsaXNpb24ob2JqZWN0LCBwb2ludGVyKSB7XG4gIGxldCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGdldFdvcmxkUmVjdChvYmplY3QpO1xuXG4gIC8vIGFjY291bnQgZm9yIGNhbWVyYVxuICBkbyB7XG4gICAgeCAtPSBvYmplY3Quc3ggfHwgMDtcbiAgICB5IC09IG9iamVjdC5zeSB8fCAwO1xuICB9IHdoaWxlICgob2JqZWN0ID0gb2JqZWN0LnBhcmVudCkpO1xuXG4gIGxldCBkeCA9IHBvaW50ZXIueCAtIE1hdGgubWF4KHgsIE1hdGgubWluKHBvaW50ZXIueCwgeCArIHdpZHRoKSk7XG4gIGxldCBkeSA9IHBvaW50ZXIueSAtIE1hdGgubWF4KHksIE1hdGgubWluKHBvaW50ZXIueSwgeSArIGhlaWdodCkpO1xuICByZXR1cm4gKGR4ICogZHggKyBkeSAqIGR5KSA8IChwb2ludGVyLnJhZGl1cyAqIHBvaW50ZXIucmFkaXVzKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IG9uIHRvcCBvYmplY3QgdGhhdCB0aGUgcG9pbnRlciBjb2xsaWRlcyB3aXRoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyIC0gVGhlIHBvaW50ZXIgb2JqZWN0XG4gKlxuICogQHJldHVybnMge09iamVjdH0gRmlyc3Qgb2JqZWN0IHRvIGNvbGxpZGUgd2l0aCB0aGUgcG9pbnRlci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudE9iamVjdChwb2ludGVyKSB7XG5cbiAgLy8gaWYgcG9pbnRlciBldmVudHMgYXJlIHJlcXVpcmVkIG9uIHRoZSB2ZXJ5IGZpcnN0IGZyYW1lIG9yXG4gIC8vIHdpdGhvdXQgYSBnYW1lIGxvb3AsIHVzZSB0aGUgY3VycmVudCBmcmFtZVxuICBsZXQgcmVuZGVyZWRPYmplY3RzID0gcG9pbnRlci5fbGYubGVuZ3RoID9cbiAgICBwb2ludGVyLl9sZiA6XG4gICAgcG9pbnRlci5fY2Y7XG5cbiAgZm9yIChsZXQgaSA9IHJlbmRlcmVkT2JqZWN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCBvYmplY3QgPSByZW5kZXJlZE9iamVjdHNbaV07XG4gICAgbGV0IGNvbGxpZGVzID0gb2JqZWN0LmNvbGxpZGVzV2l0aFBvaW50ZXIgP1xuICAgICAgb2JqZWN0LmNvbGxpZGVzV2l0aFBvaW50ZXIocG9pbnRlcikgOlxuICAgICAgY2lyY2xlUmVjdENvbGxpc2lvbihvYmplY3QsIHBvaW50ZXIpO1xuXG4gICAgaWYgKGNvbGxpZGVzKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgc3R5bGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BWYWx1ZShzdHlsZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSh2YWx1ZSkpIHx8IDA7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBjYW52YXMgc2l6ZSwgc2NhbGUsIGFuZCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFRoZSBwb2ludGVyIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzY2FsZSBhbmQgb2Zmc2V0IG9mIHRoZSBjYW52YXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzT2Zmc2V0KHBvaW50ZXIpIHtcbiAgLy8gd2UgbmVlZCB0byBhY2NvdW50IGZvciBDU1Mgc2NhbGUsIHRyYW5zZm9ybSwgYm9yZGVyLCBwYWRkaW5nLFxuICAvLyBhbmQgbWFyZ2luIGluIG9yZGVyIHRvIGdldCB0aGUgY29ycmVjdCBzY2FsZSBhbmQgb2Zmc2V0IG9mIHRoZVxuICAvLyBjYW52YXNcbiAgbGV0IHsgY2FudmFzLCBfcyB9ID0gcG9pbnRlcjtcbiAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgLy8gQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTM0MDUzOTAvMjEyNDI1NFxuICBsZXQgdHJhbnNmb3JtID0gX3MudHJhbnNmb3JtICE9PSAnbm9uZSdcbiAgICA/IF9zLnRyYW5zZm9ybS5yZXBsYWNlKCdtYXRyaXgoJywgJycpLnNwbGl0KCcsJylcbiAgICA6IFsxLDEsMSwxXTtcbiAgbGV0IHRyYW5zZm9ybVNjYWxlWCA9IHBhcnNlRmxvYXQodHJhbnNmb3JtWzBdKTtcbiAgbGV0IHRyYW5zZm9ybVNjYWxlWSA9IHBhcnNlRmxvYXQodHJhbnNmb3JtWzNdKTtcblxuICAvLyBzY2FsZSB0cmFuc2Zvcm0gYXBwbGllcyB0byB0aGUgYm9yZGVyIGFuZCBwYWRkaW5nIG9mIHRoZSBlbGVtZW50XG4gIGxldCBib3JkZXJXaWR0aCA9IChnZXRQcm9wVmFsdWUoX3MsICdib3JkZXItbGVmdC13aWR0aCcpICsgZ2V0UHJvcFZhbHVlKF9zLCAnYm9yZGVyLXJpZ2h0LXdpZHRoJykpICogdHJhbnNmb3JtU2NhbGVYO1xuICBsZXQgYm9yZGVySGVpZ2h0ID0gKGdldFByb3BWYWx1ZShfcywgJ2JvcmRlci10b3Atd2lkdGgnKSArIGdldFByb3BWYWx1ZShfcywgJ2JvcmRlci1ib3R0b20td2lkdGgnKSkgKiB0cmFuc2Zvcm1TY2FsZVk7XG5cbiAgbGV0IHBhZGRpbmdXaWR0aCA9IChnZXRQcm9wVmFsdWUoX3MsICdwYWRkaW5nLWxlZnQnKSArIGdldFByb3BWYWx1ZShfcywgJ3BhZGRpbmctcmlnaHQnKSkgKiB0cmFuc2Zvcm1TY2FsZVg7XG4gIGxldCBwYWRkaW5nSGVpZ2h0ID0gKGdldFByb3BWYWx1ZShfcywgJ3BhZGRpbmctdG9wJykgKyBnZXRQcm9wVmFsdWUoX3MsICdwYWRkaW5nLWJvdHRvbScpKSAqIHRyYW5zZm9ybVNjYWxlWTtcblxuICByZXR1cm4ge1xuICAgIHNjYWxlWDogKHJlY3Qud2lkdGggLSBib3JkZXJXaWR0aCAtIHBhZGRpbmdXaWR0aCkgLyBjYW52YXMud2lkdGgsXG4gICAgc2NhbGVZOiAocmVjdC5oZWlnaHQgLSBib3JkZXJIZWlnaHQgLSBwYWRkaW5nSGVpZ2h0KSAvIGNhbnZhcy5oZWlnaHQsXG4gICAgb2Zmc2V0WDogcmVjdC5sZWZ0ICsgKGdldFByb3BWYWx1ZShfcywgJ2JvcmRlci1sZWZ0LXdpZHRoJykgKyBnZXRQcm9wVmFsdWUoX3MsICdwYWRkaW5nLWxlZnQnKSkgKiB0cmFuc2Zvcm1TY2FsZVgsXG4gICAgb2Zmc2V0WTogcmVjdC50b3AgKyAoZ2V0UHJvcFZhbHVlKF9zLCAnYm9yZGVyLXRvcC13aWR0aCcpICsgZ2V0UHJvcFZhbHVlKF9zLCAncGFkZGluZy10b3AnKSkgKiB0cmFuc2Zvcm1TY2FsZVlcbiAgfTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBvbkRvd24gY2FsbGJhY2sgZm9yIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR8VG91Y2hFdmVudH0gZXZ0XG4gKi9cbmZ1bmN0aW9uIHBvaW50ZXJEb3duSGFuZGxlcihldnQpIHtcblxuICAvLyB0b3VjaHN0YXJ0IHNob3VsZCBiZSB0cmVhdGVkIGxpa2UgYSBsZWZ0IG1vdXNlIGJ1dHRvblxuICBsZXQgYnV0dG9uID0gZXZ0LmJ1dHRvbiAhPT0gdW5kZWZpbmVkID8gYnV0dG9uTWFwW2V2dC5idXR0b25dIDogJ2xlZnQnO1xuICBwcmVzc2VkQnV0dG9uc1tidXR0b25dID0gdHJ1ZTtcbiAgcG9pbnRlckhhbmRsZXIoZXZ0LCAnb25Eb3duJyk7XG59XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgb25VcCBjYWxsYmFjayBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7TW91c2VFdmVudHxUb3VjaEV2ZW50fSBldnRcbiAqL1xuZnVuY3Rpb24gcG9pbnRlclVwSGFuZGxlcihldnQpIHtcbiAgbGV0IGJ1dHRvbiA9IGV2dC5idXR0b24gIT09IHVuZGVmaW5lZCA/IGJ1dHRvbk1hcFtldnQuYnV0dG9uXSA6ICdsZWZ0JztcbiAgcHJlc3NlZEJ1dHRvbnNbYnV0dG9uXSA9IGZhbHNlO1xuICBwb2ludGVySGFuZGxlcihldnQsICdvblVwJyk7XG59XG5cbi8qKlxuICogVHJhY2sgdGhlIHBvc2l0aW9uIG9mIHRoZSBtb3VzZXZ0LlxuICpcbiAqIEBwYXJhbSB7TW91c2VFdmVudHxUb3VjaEV2ZW50fSBldnRcbiAqL1xuZnVuY3Rpb24gbW91c2VNb3ZlSGFuZGxlcihldnQpIHtcbiAgcG9pbnRlckhhbmRsZXIoZXZ0LCAnb25PdmVyJyk7XG59XG5cbi8qKlxuICogUmVzZXQgcHJlc3NlZCBidXR0b25zLlxuICpcbiAqIEBwYXJhbSB7TW91c2VFdmVudHxUb3VjaEV2ZW50fSBldnRcbiAqL1xuZnVuY3Rpb24gYmx1ckV2ZW50SGFuZGxlcihldnQpIHtcbiAgbGV0IHBvaW50ZXIgPSBwb2ludGVycy5nZXQoZXZ0LnRhcmdldCk7XG4gIHBvaW50ZXIuX29vID0gbnVsbDtcbiAgcHJlc3NlZEJ1dHRvbnMgPSB7fTtcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBmaXJzdCBvYmplY3QgZm9yIHRoZSBldmVudCBhbmQgZXhlY3V0ZSBpdCdzIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fFRvdWNoRXZlbnR9IGV2dFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFdoaWNoIGV2ZW50IHdhcyBjYWxsZWQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50ZXJIYW5kbGVyKGV2dCwgZXZlbnROYW1lKSB7XG4gIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIGxldCBjYW52YXMgPSBldnQudGFyZ2V0O1xuICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzLmdldChjYW52YXMpO1xuICBsZXQge1xuICAgIHNjYWxlWCxcbiAgICBzY2FsZVksXG4gICAgb2Zmc2V0WCxcbiAgICBvZmZzZXRZXG4gIH0gPSBnZXRDYW52YXNPZmZzZXQocG9pbnRlcik7XG5cbiAgbGV0IGlzVG91Y2hFdmVudCA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnXS5pbmRleE9mKGV2dC50eXBlKSAhPT0gLTE7XG5cbiAgaWYgKGlzVG91Y2hFdmVudCkge1xuXG4gICAgLy8gdXBkYXRlIHBvaW50ZXIudG91Y2hlc1xuICAgIHBvaW50ZXIudG91Y2hlcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZ0LnRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvaW50ZXIudG91Y2hlc1tldnQudG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHtcbiAgICAgICAgaWQ6IGV2dC50b3VjaGVzW2ldLmlkZW50aWZpZXIsXG4gICAgICAgIHg6IChldnQudG91Y2hlc1tpXS5jbGllbnRYIC0gb2Zmc2V0WCkgLyBzY2FsZVgsXG4gICAgICAgIHk6IChldnQudG91Y2hlc1tpXS5jbGllbnRZIC0gb2Zmc2V0WSkgLyBzY2FsZVksXG4gICAgICAgIGNoYW5nZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBhbGwgdG91Y2hlc1xuICAgIGZvciAodmFyIGkgPSBldnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBpZCA9IGV2dC5jaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyO1xuICAgICAgaWYgKHR5cGVvZiBwb2ludGVyLnRvdWNoZXNbaWRdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHBvaW50ZXIudG91Y2hlc1tpZF0uY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBjbGllbnRYID0gZXZ0LmNoYW5nZWRUb3VjaGVzW2ldLmNsaWVudFg7XG4gICAgICBsZXQgY2xpZW50WSA9IGV2dC5jaGFuZ2VkVG91Y2hlc1tpXS5jbGllbnRZO1xuICAgICAgcG9pbnRlci54ID0gKGNsaWVudFggLSBvZmZzZXRYKSAvIHNjYWxlWDtcbiAgICAgIHBvaW50ZXIueSA9IChjbGllbnRZIC0gb2Zmc2V0WSkgLyBzY2FsZVk7XG5cbiAgICAgIC8vIFRyaWdnZXIgZXZlbnRzXG4gICAgICBsZXQgb2JqZWN0ID0gZ2V0Q3VycmVudE9iamVjdChwb2ludGVyKTtcbiAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0W2V2ZW50TmFtZV0pIHtcbiAgICAgICAgb2JqZWN0W2V2ZW50TmFtZV0oZXZ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrcyQxW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgY2FsbGJhY2tzJDFbZXZlbnROYW1lXShldnQsIG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuXG4gICAgLy8gdHJhbnNsYXRlIHRoZSBzY2FsZWQgc2l6ZSBiYWNrIGFzIGlmIHRoZSBjYW52YXMgd2FzIGF0IGFcbiAgICAvLyAxOjEgc2NhbGVcbiAgICBwb2ludGVyLnggPSAoZXZ0LmNsaWVudFggLSBvZmZzZXRYKSAvIHNjYWxlWDtcbiAgICBwb2ludGVyLnkgPSAoZXZ0LmNsaWVudFkgLSBvZmZzZXRZKSAvIHNjYWxlWTtcblxuICAgIGxldCBvYmplY3QgPSBnZXRDdXJyZW50T2JqZWN0KHBvaW50ZXIpO1xuICAgIGlmIChvYmplY3QgJiYgb2JqZWN0W2V2ZW50TmFtZV0pIHtcbiAgICAgIG9iamVjdFtldmVudE5hbWVdKGV2dCk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrcyQxW2V2ZW50TmFtZV0pIHtcbiAgICAgIGNhbGxiYWNrcyQxW2V2ZW50TmFtZV0oZXZ0LCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBvbk91dCBldmVudHNcbiAgICBpZiAoZXZlbnROYW1lID09ICdvbk92ZXInKSB7XG4gICAgICBpZiAob2JqZWN0ICE9IHBvaW50ZXIuX29vICYmIHBvaW50ZXIuX29vICYmIHBvaW50ZXIuX29vLm9uT3V0KSB7XG4gICAgICAgIHBvaW50ZXIuX29vLm9uT3V0KGV2dCk7XG4gICAgICB9XG5cbiAgICAgIHBvaW50ZXIuX29vID0gb2JqZWN0O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgcG9pbnRlciBldmVudCBsaXN0ZW5lcnMuIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHVzaW5nIG90aGVyIHBvaW50ZXIgZnVuY3Rpb25zLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIHVzZSBtdWx0aXBsZSBjYW52YXMsIHlvdSdsbCBoYXZlIHRvIGluaXRpYWxpemUgdGhlIHBvaW50ZXIgZm9yIGVhY2ggb25lIGluZGl2aWR1YWxseSBhcyBlYWNoIGNhbnZhcyBtYWludGFpbnMgaXRzIG93biBwb2ludGVyIG9iamVjdC5cbiAqIEBmdW5jdGlvbiBpbml0UG9pbnRlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBQb2ludGVyIG9wdGlvbnMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmFkaXVzPTVdIC0gUmFkaXVzIG9mIHRoZSBwb2ludGVyLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW29wdGlvbnMuY2FudmFzXSAtIFRoZSBjYW52YXMgdGhhdCBldmVudCBsaXN0ZW5lcnMgd2lsbCBiZSBhdHRhY2hlZCB0by4gRGVmYXVsdHMgdG8gW2NvcmUuZ2V0Q2FudmFzKCldKGFwaS9jb3JlI2dldENhbnZhcykuXG4gKlxuICogQHJldHVybnMge3t4OiBOdW1iZXIsIHk6IE51bWJlciwgcmFkaXVzOiBOdW1iZXIsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHRvdWNoZXM6IE9iamVjdH19IFRoZSBwb2ludGVyIG9iamVjdCBmb3IgdGhlIGNhbnZhcy5cbiAqL1xuZnVuY3Rpb24gaW5pdFBvaW50ZXIoe3JhZGl1cyA9IDUsIGNhbnZhcyA9IGdldENhbnZhcygpfSA9IHt9KSB7XG4gIGxldCBwb2ludGVyID0gcG9pbnRlcnMuZ2V0KGNhbnZhcyk7XG4gIGlmICghcG9pbnRlcikge1xuICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG5cbiAgICBwb2ludGVyID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICByYWRpdXMsXG4gICAgICB0b3VjaGVzOiB7fSxcbiAgICAgIGNhbnZhcyxcblxuICAgICAgLy8gY2YgPSBjdXJyZW50IGZyYW1lLCBsZiA9IGxhc3QgZnJhbWUsIG8gPSBvYmplY3RzLFxuICAgICAgLy8gb28gPSBvdmVyIG9iamVjdCwgX3MgPSBzdHlsZVxuICAgICAgX2NmOiBbXSxcbiAgICAgIF9sZjogW10sXG4gICAgICBfbzogW10sXG4gICAgICBfb286IG51bGwsXG4gICAgICBfczogc3R5bGVcbiAgICB9O1xuICAgIHBvaW50ZXJzLnNldChjYW52YXMsIHBvaW50ZXIpO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIHRoZSBzYW1lIGV2ZW50XG4gIC8vIHdvbid0IGJlIGFkZGVkIG11bHRpcGxlIHRpbWVzXG4gIC8vIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjgwNTY3MTYvY2hlY2staWYtYW4tZWxlbWVudC1oYXMtZXZlbnQtbGlzdGVuZXItb24taXQtbm8tanF1ZXJ5LzQxMTM3NTg1IzQxMTM3NTg1XG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBwb2ludGVyRG93bkhhbmRsZXIpO1xuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHBvaW50ZXJEb3duSGFuZGxlcik7XG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgcG9pbnRlclVwSGFuZGxlcik7XG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHBvaW50ZXJVcEhhbmRsZXIpO1xuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBwb2ludGVyVXBIYW5kbGVyKTtcbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBibHVyRXZlbnRIYW5kbGVyKTtcbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlTW92ZUhhbmRsZXIpO1xuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XG5cbiAgLy8gaG93ZXZlciwgdGhlIHRpY2sgZXZlbnQgc2hvdWxkIG9ubHkgYmUgcmVnaXN0ZXJlZCBvbmNlXG4gIC8vIG90aGVyd2lzZSBpdCBjb21wbGV0ZWx5IGRlc3Ryb3lzIHBvaW50ZXIgZXZlbnRzXG4gIGlmICghcG9pbnRlci5fdCkge1xuICAgIHBvaW50ZXIuX3QgPSB0cnVlO1xuXG4gICAgLy8gcmVzZXQgb2JqZWN0IHJlbmRlciBvcmRlciBvbiBldmVyeSBuZXcgZnJhbWVcbiAgICBvbigndGljaycsICgpID0+IHtcbiAgICAgIHBvaW50ZXIuX2xmLmxlbmd0aCA9IDA7XG5cbiAgICAgIHBvaW50ZXIuX2NmLm1hcChvYmplY3QgPT4ge1xuICAgICAgICBwb2ludGVyLl9sZi5wdXNoKG9iamVjdCk7XG4gICAgICB9KTtcblxuICAgICAgcG9pbnRlci5fY2YubGVuZ3RoID0gMDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwb2ludGVyO1xufVxuXG4vKipcbiAqIEJlZ2luIHRyYWNraW5nIHBvaW50ZXIgZXZlbnRzIGZvciBhIHNldCBvZiBvYmplY3RzLiBUYWtlcyBhIHNpbmdsZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgaW5pdFBvaW50ZXIsIHRyYWNrIH0gZnJvbSAna29udHJhJztcbiAqXG4gKiBpbml0UG9pbnRlcigpO1xuICpcbiAqIHRyYWNrKG9iaik7XG4gKiB0cmFjayhvYmoxLCBvYmoyKTtcbiAqIGBgYFxuICogQGZ1bmN0aW9uIHRyYWNrXG4gKlxuICogQHBhcmFtIHsuLi5PYmplY3RbXX0gb2JqZWN0cyAtIE9iamVjdHMgdG8gdHJhY2suXG4gKi9cbmZ1bmN0aW9uIHRyYWNrKC4uLm9iamVjdHMpIHtcbiAgb2JqZWN0cy5tYXAob2JqZWN0ID0+IHtcbiAgICBsZXQgY2FudmFzID0gb2JqZWN0LmNvbnRleHQgPyBvYmplY3QuY29udGV4dC5jYW52YXMgOiBnZXRDYW52YXMoKTtcbiAgICBsZXQgcG9pbnRlciA9IHBvaW50ZXJzLmdldChjYW52YXMpO1xuXG4gICAgLy8gQGlmZGVmIERFQlVHXG4gICAgaWYgKCFwb2ludGVyKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1BvaW50ZXIgZXZlbnRzIG5vdCBpbml0aWFsaXplZCBmb3IgdGhlIG9iamVjdHMgY2FudmFzJyk7XG4gICAgfSAgICAvLyBAZW5kaWZcblxuICAgIC8vIG92ZXJyaWRlIHRoZSBvYmplY3RzIHJlbmRlciBmdW5jdGlvbiB0byBrZWVwIHRyYWNrIG9mIHJlbmRlclxuICAgIC8vIG9yZGVyXG4gICAgaWYgKCFvYmplY3QuX3IpIHtcbiAgICAgIG9iamVjdC5fciA9IG9iamVjdC5yZW5kZXI7XG5cbiAgICAgIG9iamVjdC5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcG9pbnRlci5fY2YucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcigpO1xuICAgICAgfTtcblxuICAgICAgcG9pbnRlci5fby5wdXNoKG9iamVjdCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4qIFJlbW92ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGEgYm91bmQgc2V0IG9mIG9iamVjdHMuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IHVudHJhY2sgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIHVudHJhY2sob2JqKTtcbiAqIHVudHJhY2sob2JqMSwgb2JqMik7XG4gKiBgYGBcbiAqIEBmdW5jdGlvbiB1bnRyYWNrXG4gKlxuICogQHBhcmFtIHsuLi5PYmplY3RbXX0gb2JqZWN0cyAtIE9iamVjdCBvciBvYmplY3RzIHRvIHN0b3AgdHJhY2tpbmcuXG4gKi9cbmZ1bmN0aW9uIHVudHJhY2soLi4ub2JqZWN0cykge1xuICBvYmplY3RzLm1hcChvYmplY3QgPT4ge1xuICAgIGxldCBjYW52YXMgPSBvYmplY3QuY29udGV4dCA/IG9iamVjdC5jb250ZXh0LmNhbnZhcyA6IGdldENhbnZhcygpO1xuICAgIGxldCBwb2ludGVyID0gcG9pbnRlcnMuZ2V0KGNhbnZhcyk7XG5cbiAgICAvLyBAaWZkZWYgREVCVUdcbiAgICBpZiAoIXBvaW50ZXIpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignUG9pbnRlciBldmVudHMgbm90IGluaXRpYWxpemVkIGZvciB0aGUgb2JqZWN0cyBjYW52YXMnKTtcbiAgICB9ICAgIC8vIEBlbmRpZlxuXG4gICAgLy8gcmVzdG9yZSBvcmlnaW5hbCByZW5kZXIgZnVuY3Rpb24gdG8gbm8gbG9uZ2VyIHRyYWNrIHJlbmRlciBvcmRlclxuICAgIG9iamVjdC5yZW5kZXIgPSBvYmplY3QuX3I7XG4gICAgb2JqZWN0Ll9yID0gMDsgIC8vIDAgaXMgdGhlIHNob3J0ZXN0IGZhbHN5IHZhbHVlXG5cbiAgICBsZXQgaW5kZXggPSBwb2ludGVyLl9vLmluZGV4T2Yob2JqZWN0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBwb2ludGVyLl9vLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgdGhlIHBvaW50ZXIgaXMgY3VycmVudGx5IG92ZXIgdGhlIG9iamVjdC4gU2luY2UgbXVsdGlwbGUgb2JqZWN0cyBtYXkgYmUgcmVuZGVyZWQgb24gdG9wIG9mIG9uZSBhbm90aGVyLCBvbmx5IHRoZSB0b3AgbW9zdCBvYmplY3QgdW5kZXIgdGhlIHBvaW50ZXIgd2lsbCByZXR1cm4gdHJ1ZS5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgaW5pdFBvaW50ZXIsIHRyYWNrLCBwb2ludGVyLCBwb2ludGVyT3ZlciwgU3ByaXRlIH0gZnJvbSAna29udHJhJztcbiAqXG4gKiBpbml0UG9pbnRlcigpO1xuICpcbiAqIGxldCBzcHJpdGUxID0gU3ByaXRlKHtcbiAqICAgeDogMTAsXG4gKiAgIHk6IDEwLFxuICogICB3aWR0aDogMTAsXG4gKiAgIGhlaWdodDogMTBcbiAqIH0pO1xuICogbGV0IHNwcml0ZTIgPSBTcHJpdGUoe1xuICogICB4OiAxNSxcbiAqICAgeTogMTAsXG4gKiAgIHdpZHRoOiAxMCxcbiAqICAgaGVpZ2h0OiAxMFxuICogfSk7XG4gKlxuICogdHJhY2soc3ByaXRlMSwgc3ByaXRlMik7XG4gKlxuICogc3ByaXRlMS5yZW5kZXIoKTtcbiAqIHNwcml0ZTIucmVuZGVyKCk7XG4gKlxuICogcG9pbnRlci54ID0gMTQ7XG4gKiBwb2ludGVyLnkgPSAxNTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwb2ludGVyT3ZlcihzcHJpdGUxKSk7ICAvLz0+IGZhbHNlXG4gKiBjb25zb2xlLmxvZyhwb2ludGVyT3ZlcihzcHJpdGUyKSk7ICAvLz0+IHRydWVcbiAqIGBgYFxuICogQGZ1bmN0aW9uIHBvaW50ZXJPdmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gY2hlY2sgaWYgdGhlIHBvaW50ZXIgaXMgb3Zlci5cbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwb2ludGVyIGlzIGN1cnJlbnRseSBvdmVyIHRoZSBvYmplY3QsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBwb2ludGVyT3ZlcihvYmplY3QpIHtcbiAgbGV0IGNhbnZhcyA9IG9iamVjdC5jb250ZXh0ID8gb2JqZWN0LmNvbnRleHQuY2FudmFzIDogZ2V0Q2FudmFzKCk7XG4gIGxldCBwb2ludGVyID0gcG9pbnRlcnMuZ2V0KGNhbnZhcyk7XG5cbiAgLy8gQGlmZGVmIERFQlVHXG4gIGlmICghcG9pbnRlcikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignUG9pbnRlciBldmVudHMgbm90IGluaXRpYWxpemVkIGZvciB0aGUgb2JqZWN0cyBjYW52YXMnKTtcbiAgfSAgLy8gQGVuZGlmXG5cbiAgcmV0dXJuIHBvaW50ZXIuX28uaW5jbHVkZXMob2JqZWN0KSAmJiBnZXRDdXJyZW50T2JqZWN0KHBvaW50ZXIpID09PSBvYmplY3Q7XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYWxsIHBvaW50ZXIgZG93biBldmVudHMuIElzIHBhc3NlZCB0aGUgb3JpZ2luYWwgRXZlbnQgYW5kIHRoZSB0YXJnZXQgb2JqZWN0IChpZiB0aGVyZSBpcyBvbmUpLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBpbml0UG9pbnRlciwgb25Qb2ludGVyRG93biB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogaW5pdFBvaW50ZXIoKTtcbiAqXG4gKiBvblBvaW50ZXJEb3duKGZ1bmN0aW9uKGUsIG9iamVjdCkge1xuICogICAvLyBoYW5kbGUgcG9pbnRlciBkb3duXG4gKiB9KVxuICogYGBgXG4gKiBAZnVuY3Rpb24gb25Qb2ludGVyRG93blxuICpcbiAqIEBwYXJhbSB7KGV2dDogTW91c2VFdmVudHxUb3VjaEV2ZW50LCBvYmplY3Q/OiBPYmplY3QpID0+IHZvaWR9IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCBvbiBwb2ludGVyIGRvd24uXG4gKi9cbmZ1bmN0aW9uIG9uUG9pbnRlckRvd24oY2FsbGJhY2spIHtcbiAgY2FsbGJhY2tzJDEub25Eb3duID0gY2FsbGJhY2s7XG59XG5cbi8qKlxuKiBSZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbGwgcG9pbnRlciB1cCBldmVudHMuIElzIHBhc3NlZCB0aGUgb3JpZ2luYWwgRXZlbnQgYW5kIHRoZSB0YXJnZXQgb2JqZWN0IChpZiB0aGVyZSBpcyBvbmUpLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBpbml0UG9pbnRlciwgb25Qb2ludGVyVXAgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIGluaXRQb2ludGVyKCk7XG4gKlxuICogb25Qb2ludGVyVXAoZnVuY3Rpb24oZSwgb2JqZWN0KSB7XG4gKiAgIC8vIGhhbmRsZSBwb2ludGVyIHVwXG4gKiB9KVxuICogYGBgXG4gKiBAZnVuY3Rpb24gb25Qb2ludGVyVXBcbiAqXG4gKiBAcGFyYW0geyhldnQ6IE1vdXNlRXZlbnR8VG91Y2hFdmVudCwgb2JqZWN0PzogT2JqZWN0KSA9PiB2b2lkfSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgb24gcG9pbnRlciB1cC5cbiAqL1xuZnVuY3Rpb24gb25Qb2ludGVyVXAoY2FsbGJhY2spIHtcbiAgY2FsbGJhY2tzJDEub25VcCA9IGNhbGxiYWNrO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgYnV0dG9uIGlzIGN1cnJlbnRseSBwcmVzc2VkLiBVc2UgZHVyaW5nIGFuIGB1cGRhdGUoKWAgZnVuY3Rpb24gdG8gcGVyZm9ybSBhY3Rpb25zIGVhY2ggZnJhbWUuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IGluaXRQb2ludGVyLCBwb2ludGVyUHJlc3NlZCB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogaW5pdFBvaW50ZXIoKTtcbiAqXG4gKiBTcHJpdGUoe1xuICogICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICogICAgIGlmIChwb2ludGVyUHJlc3NlZCgnbGVmdCcpKXtcbiAqICAgICAgIC8vIGxlZnQgbW91c2UgYnV0dG9uIHByZXNzZWRcbiAqICAgICB9XG4gKiAgICAgZWxzZSBpZiAocG9pbnRlclByZXNzZWQoJ3JpZ2h0JykpIHtcbiAqICAgICAgIC8vIHJpZ2h0IG1vdXNlIGJ1dHRvbiBwcmVzc2VkXG4gKiAgICAgfVxuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICogQGZ1bmN0aW9uIHBvaW50ZXJQcmVzc2VkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJ1dHRvbiAtIEJ1dHRvbiB0byBjaGVjayBmb3IgcHJlc3NlZCBzdGF0ZS5cbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBidXR0b24gaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIHBvaW50ZXJQcmVzc2VkKGJ1dHRvbikge1xuICByZXR1cm4gISFwcmVzc2VkQnV0dG9uc1tidXR0b25dXG59XG5cbi8qKlxuICogQW4gYWNjZXNzaWJsZSBidXR0b24uIFN1cHBvcnRzIHNjcmVlbiByZWFkZXJzIGFuZCBrZXlib2FyZCBuYXZpZ2F0aW9uIHVzaW5nIHRoZSA8a2JkPlRhYjwva2JkPiBrZXkuIFRoZSBidXR0b24gaXMgYXV0b21hdGljYWxseSBbdHJhY2tlZF0oYXBpL3BvaW50ZXIjdHJhY2spIGJ5IHRoZSBwb2ludGVyIGFuZCBhY2NlcHRzIGFsbCBwb2ludGVyIGZ1bmN0aW9ucywgYnV0IHlvdSB3aWxsIHN0aWxsIG5lZWQgdG8gY2FsbCBbaW5pdFBvaW50ZXJdKGFwaS9wb2ludGVyI2luaXRQb2ludGVyKSB0byBoYXZlIHBvaW50ZXIgZXZlbnRzIGVuYWJsZWQuXG4gKiBAY2xhc3MgQnV0dG9uXG4gKiBAZXh0ZW5kcyBTcHJpdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIC0gUHJvcGVydGllcyBvZiB0aGUgYnV0dG9uIChpbiBhZGRpdGlvbiB0byBhbGwgU3ByaXRlIHByb3BlcnRpZXMpLlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzLnRleHRdIC0gUHJvcGVydGllcyBvZiBbVGV4dF0oYXBpL3RleHQpIHdoaWNoIGFyZSB1c2VkIHRvIGNyZWF0ZSB0aGUgW3RleHROb2RlXShhcGkvYnV0dG9uI3RleHROb2RlKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvcGVydGllcy5wYWRYPTBdIC0gVGhlIGhvcml6b250YWwgcGFkZGluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvcGVydGllcy5wYWRZPTBdIC0gVGhlIHZlcnRpY2FsIHBhZGRpbmcuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcGVydGllcy5vbkVuYWJsZV0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYnV0dG9uIGlzIGVuYWJsZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcGVydGllcy5vbkRpc2FibGVdIC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wZXJ0aWVzLm9uRm9jdXNdIC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGJ1dHRvbiBpcyBmb2N1c2VkIGJ5IHRoZSBrZXlib2FyZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wZXJ0aWVzLm9uQmx1cl0gLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYnV0dG9uIGxvc3NlcyBmb2N1cyBlaXRoZXIgYnkgdGhlIHBvaW50ZXIgb3Iga2V5Ym9hcmQuXG4gKi9cbmNsYXNzIEJ1dHRvbiBleHRlbmRzIGZhY3RvcnkkMy5jbGFzcyB7XG4gIC8qKlxuICAgKiBAZG9jcyBkb2NzL2FwaV9kb2NzL2J1dHRvbi5qc1xuICAgKi9cblxuICBpbml0KHtcbiAgICAvKipcbiAgICAgKiBUaGUgaG9yaXpvbnRhbCBwYWRkaW5nLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHdpZHRoIHRvIGdpdmUgdGhlIGZpbmFsIHdpZHRoIG9mIHRoZSBidXR0b24uXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwYWRYXG4gICAgICovXG4gICAgcGFkWCA9IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVydGljYWwgcGFkZGluZy4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBoZWlnaHQgdG8gZ2l2ZSB0aGUgZmluYWwgaGVpZ2h0IG9mIHRoZSBidXR0b24uXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwYWRZXG4gICAgICovXG4gICAgcGFkWSA9IDAsXG5cbiAgICB0ZXh0LFxuICAgIG9uRG93bixcbiAgICBvblVwLFxuICAgIC4uLnByb3BzXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyLmluaXQoe1xuICAgICAgcGFkWCxcbiAgICAgIHBhZFksXG4gICAgICAuLi5wcm9wc1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRWFjaCBCdXR0b24gY3JlYXRlcyBhIFRleHQgb2JqZWN0IGFuZCBhZGRzIGl0IGFzIGEgY2hpbGQuIFRoZSBgdGV4dGAgb2YgdGhlIFRleHQgb2JqZWN0IGlzIHVzZWQgYXMgdGhlIGFjY2Vzc2libGUgbmFtZSBvZiB0aGUgSFRNTEJ1dHRvbkVsZW1lbnQuXG4gICAgICogQG1lbWJlcm9mIEJ1dHRvblxuICAgICAqIEBwcm9wZXJ0eSB7VGV4dH0gdGV4dE5vZGVcbiAgICAgKi9cbiAgICB0aGlzLnRleHROb2RlID0gZmFjdG9yeSQ0KHtcbiAgICAgIC4uLnRleHQsXG5cbiAgICAgIC8vIGVuc3VyZSB0aGUgdGV4dCB1c2VzIHRoZSBzYW1lIGNvbnRleHQgYXMgdGhlIGJ1dHRvblxuICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0XG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGUgdXNlciBkaWRuJ3Qgc2V0IGEgd2lkdGgvaGVpZ2h0IG9yIHVzZSBhbiBpbWFnZVxuICAgIC8vIGRlZmF1bHQgdG8gdGhlIHRleHROb2RlIGRpbWVuc2lvbnNcbiAgICBpZiAoIXRoaXMud2lkdGgpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLnRleHROb2RlLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnRleHROb2RlLmhlaWdodDtcbiAgICB9XG5cbiAgICB0cmFjayh0aGlzKTtcbiAgICB0aGlzLmFkZENoaWxkKHRoaXMudGV4dE5vZGUpO1xuXG4gICAgLy8gb2QgPSBvbiBkb3duXG4gICAgdGhpcy5fb2QgPSBvbkRvd24gfHwgbm9vcDtcblxuICAgIC8vIG91ID0gb24gdXBcbiAgICB0aGlzLl9vdSA9IG9uVXAgfHwgbm9vcDtcblxuICAgIC8vIGNyZWF0ZSBhbiBhY2Nlc3NpYmxlIERPTSBub2RlIGZvciBzY3JlZW4gcmVhZGVyc1xuICAgIC8vIGRuID0gZG9tIG5vZGVcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLl9kbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi5zdHlsZSA9IHNyT25seVN0eWxlO1xuICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IHRoaXMudGV4dDtcblxuICAgIC8vIHN5bmMgZXZlbnRzIGJldHdlZW4gdGhlIGJ1dHRvbiBlbGVtZW50IGFuZCB0aGUgY2xhc3NcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoKSA9PiB0aGlzLmZvY3VzKCkpO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKCkgPT4gdGhpcy5ibHVyKCkpO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2dCkgPT4gdGhpcy5fa2QoZXZ0KSk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2dCkgPT4gdGhpcy5fa3UoZXZ0KSk7XG5cbiAgICBhZGRUb0RvbShidXR0b24sIHRoaXMuY29udGV4dC5jYW52YXMpO1xuXG4gICAgdGhpcy5fdXcoKTtcbiAgICB0aGlzLl9wKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRleHQgcHJvcGVydHkgb2YgdGhlIFRleHQgb2JqZWN0LlxuICAgKiBAbWVtYmVyb2YgQnV0dG9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0ZXh0XG4gICAqL1xuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0Tm9kZS50ZXh0O1xuICB9XG5cbiAgc2V0IHRleHQodmFsdWUpIHtcbiAgICAvLyBkID0gZGlydHlcbiAgICB0aGlzLl9kID0gdHJ1ZTtcbiAgICB0aGlzLnRleHROb2RlLnRleHQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCB0aGUgYnV0dG9uIGJ5IHJlbW92aW5nIHRoZSBIVE1MQnV0dG9uRWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAqIEBtZW1iZXJvZiBCdXR0b25cbiAgICogQGZ1bmN0aW9uIGRlc3Ryb3lcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZG4ucmVtb3ZlKCk7XG4gIH1cblxuICBfcCgpIHtcbiAgICAvLyB1cGRhdGUgRE9NIG5vZGUgdGV4dCBpZiBpdCBoYXMgY2hhbmdlZFxuICAgIGlmICh0aGlzLnRleHQgIT09IHRoaXMuX2RuLnRleHRDb250ZW50KSB7XG4gICAgICB0aGlzLl9kbi50ZXh0Q29udGVudCA9IHRoaXMudGV4dDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgd2lkdGggYW5kIGhlaWdodCAobmVlZCB0byBwcmVyZW5kZXIgdGhlIGJ1dHRvblxuICAgIC8vIGZpcnN0KVxuICAgIHRoaXMudGV4dE5vZGUuX3AoKTtcblxuICAgIGxldCB3aWR0aCA9IHRoaXMudGV4dE5vZGUud2lkdGggKyB0aGlzLnBhZFggKiAyO1xuICAgIGxldCBoZWlnaHQgPSB0aGlzLnRleHROb2RlLmhlaWdodCArIHRoaXMucGFkWSAqIDI7XG5cbiAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMud2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCB0aGlzLmhlaWdodCk7XG4gICAgdGhpcy5fdXcoKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5fZCkge1xuICAgICAgdGhpcy5fcCgpO1xuICAgIH1cblxuICAgIHN1cGVyLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGUgYnV0dG9uLiBDYWxscyBbb25FbmFibGVdKGFwaS9idXR0b24jb25FbmFibGUpIGlmIHBhc3NlZC5cbiAgICogQG1lbWJlcm9mIEJ1dHRvblxuICAgKiBAZnVuY3Rpb24gZW5hYmxlXG4gICAqL1xuICBlbmFibGUoKSB7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYnV0dG9uIGlzIGRpc2FibGVkLlxuICAgICAqIEBtZW1iZXJvZiBCdXR0b25cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGRpc2FibGVkXG4gICAgICovXG4gICAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuX2RuLmRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5vbkVuYWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGUgdGhlIGJ1dHRvbi4gQSBkaXNhYmxlZCBidXR0b24gd2lsbCBub3QgbG9uZ2VyIHJlbmRlciBub3IgcmVzcG9uZCB0byBwb2ludGVyIGFuZCBrZXlib2FyZCBldmVudHMuIENhbGxzIFtvbkRpc2FibGVdKGFwaS9idXR0b24jb25EaXNhYmxlKSBpZiBwYXNzZWQuXG4gICAqIEBtZW1iZXJvZiBCdXR0b25cbiAgICogQGZ1bmN0aW9uIGRpc2FibGVcbiAgICovXG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuX2RuLmRpc2FibGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9uRGlzYWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvY3VzIHRoZSBidXR0b24uIENhbGxzIFtvbkZvY3VzXShhcGkvYnV0dG9uI29uRm9jdXMpIGlmIHBhc3NlZC5cbiAgICogQG1lbWJlcm9mIEJ1dHRvblxuICAgKiBAZnVuY3Rpb24gZm9jdXNcbiAgICovXG4gIGZvY3VzKCkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuXG4gICAgICAvKipcbiAgICAgICAqIElmIHRoZSBidXR0b24gaXMgZm9jdXNlZC5cbiAgICAgICAqIEBtZW1iZXJvZiBCdXR0b25cbiAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZm9jdXNlZFxuICAgICAgICovXG4gICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgLy8gcHJldmVudCBpbmZpbml0ZSBsb29wXG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPSB0aGlzLl9kbikgdGhpcy5fZG4uZm9jdXMoKTtcblxuICAgICAgdGhpcy5vbkZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJsdXIgdGhlIGJ1dHRvbi4gQ2FsbHMgW29uQmx1cl0oYXBpL2J1dHRvbiNvbkJsdXIpIGlmIHBhc3NlZC5cbiAgICogQG1lbWJlcm9mIEJ1dHRvblxuICAgKiBAZnVuY3Rpb24gYmx1clxuICAgKi9cbiAgYmx1cigpIHtcbiAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAvLyBwcmV2ZW50IGluZmluaXRlIGxvb3BcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSB0aGlzLl9kbikgdGhpcy5fZG4uYmx1cigpO1xuXG4gICAgdGhpcy5vbkJsdXIoKTtcbiAgfVxuXG4gIG9uT3ZlcigpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgYnV0dG9uIGlzIGhvdmVyZWQuXG4gICAgICAgKiBAbWVtYmVyb2YgQnV0dG9uXG4gICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGhvdmVyZWRcbiAgICAgICAqL1xuICAgICAgdGhpcy5ob3ZlcmVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBvbk91dCgpIHtcbiAgICB0aGlzLmhvdmVyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGVuIGJ1dHRvbiBpcyBlbmFibGVkLiBPdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIGhhdmUgdGhlIGJ1dHRvbiBkbyBzb21ldGhpbmcgd2hlbiBlbmFibGVkLlxuICAgKiBAbWVtYmVyb2YgQnV0dG9uXG4gICAqIEBmdW5jdGlvbiBvbkVuYWJsZVxuICAgKi9cbiAgb25FbmFibGUoKSB7fVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGVuIGJ1dHRvbiBpcyBkaXNhYmxlZC4gT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBoYXZlIHRoZSBidXR0b24gZG8gc29tZXRoaW5nIHdoZW4gZGlzYWJsZWQuXG4gICAqIEBtZW1iZXJvZiBCdXR0b25cbiAgICogQGZ1bmN0aW9uIG9uRGlzYWJsZVxuICAgKi9cbiAgb25EaXNhYmxlKCkge31cblxuICAvKipcbiAgICogRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlbiBidXR0b24gaXMgZm9jdXNlZC4gT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBoYXZlIHRoZSBidXR0b24gZG8gc29tZXRoaW5nIHdoZW4gZm9jdXNlZC5cbiAgICogQG1lbWJlcm9mIEJ1dHRvblxuICAgKiBAZnVuY3Rpb24gb25Gb2N1c1xuICAgKi9cbiAgb25Gb2N1cygpIHt9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZW4gYnV0dG9uIGlzIGJsdXJyZWQuIE92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gaGF2ZSB0aGUgYnV0dG9uIGRvIHNvbWV0aGluZyB3aGVuIGJsdXJyZWQuXG4gICAqIEBtZW1iZXJvZiBCdXR0b25cbiAgICogQGZ1bmN0aW9uIG9uQmx1clxuICAgKi9cbiAgb25CbHVyKCkge31cblxuICBvbkRvd24oKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdGhlIGJ1dHRvbiBpcyBwcmVzc2VkLlxuICAgICAgICogQG1lbWJlcm9mIEJ1dHRvblxuICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBwcmVzc2VkXG4gICAgICAgKi9cbiAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICB0aGlzLl9vZCgpO1xuICAgIH1cbiAgfVxuXG4gIG9uVXAoKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX291KCk7XG4gICAgfVxuICB9XG5cbiAgLy8ga2QgPSBrZXlkb3duXG4gIF9rZChldnQpIHtcbiAgICAvLyBhY3RpdmF0ZSBidXR0b24gb24gZW50ZXIgb3Igc3BhY2VcbiAgICBpZiAoZXZ0LmNvZGUgPT0gJ0VudGVyJyB8fCBldnQuY29kZSA9PSAnU3BhY2UnKSB7XG4gICAgICB0aGlzLm9uRG93bigpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGtkID0ga2V5ZG93blxuICBfa3UoZXZ0KSB7XG4gICAgLy8gYWN0aXZhdGUgYnV0dG9uIG9uIGVudGVyIG9yIHNwYWNlXG4gICAgaWYgKGV2dC5jb2RlID09ICdFbnRlcicgfHwgZXZ0LmNvZGUgPT0gJ1NwYWNlJykge1xuICAgICAgdGhpcy5vblVwKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZhY3RvcnkkNSgpIHtcbiAgcmV0dXJuIG5ldyBCdXR0b24oLi4uYXJndW1lbnRzKTtcbn1cbmZhY3RvcnkkNS5wcm90b3R5cGUgPSBCdXR0b24ucHJvdG90eXBlO1xuZmFjdG9yeSQ1LmNsYXNzID0gQnV0dG9uO1xuXG4vKipcbiAqIENsZWFyIHRoZSBjYW52YXMuXG4gKi9cbmZ1bmN0aW9uIGNsZWFyKGNvbnRleHQpIHtcbiAgbGV0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xufVxuXG4vKipcbiAqIFRoZSBnYW1lIGxvb3AgdXBkYXRlcyBhbmQgcmVuZGVycyB0aGUgZ2FtZSBldmVyeSBmcmFtZS4gVGhlIGdhbWUgbG9vcCBpcyBzdG9wcGVkIGJ5IGRlZmF1bHQgYW5kIHdpbGwgbm90IHN0YXJ0IHVudGlsIHRoZSBsb29wcyBgc3RhcnQoKWAgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICpcbiAqIFRoZSBnYW1lIGxvb3AgdXNlcyBhIHRpbWUtYmFzZWQgYW5pbWF0aW9uIHdpdGggYSBmaXhlZCBgZHRgIHRvIFthdm9pZCBmcmFtZSByYXRlIGlzc3Vlc10oaHR0cDovL2Jsb2cuc2tsYW1iZXJ0LmNvbS91c2luZy10aW1lLWJhc2VkLWFuaW1hdGlvbi1pbXBsZW1lbnQvKS4gRWFjaCB1cGRhdGUgY2FsbCBpcyBndWFyYW50ZWVkIHRvIGVxdWFsIDEvNjAgb2YgYSBzZWNvbmQuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IHlvdSBjYW4gYXZvaWQgaGF2aW5nIHRvIGRvIHRpbWUgYmFzZWQgY2FsY3VsYXRpb25zIGluIHlvdXIgdXBkYXRlIGZ1bmN0aW9ucyBhbmQgaW5zdGVhZCBkbyBmaXhlZCB1cGRhdGVzLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBTcHJpdGUsIEdhbWVMb29wIH0gZnJvbSAna29udHJhJztcbiAqXG4gKiBsZXQgc3ByaXRlID0gU3ByaXRlKHtcbiAqICAgeDogMTAwLFxuICogICB5OiAyMDAsXG4gKiAgIHdpZHRoOiAyMCxcbiAqICAgaGVpZ2h0OiA0MCxcbiAqICAgY29sb3I6ICdyZWQnXG4gKiB9KTtcbiAqXG4gKiBsZXQgbG9vcCA9IEdhbWVMb29wKHtcbiAqICAgdXBkYXRlOiBmdW5jdGlvbihkdCkge1xuICogICAgIC8vIG5vIG5lZWQgdG8gZGV0ZXJtaW5lIGhvdyBtYW55IHBpeGVscyB5b3Ugd2FudCB0b1xuICogICAgIC8vIG1vdmUgZXZlcnkgc2Vjb25kIGFuZCBtdWx0aXBsZSBieSBkdFxuICogICAgIC8vIHNwcml0ZS54ICs9IDE4MCAqIGR0O1xuICpcbiAqICAgICAvLyBpbnN0ZWFkIGp1c3QgdXBkYXRlIGJ5IGhvdyBtYW55IHBpeGVscyB5b3Ugd2FudFxuICogICAgIC8vIHRvIG1vdmUgZXZlcnkgZnJhbWUgYW5kIHRoZSBsb29wIHdpbGwgZW5zdXJlIDYwRlBTXG4gKiAgICAgc3ByaXRlLnggKz0gMztcbiAqICAgfSxcbiAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICBzcHJpdGUucmVuZGVyKCk7XG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGxvb3Auc3RhcnQoKTtcbiAqIGBgYFxuICogQGNsYXNzIEdhbWVMb29wXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBQcm9wZXJ0aWVzIG9mIHRoZSBnYW1lIGxvb3AuXG4gKiBAcGFyYW0geyhkdDogTnVtYmVyKSA9PiB2b2lkfSBbcHJvcGVydGllcy51cGRhdGVdIC0gRnVuY3Rpb24gY2FsbGVkIGV2ZXJ5IGZyYW1lIHRvIHVwZGF0ZSB0aGUgZ2FtZS4gSXMgcGFzc2VkIHRoZSBmaXhlZCBgZHRgIGFzIGEgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcGVydGllcy5yZW5kZXIgLSBGdW5jdGlvbiBjYWxsZWQgZXZlcnkgZnJhbWUgdG8gcmVuZGVyIHRoZSBnYW1lLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW3Byb3BlcnRpZXMuZnBzPTYwXSAtIERlc2lyZWQgZnJhbWUgcmF0ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gIFtwcm9wZXJ0aWVzLmNsZWFyQ2FudmFzPXRydWVdIC0gQ2xlYXIgdGhlIGNhbnZhcyBldmVyeSBmcmFtZSBiZWZvcmUgdGhlIGByZW5kZXIoKWAgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtwcm9wZXJ0aWVzLmNvbnRleHRdIC0gVGhlIGNvbnRleHQgdGhhdCBzaG91bGQgYmUgY2xlYXJlZCBlYWNoIGZyYW1lIGlmIGBjbGVhckNvbnRleHRgIGlzIG5vdCBzZXQgdG8gYGZhbHNlYC4gRGVmYXVsdHMgdG8gW2NvcmUuZ2V0Q29udGV4dCgpXShhcGkvY29yZSNnZXRDb250ZXh0KS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Byb3BlcnRpZXMuYmx1cj1mYWxzZV0gLSBJZiB0aGUgbG9vcCBzaG91bGQgc3RpbGwgdXBkYXRlIGFuZCByZW5kZXIgaWYgdGhlIHBhZ2UgZG9lcyBub3QgaGF2ZSBmb2N1cy5cbiAqL1xuZnVuY3Rpb24gR2FtZUxvb3Aoe1xuICBmcHMgPSA2MCxcbiAgY2xlYXJDYW52YXMgPSB0cnVlLFxuICB1cGRhdGUgPSBub29wLFxuICByZW5kZXIsXG4gIGNvbnRleHQgPSBnZXRDb250ZXh0KCksXG4gIGJsdXIgPSBmYWxzZVxufSA9IHt9KSB7XG4gIC8vIGNoZWNrIGZvciByZXF1aXJlZCBmdW5jdGlvbnNcbiAgLy8gQGlmZGVmIERFQlVHXG4gIGlmICghcmVuZGVyKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSByZW5kZXIoKSBmdW5jdGlvbicpO1xuICB9XG4gIC8vIEBlbmRpZlxuXG4gIC8vIGFuaW1hdGlvbiB2YXJpYWJsZXNcbiAgbGV0IGFjY3VtdWxhdG9yID0gMDtcbiAgbGV0IGRlbHRhID0gMUUzIC8gZnBzOyAgLy8gZGVsdGEgYmV0d2VlbiBwZXJmb3JtYW5jZS5ub3cgdGltaW5ncyAoaW4gbXMpXG4gIGxldCBzdGVwID0gMSAvIGZwcztcbiAgbGV0IGNsZWFyRm4gPSBjbGVhckNhbnZhcyA/IGNsZWFyIDogbm9vcDtcbiAgbGV0IGxhc3QsIHJBRiwgbm93LCBkdCwgbG9vcDtcbiAgbGV0IGZvY3VzZWQgPSB0cnVlO1xuXG4gIGlmICghYmx1cikge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICgpID0+IHsgZm9jdXNlZCA9IHRydWU7IH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKCkgPT4geyBmb2N1c2VkID0gZmFsc2U7IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBldmVyeSBmcmFtZSBvZiB0aGUgZ2FtZSBsb29wLlxuICAgKi9cbiAgZnVuY3Rpb24gZnJhbWUoKSB7XG4gICAgckFGID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcblxuICAgIC8vIGRvbid0IHVwZGF0ZSB0aGUgZnJhbWUgaWYgdGFiIGlzbid0IGZvY3VzZWRcbiAgICBpZiAoIWZvY3VzZWQpIHJldHVybjtcblxuICAgIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGR0ID0gbm93IC0gbGFzdDtcbiAgICBsYXN0ID0gbm93O1xuXG4gICAgLy8gcHJldmVudCB1cGRhdGluZyB0aGUgZ2FtZSB3aXRoIGEgdmVyeSBsYXJnZSBkdCBpZiB0aGUgZ2FtZSB3ZXJlIHRvIGxvc2UgZm9jdXNcbiAgICAvLyBhbmQgdGhlbiByZWdhaW4gZm9jdXMgbGF0ZXJcbiAgICBpZiAoZHQgPiAxRTMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbWl0KCd0aWNrJyk7XG4gICAgYWNjdW11bGF0b3IgKz0gZHQ7XG5cbiAgICB3aGlsZSAoYWNjdW11bGF0b3IgPj0gZGVsdGEpIHtcbiAgICAgIGxvb3AudXBkYXRlKHN0ZXApO1xuXG4gICAgICBhY2N1bXVsYXRvciAtPSBkZWx0YTtcbiAgICB9XG5cbiAgICBjbGVhckZuKGNvbnRleHQpO1xuICAgIGxvb3AucmVuZGVyKCk7XG4gIH1cblxuICAvLyBnYW1lIGxvb3Agb2JqZWN0XG4gIGxvb3AgPSB7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGV2ZXJ5IGZyYW1lIHRvIHVwZGF0ZSB0aGUgZ2FtZS4gUHV0IGFsbCBvZiB5b3VyIGdhbWVzIHVwZGF0ZSBsb2dpYyBoZXJlLlxuICAgICAqIEBtZW1iZXJvZiBHYW1lTG9vcFxuICAgICAqIEBmdW5jdGlvbiB1cGRhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZHRdIC0gVGhlIGZpeGVkIGR0IHRpbWUgb2YgMS82MCBvZiBhIGZyYW1lLlxuICAgICAqL1xuICAgIHVwZGF0ZSxcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBldmVyeSBmcmFtZSB0byByZW5kZXIgdGhlIGdhbWUuIFB1dCBhbGwgb2YgeW91ciBnYW1lcyByZW5kZXIgbG9naWMgaGVyZS5cbiAgICAgKiBAbWVtYmVyb2YgR2FtZUxvb3BcbiAgICAgKiBAZnVuY3Rpb24gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyLFxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGdhbWUgbG9vcCBpcyBjdXJyZW50bHkgc3RvcHBlZC5cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IHsgR2FtZUxvb3AgfSBmcm9tICdrb250cmEnO1xuICAgICAqXG4gICAgICogbGV0IGxvb3AgPSBHYW1lTG9vcCh7XG4gICAgICogICAvLyAuLi5cbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhsb29wLmlzU3RvcHBlZCk7ICAvLz0+IHRydWVcbiAgICAgKlxuICAgICAqIGxvb3Auc3RhcnQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhsb29wLmlzU3RvcHBlZCk7ICAvLz0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBsb29wLnN0b3AoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhsb29wLmlzU3RvcHBlZCk7ICAvLz0+IHRydWVcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgR2FtZUxvb3BcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzU3RvcHBlZFxuICAgICAqL1xuICAgIGlzU3RvcHBlZDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBnYW1lIGxvb3AuXG4gICAgICogQG1lbWJlcm9mIEdhbWVMb29wXG4gICAgICogQGZ1bmN0aW9uIHN0YXJ0XG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICBsYXN0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgZ2FtZSBsb29wLlxuICAgICAqIEBtZW1iZXJvZiBHYW1lTG9vcFxuICAgICAqIEBmdW5jdGlvbiBzdG9wXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJBRik7XG4gICAgfSxcblxuICAgIC8vIGV4cG9zZSBwcm9wZXJ0aWVzIGZvciB0ZXN0aW5nXG4gICAgLy8gQGlmZGVmIERFQlVHXG4gICAgX2ZyYW1lOiBmcmFtZSxcbiAgICBzZXQgX2xhc3QodmFsdWUpIHtcbiAgICAgIGxhc3QgPSB2YWx1ZTtcbiAgICB9XG4gICAgLy8gQGVuZGlmXG4gIH07XG5cbiAgcmV0dXJuIGxvb3A7XG59XG5cbmxldCBoYW5kbGVyID0ge1xuICBzZXQob2JqLCBwcm9wLCB2YWx1ZSkge1xuXG4gICAgLy8gZG9uJ3Qgc2V0IGRpcnR5IGZvciBwcml2YXRlIHByb3BlcnRpZXNcbiAgICBpZiAoIXByb3Auc3RhcnRzV2l0aCgnXycpKSB7XG4gICAgICBvYmouX2QgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBSZWZsZWN0LnNldChvYmosIHByb3AsIHZhbHVlKTtcbiAgfVxufTtcblxubGV0IGFsaWdubWVudCA9IHtcbiAgc3RhcnQocnRsKSB7XG4gICAgcmV0dXJuIHJ0bCA/IDEgOiAwO1xuICB9LFxuICBjZW50ZXIoKSB7XG4gICAgcmV0dXJuIDAuNTtcbiAgfSxcbiAgZW5kKHJ0bCkge1xuICAgIHJldHVybiBydGwgPyAwIDogMTtcbiAgfVxufTtcblxuLyoqXG4gKiBRdWlja2x5IGFuZCBlYXNpbHkgb3JnYW5pemUgeW91ciBVSSBlbGVtZW50cyBpbnRvIGEgZ3JpZC4gV29ya3MgZ3JlYXQgZm9yIGF1dG8gcGxhY2luZyBtZW51IG9wdGlvbnMgd2l0aG91dCBoYXZpbmcgdG8gZmlndXJlIG91dCB0aGUgcG9zaXRpb24gZm9yIGVhY2ggb25lLiBCYXNlZCBvbiB0aGUgY29uY2VwdCBvZiBDU1MgR3JpZCBMYXlvdXQuXG4gKiBAY2xhc3MgR3JpZFxuICogQGV4dGVuZHMgR2FtZU9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gLSBQcm9wZXJ0aWVzIG9mIHRoZSBncmlkIG1hbmFnZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnRpZXMuZmxvdz0nY29sdW1uJ10gLSBUaGUgZmxvdyBvZiB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydGllcy5hbGlnbj0nc3RhcnQnXSAtIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGhlIGdyaWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnRpZXMuanVzdGlmeT0nc3RhcnQnXSAtIFRoZSBob3Jpem9udGFsIGFsaWdubWVudCBvZiB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7TnVtYmVyfE51bWJlcltdfSBbcHJvcGVydGllcy5jb2xHYXA9MF0gLSBUaGUgaG9yaXpvbnRhbCBnYXAgYmV0d2VlbiBlYWNoIGNvbHVtbiBpbiB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7TnVtYmVyfE51bWJlcltdfSBbcHJvcGVydGllcy5yb3dHYXA9MF0gLSBUaGUgdmVydGljYWwgZ2FwIGJldHdlZW4gZWFjaCByb3cgaW4gdGhlIGdyaWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW3Byb3BlcnRpZXMubnVtQ29scz0xXSAtIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgZ3JpZC4gT25seSBhcHBsaWVzIGlmIHRoZSBgZmxvd2AgcHJvcGVydHkgaXMgc2V0IHRvIGBncmlkYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydGllcy5kaXI9JyddIC0gVGhlIGRpcmVjdGlvbiBvZiB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7e21ldHJpYzogRnVuY3Rpb24sIGNhbGxiYWNrOiBGdW5jdGlvbn1bXX0gW3Byb3BlcnRpZXMuYnJlYWtwb2ludHM9W11dIC0gSG93IHRoZSBncmlkIHNob3VsZCBjaGFuZ2UgYmFzZWQgb24gZGlmZmVyZW50IG1ldHJpY3MuXG4gKi9cbmNsYXNzIEdyaWQgZXh0ZW5kcyBmYWN0b3J5JDIuY2xhc3Mge1xuICAvKipcbiAgICogQGRvY3MgZG9jcy9hcGlfZG9jcy9ncmlkLmpzXG4gICAqL1xuXG4gIGluaXQoe1xuICAgIC8qKlxuICAgICAqIEhvdyB0byBvcmdhbml6ZSBhbGwgb2JqZWN0cyBpbiB0aGUgZ3JpZC4gVmFsaWQgdmFsdWVzIGFyZTpcbiAgICAgKlxuICAgICAqIC0gYGNvbHVtbmAgLSBvcmdhbml6ZSBpbnRvIGEgc2luZ2xlIGNvbHVtblxuICAgICAqIC0gYHJvd2AgLSBvcmdhbml6ZSBpbnRvIGEgc2luZ2xlIHJvd1xuICAgICAqIC0gYGdyaWRgIC0gb3JnYW5pemUgaW50byBhIGdyaWQgd2l0aCBbbnVtQ29sc10oYXBpL2dyaWQjbnVtQ29scykgbnVtYmVyIG9mIGNvbHVtbnNcbiAgICAgKiBAbWVtYmVyb2YgR3JpZFxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmbG93XG4gICAgICovXG4gICAgZmxvdyA9ICdjb2x1bW4nLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgZ3JpZC4gVmFsaWQgdmFsdWVzIGFyZTpcbiAgICAgKlxuICAgICAqIC0gYHN0YXJ0YCAtIGFsaWduIHRvIHRoZSB0b3Agb2Ygcm93XG4gICAgICogLSBgY2VudGVyYCAtIGFsaWduIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHJvd1xuICAgICAqIC0gYGVuZGAgLSBhbGlnbiB0byB0aGUgdGhlIGJvdHRvbSBvZiB0aGUgcm93XG4gICAgICpcbiAgICAgKiBBZGRpdGlvbmFsbHksIGVhY2ggY2hpbGQgb2YgdGhlIGdyaWQgY2FuIHVzZSB0aGUgYGFsaWduU2VsZmAgcHJvcGVydHkgdG8gY2hhbmdlIGl0J3MgYWxpZ25tZW50IGluIHRoZSBncmlkLlxuICAgICAqIEBtZW1iZXJvZiBHcmlkXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGFsaWduXG4gICAgICovXG4gICAgYWxpZ24gPSAnc3RhcnQnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGhvcml6b250YWwgYWxpZ25tZW50IG9mIHRoZSBncmlkLiBWYWxpZCB2YWx1ZXMgYXJlOlxuICAgICAqXG4gICAgICogLSBgc3RhcnRgIC0gYWxpZ24gdG8gdGhlIGxlZnQgb2YgY29sdW1uXG4gICAgICogLSBgY2VudGVyYCAtIGFsaWduIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNvbHVtblxuICAgICAqIC0gYGVuZGAgLSBhbGlnbiB0byB0aGUgdGhlIHJpZ2h0IG9mIHRoZSBjb2x1bW5cbiAgICAgKlxuICAgICAqIElmIHRoZSBbZGlyXShhcGkvZ3JpZCNkaXIpIHByb3BlcnR5IGlzIHNldCB0byBgcnRsYCwgdGhlbiBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgcmV2ZXJzZWQuXG4gICAgICpcbiAgICAgKiBBZGRpdGlvbmFsbHksIGVhY2ggY2hpbGQgb2YgdGhlIGdyaWQgY2FuIHVzZSB0aGUgYGp1c3RpZnlTZWxmYCBwcm9wZXJ0eSB0byBjaGFuZ2UgaXQncyBhbGlnbm1lbnQgaW4gdGhlIGdyaWQuXG4gICAgICogQG1lbWJlcm9mIEdyaWRcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30ganVzdGlmeVxuICAgICAqL1xuICAgIGp1c3RpZnkgPSAnc3RhcnQnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGhvcml6b250YWwgZ2FwIGJldHdlZW4gZWFjaCBjb2x1bW4gaW4gdGhlIGdyaWQuXG4gICAgICpcbiAgICAgKiBBbiBhcnJheSBvZiBudW1iZXJzIG1lYW5zIHRoZSBncmlkIHdpbGwgc2V0IHRoZSBnYXAgYmV0d2VlbiBjb2x1bW5zIHVzaW5nIHRoZSBvcmRlciBvZiB0aGUgYXJyYXkuIEZvciBleGFtcGxlLCBpZiB0aGUgZ2FwIGlzIHNldCB0byBiZSBgWzEwLCA1XWAsIHRoZW4gZXZlcnkgb2RkIGNvbHVtbiBnYXAgd2l0aCB1c2UgMTAgYW5kIGV2ZXJ5IGV2ZW4gY29sdW1uIGdhcCB3aWxsIHVzZSA1LlxuICAgICAqIEBtZW1iZXJvZiBHcmlkXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8TnVtYmVyW119IGNvbEdhcFxuICAgICAqL1xuICAgIGNvbEdhcCA9IDAsXG5cbiAgICAgLyoqXG4gICAgICogVGhlIHZlcnRpY2FsIGdhcCBiZXR3ZWVuIGVhY2ggcm93IGluIHRoZSBncmlkLlxuICAgICAqXG4gICAgICogQW4gYXJyYXkgb2YgbnVtYmVycyBtZWFucyB0aGUgZ3JpZCB3aWxsIHNldCB0aGUgZ2FwIGJldHdlZW4gcm93cyB1c2luZyB0aGUgb3JkZXIgb2YgdGhlIGFycmF5LiBGb3IgZXhhbXBsZSwgaWYgdGhlIGdhcCBpcyBzZXQgdG8gYmUgYFsxMCwgNV1gLCB0aGVuIGV2ZXJ5IG9kZCByb3cgZ2FwIHdpdGggdXNlIDEwIGFuZCBldmVyeSBldmVuIHJvdyBnYXAgd2lsbCB1c2UgNS5cbiAgICAgKiBAbWVtYmVyb2YgR3JpZFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfE51bWJlcltdfSByb3dHYXBcbiAgICAgKi9cbiAgICByb3dHYXAgPSAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBncmlkLiBPbmx5IGFwcGxpZXMgaWYgdGhlIFtmbG93XShhcGkvZ3JpZCNmbG93KSBwcm9wZXJ0eSBpcyBzZXQgdG8gYGdyaWRgLlxuICAgICAqIEBtZW1iZXJvZiBHcmlkXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG51bUNvbHNcbiAgICAgKi9cbiAgICBudW1Db2xzID0gMSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXJlY3Rpb24gb2YgdGhlIGdyaWQuIERlZmF1bHRzIHRvIG9yZ2FuaXppbmcgdGhlIGdyaWQgb2JqZWN0cyBsZWZ0LXRvLXJpZ2h0LCBidXQgaWYgc2V0IHRvIGBydGxgIHRoZW4gdGhlIGdyaWQgaXMgb3JnYW5pemVkIHJpZ2h0LXRvLWxlZnQuXG4gICAgICpcbiAgICAgKiBXaGVuIGRldGVybWluaW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGdyaWQsIHRoZSBjYW52YXMgYGRpcmAgYXR0cmlidXRlIGlzIGFsc28gdGFrZW4gaW50byBhY2NvdW50LiBTZXR0aW5nIHRoZSBhdHRyaWJ1dGUgdG8gYHJ0bGAgaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIHRoZSBgZGlyYCBwcm9wZXJ0eSB0byBgcnRsYC4gVGhlIGBkaXJgIHByb3BlcnR5IGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgY2FudmFzIGF0dHJpYnV0ZSBpZiBib3RoIGFyZSBzZXQuXG4gICAgICogQG1lbWJlcm9mIEdyaWRcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZGlyXG4gICAgICovXG4gICAgZGlyID0gJycsXG5cbiAgICAvKipcbiAgICAgKiBIb3cgdGhlIGdyaWQgc2hvdWxkIGNoYW5nZSBiYXNlZCBvbiBkaWZmZXJlbnQgbWV0cmljcy4gQmFzZWQgb24gdGhlIGNvbmNlcHQgb2YgQ1NTIE1lZGlhIFF1ZXJpZXMgc28geW91IGNhbiB1cGRhdGUgaG93IHRoZSBncmlkIG9yZ2FuaXplcyB0aGUgb2JqZWN0cyB3aGVuIHRoaW5ncyBjaGFuZ2UgKHN1Y2ggYXMgdGhlIHNjYWxlKS5cbiAgICAgKlxuICAgICAqIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheSB1c2VzIHRoZSBgbWV0cmljKClgIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGVuIHRoZSBicmVha3BvaW50IGFwcGxpZXMgYW5kIHRoZSBgY2FsbGJhY2soKWAgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGNoYW5nZSBhbnkgcHJvcGVydGllcyBvZiB0aGUgZ3JpZC5cbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IHsgR3JpZCB9ID0ga29udHJhO1xuICAgICAqXG4gICAgICogbGV0IGdyaWQgPSBHcmlkKHtcbiAgICAgKiAgIGJyZWFrcG9pbnRzOiBbe1xuICAgICAqICAgICBtZXRyaWMoKSB7XG4gICAgICogICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYIDwgMVxuICAgICAqICAgICB9LFxuICAgICAqICAgICBjYWxsYmFjaygpIHtcbiAgICAgKiAgICAgICB0aGlzLm51bUNvbHMgPSAxO1xuICAgICAqICAgICB9XG4gICAgICogICB9LFxuICAgICAqICAge1xuICAgICAqICAgICBtZXRyaWMoKSB7XG4gICAgICogICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYID49IDFcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgY2FsbGJhY2soKSB7XG4gICAgICogICAgICAgdGhpcy5udW1Db2xzID0gMjtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfV1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgR3JpZFxuICAgICAqIEBwcm9wZXJ0eSB7e21ldHJpYzogRnVuY3Rpb24sIGNhbGxiYWNrOiBGdW5jdGlvbn1bXX0gYnJlYWtwb2ludHNcbiAgICAgKi9cbiAgICBicmVha3BvaW50cyA9IFtdLFxuXG4gICAgLi4ucHJvcHNcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIuaW5pdCh7XG4gICAgICBmbG93LFxuICAgICAgYWxpZ24sXG4gICAgICBqdXN0aWZ5LFxuICAgICAgY29sR2FwLFxuICAgICAgcm93R2FwLFxuICAgICAgbnVtQ29scyxcbiAgICAgIGRpcixcbiAgICAgIGJyZWFrcG9pbnRzLFxuICAgICAgLi4ucHJvcHNcbiAgICB9KTtcblxuICAgIHRoaXMuX3AoKTtcbiAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIGhhbmRsZXIpO1xuICB9XG5cbiAgYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICB0aGlzLl9kID0gdHJ1ZTtcbiAgICBzdXBlci5hZGRDaGlsZChjaGlsZCk7XG4gIH1cblxuICByZW1vdmVDaGlsZChjaGlsZCkge1xuICAgIHRoaXMuX2QgPSB0cnVlO1xuICAgIHN1cGVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5fZCkge1xuICAgICAgdGhpcy5fcCgpO1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGBkZXN0cm95KClgIG9uIGFsbCBjaGlsZHJlbi5cbiAgICogQG1lbWJlcm9mIEdyaWRcbiAgICogQGZ1bmN0aW9uIGRlc3Ryb3lcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQuZGVzdHJveSAmJiBjaGlsZC5kZXN0cm95KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIHRoZSBncmlkIGFuZCBjYWxjdWxhdGUgaXRzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICovXG4gIF9wKCkge1xuICAgIHRoaXMuX2QgPSBmYWxzZTtcblxuICAgIHRoaXMuYnJlYWtwb2ludHMubWFwKGJyZWFrcG9pbnQgPT4ge1xuICAgICAgLy8gYiA9IGJyZWFrcG9pbnRcbiAgICAgIGlmIChicmVha3BvaW50Lm1ldHJpYy5jYWxsKHRoaXMpICYmIHRoaXMuX2IgIT09IGJyZWFrcG9pbnQpIHtcbiAgICAgICAgdGhpcy5fYiA9IGJyZWFrcG9pbnQ7XG4gICAgICAgIGJyZWFrcG9pbnQuY2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGcgPSBncmlkLCBjdyA9IGNvbFdpZHRocywgcmggPSByb3dIZWlnaHRzXG4gICAgbGV0IGdyaWQgPSB0aGlzLl9nID0gW107XG4gICAgbGV0IGNvbFdpZHRocyA9IHRoaXMuX2N3ID0gW107XG4gICAgbGV0IHJvd0hlaWdodHMgPSB0aGlzLl9yaCA9IFtdO1xuICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICAvLyBuYyA9IG51bUNvbHNcbiAgICBsZXQgbnVtQ29scyA9IHRoaXMuX25jID0gdGhpcy5mbG93ID09PSAnY29sdW1uJ1xuICAgICAgPyAxXG4gICAgICA6IHRoaXMuZmxvdyA9PT0gJ3JvdydcbiAgICAgICAgPyBjaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgOiB0aGlzLm51bUNvbHM7XG5cbiAgICBsZXQgcm93ID0gMDtcbiAgICBsZXQgY29sID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgY2hpbGQ7IGNoaWxkID0gY2hpbGRyZW5baV07IGkrKykge1xuICAgICAgZ3JpZFtyb3ddID0gZ3JpZFtyb3ddIHx8IFtdO1xuXG4gICAgICAvLyBwcmVyZW5kZXIgY2hpbGQgdG8gZ2V0IGN1cnJlbnQgd2lkdGgvaGVpZ2h0XG4gICAgICBpZiAoY2hpbGQuX3ApIHtcbiAgICAgICAgY2hpbGQuX3AoKTtcbiAgICAgIH1cblxuICAgICAgcm93SGVpZ2h0c1tyb3ddID0gTWF0aC5tYXgocm93SGVpZ2h0c1tyb3ddIHx8IDAsIGNoaWxkLmhlaWdodCk7XG5cbiAgICAgIGxldCBzcGFucyA9IGNoaWxkLmNvbFNwYW4gfHwgMTtcbiAgICAgIGxldCBjb2xTcGFuID0gc3BhbnM7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbFdpZHRoc1tjb2xdID0gTWF0aC5tYXgoY29sV2lkdGhzW2NvbF0gfHwgMCwgY2hpbGQud2lkdGggLyBjb2xTcGFuKTtcbiAgICAgICAgZ3JpZFtyb3ddW2NvbF0gPSBjaGlsZDtcbiAgICAgIH0gd2hpbGUgKGNvbFNwYW4gKyBjb2wrKyA8PSBudW1Db2xzICYmIC0tc3BhbnMpO1xuXG4gICAgICBpZiAoY29sID49IG51bUNvbHMpIHtcbiAgICAgICAgY29sID0gMDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsbCByZW1haW5pbmcgcm93XG4gICAgd2hpbGUgKGNvbCA+IDAgJiYgY29sIDwgbnVtQ29scykge1xuICAgICAgLy8gYWRkIGVtcHR5IGFycmF5IGl0ZW0gc28gd2UgY2FuIHJldmVyc2UgYSByb3cgZXZlbiB3aGVuIGl0XG4gICAgICAvLyBjb250YWlucyBsZXNzIGl0ZW1zIHRoYW4gYW5vdGhlciByb3dcbiAgICAgIGdyaWRbcm93XVtjb2wrK10gPSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG51bVJvd3MgPSBncmlkLmxlbmd0aDtcblxuICAgIGxldCBjb2xHYXAgPSBbXS5jb25jYXQodGhpcy5jb2xHYXApO1xuICAgIGxldCByb3dHYXAgPSBbXS5jb25jYXQodGhpcy5yb3dHYXApO1xuXG4gICAgdGhpcy5fdyA9IGNvbFdpZHRocy5yZWR1Y2UoKGFjYywgd2lkdGgpID0+IGFjYyArPSB3aWR0aCwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db2xzIC0gMTsgaSsrKSB7XG4gICAgICB0aGlzLl93ICs9IGNvbEdhcFtpICUgY29sR2FwLmxlbmd0aF07XG4gICAgfVxuXG4gICAgdGhpcy5faCA9IHJvd0hlaWdodHMucmVkdWNlKChhY2MsIGhlaWdodCkgPT4gYWNjICs9IGhlaWdodCwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Sb3dzIC0gMTsgaSsrKSB7XG4gICAgICB0aGlzLl9oICs9IHJvd0dhcFtpICUgcm93R2FwLmxlbmd0aF07XG4gICAgfVxuXG4gICAgdGhpcy5fdXcoKTtcblxuICAgIC8vIHJldmVyc2UgY29sdW1ucy4gZGlyZWN0aW9uIHByb3BlcnR5IG92ZXJyaWRlcyBjYW52YXMgZGlyXG4gICAgbGV0IGRpciA9IHRoaXMuY29udGV4dC5jYW52YXMuZGlyO1xuICAgIGxldCBydGwgPSAoZGlyID09PSAncnRsJyAmJiAhdGhpcy5kaXIpIHx8IHRoaXMuZGlyID09PSAncnRsJztcbiAgICB0aGlzLl9ydGwgPSBydGw7XG4gICAgaWYgKHJ0bCkge1xuICAgICAgdGhpcy5fZyA9IGdyaWQubWFwKHJvdyA9PiByb3cucmV2ZXJzZSgpKTtcbiAgICAgIHRoaXMuX2N3ID0gY29sV2lkdGhzLnJldmVyc2UoKTtcbiAgICAgIGNvbEdhcCA9IGNvbEdhcC5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgbGV0IHRvcExlZnRZID0gLXRoaXMuYW5jaG9yLnkgKiB0aGlzLmhlaWdodDtcbiAgICBsZXQgcmVuZGVyZWQgPSBbXTtcblxuICAgIHRoaXMuX2cubWFwKChncmlkUm93LCByb3cpID0+IHtcbiAgICAgIGxldCB0b3BMZWZ0WCA9IC10aGlzLmFuY2hvci54ICogdGhpcy53aWR0aDtcblxuICAgICAgZ3JpZFJvdy5tYXAoKGNoaWxkLCBjb2wpID0+IHtcbiAgICAgICAgLy8gZG9uJ3QgcmVuZGVyIHRoZSBzYW1lIGNoaWxkIG11bHRpcGxlIHRpbWVzIGlmIGl0IHVzZXMgY29sU3BhblxuICAgICAgICBpZiAoY2hpbGQgJiYgIXJlbmRlcmVkLmluY2x1ZGVzKGNoaWxkKSkge1xuICAgICAgICAgIHJlbmRlcmVkLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgbGV0IGp1c3RpZnkgPSBhbGlnbm1lbnRbY2hpbGQuanVzdGlmeVNlbGYgfHwgdGhpcy5qdXN0aWZ5XSh0aGlzLl9ydGwpO1xuICAgICAgICAgIGxldCBhbGlnbiA9IGFsaWdubWVudFtjaGlsZC5hbGlnblNlbGYgfHwgdGhpcy5hbGlnbl0oKTtcblxuICAgICAgICAgIGxldCBjb2xTcGFuID0gY2hpbGQuY29sU3BhbiB8fCAxO1xuICAgICAgICAgIGxldCBjb2xXaWR0aCA9IGNvbFdpZHRoc1tjb2xdO1xuICAgICAgICAgIGlmIChjb2xTcGFuID4gMSAmJiBjb2wgKyBjb2xTcGFuIDw9IHRoaXMuX25jKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbFNwYW47IGkrKykge1xuICAgICAgICAgICAgICBjb2xXaWR0aCArPSBjb2xXaWR0aHNbY29sICsgaV0gKyBjb2xHYXBbKGNvbCArIGkpICUgY29sR2FwLmxlbmd0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHBvaW50WCA9IGNvbFdpZHRoICoganVzdGlmeTtcbiAgICAgICAgICBsZXQgcG9pbnRZID0gcm93SGVpZ2h0c1tyb3ddICogYWxpZ247XG4gICAgICAgICAgbGV0IGFuY2hvclggPSAwO1xuICAgICAgICAgIGxldCBhbmNob3JZID0gMDtcbiAgICAgICAgICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjaGlsZDtcblxuICAgICAgICAgIGlmIChjaGlsZC5hbmNob3IpIHtcbiAgICAgICAgICAgIGFuY2hvclggPSBjaGlsZC5hbmNob3IueDtcbiAgICAgICAgICAgIGFuY2hvclkgPSBjaGlsZC5hbmNob3IueTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHggcG9zaXRpb24gYmFzZWQgb24gdGhlIGFsaWdubWVudCBhbmRcbiAgICAgICAgICAvLyBhbmNob3Igb2YgdGhlIG9iamVjdFxuICAgICAgICAgIGlmIChqdXN0aWZ5ID09PSAwKSB7XG4gICAgICAgICAgICBwb2ludFggPSBwb2ludFggKyB3aWR0aCAqIGFuY2hvclg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGp1c3RpZnkgPT09IDAuNSkge1xuICAgICAgICAgICAgbGV0IHNpZ24gPSBhbmNob3JYIDwgMC41ID8gLTEgOiBhbmNob3JYID09PSAwLjUgPyAwIDogMTtcbiAgICAgICAgICAgIHBvaW50WCA9IHBvaW50WCArIHNpZ24gKiB3aWR0aCAqIGp1c3RpZnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRYID0gcG9pbnRYIC0gKHdpZHRoICogKDEgLSBhbmNob3JYKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB5IHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBqdXN0aWZpY2F0aW9uIGFuZFxuICAgICAgICAgIC8vIGFuY2hvciBvZiB0aGUgb2JqZWN0XG4gICAgICAgICAgaWYgKGFsaWduID09PSAwKSB7XG4gICAgICAgICAgICBwb2ludFkgPSBwb2ludFkgKyBoZWlnaHQgKiBhbmNob3JZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhbGlnbiA9PT0gMC41KSB7XG4gICAgICAgICAgICBsZXQgc2lnbiA9IGFuY2hvclkgPCAwLjUgPyAtMSA6IGFuY2hvclkgPT09IDAuNSA/IDAgOiAxO1xuICAgICAgICAgICAgcG9pbnRZID0gcG9pbnRZICsgc2lnbiAqIGhlaWdodCAqIGFsaWduO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50WSA9IHBvaW50WSAtIChoZWlnaHQgKiAoMSAtIGFuY2hvclkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZC54ID0gdG9wTGVmdFggKyBwb2ludFg7XG4gICAgICAgICAgY2hpbGQueSA9IHRvcExlZnRZICsgcG9pbnRZO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9wTGVmdFggKz0gY29sV2lkdGhzW2NvbF0gKyBjb2xHYXBbY29sICUgY29sR2FwLmxlbmd0aF07XG4gICAgICB9KTtcblxuICAgICAgdG9wTGVmdFkgKz0gcm93SGVpZ2h0c1tyb3ddICsgcm93R2FwW3JvdyAlIHJvd0dhcC5sZW5ndGhdO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZhY3RvcnkkNigpIHtcbiAgcmV0dXJuIG5ldyBHcmlkKC4uLmFyZ3VtZW50cyk7XG59XG5mYWN0b3J5JDYucHJvdG90eXBlID0gR3JpZC5wcm90b3R5cGU7XG5mYWN0b3J5JDYuY2xhc3MgPSBHcmlkO1xuXG4vKipcbiAqIEEgbWluaW1hbGlzdGljIGtleWJvYXJkIEFQSS4gWW91IGNhbiB1c2UgaXQgbW92ZSB0aGUgbWFpbiBzcHJpdGUgb3IgcmVzcG9uZCB0byBhIGtleSBwcmVzcy5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgaW5pdEtleXMsIGtleVByZXNzZWQgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIC8vIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgZmlyc3QgYmVmb3JlIGtleWJvYXJkXG4gKiAvLyBmdW5jdGlvbnMgd2lsbCB3b3JrXG4gKiBpbml0S2V5cygpO1xuICpcbiAqIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAqICAgaWYgKGtleVByZXNzZWQoJ2xlZnQnKSkge1xuICogICAgIC8vIG1vdmUgbGVmdFxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqIEBzZWN0aW9uTmFtZSBLZXlib2FyZFxuICovXG5cbi8qKlxuICogQmVsb3cgaXMgYSBsaXN0IG9mIGtleXMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgZGVmYXVsdC4gSWYgeW91IG5lZWQgdG8gZXh0ZW5kIHRoaXMgbGlzdCwgeW91IGNhbiB1c2UgdGhlIFtrZXlNYXBdKGFwaS9rZXlib2FyZCNrZXlNYXApIHByb3BlcnR5LlxuICpcbiAqIC0gYS16XG4gKiAtIDAtOVxuICogLSBlbnRlciwgZXNjLCBzcGFjZSwgbGVmdCwgdXAsIHJpZ2h0LCBkb3duXG4gKiBAc2VjdGlvbk5hbWUgQXZhaWxhYmxlIEtleXNcbiAqL1xuXG5sZXQga2V5ZG93bkNhbGxiYWNrcyA9IHt9O1xubGV0IGtleXVwQ2FsbGJhY2tzID0ge307XG5sZXQgcHJlc3NlZEtleXMgPSB7fTtcblxuLyoqXG4gKiBBIG1hcCBvZiBbS2V5Ym9hcmRFdmVudCBjb2RlIHZhbHVlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQvY29kZS9jb2RlX3ZhbHVlcykgdG8ga2V5IG5hbWVzLiBBZGQgdG8gdGhpcyBvYmplY3QgdG8gZXhwYW5kIHRoZSBsaXN0IG9mIFthdmFpbGFibGUga2V5c10oYXBpL2tleWJvYXJkI2F2YWlsYWJsZS1rZXlzKS5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsga2V5TWFwLCBiaW5kS2V5cyB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICoga2V5TWFwWydDb250cm9sUmlnaHQnXSA9ICdjdHJsJztcbiAqXG4gKiBiaW5kS2V5cygnY3RybCcsIGZ1bmN0aW9uKGUpIHtcbiAqICAgLy8gaGFuZGxlIGN0cmwga2V5XG4gKiB9KTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHt7W2tleSBpbiAoU3RyaW5nfE51bWJlcildOiBzdHJpbmd9fSBrZXlNYXBcbiAqL1xubGV0IGtleU1hcCA9IHtcbiAgLy8gbmFtZWQga2V5c1xuICAnRW50ZXInOiAnZW50ZXInLFxuICAnRXNjYXBlJzogJ2VzYycsXG4gICdTcGFjZSc6ICdzcGFjZScsXG4gICdBcnJvd0xlZnQnOiAnbGVmdCcsXG4gICdBcnJvd1VwJzogJ3VwJyxcbiAgJ0Fycm93UmlnaHQnOiAncmlnaHQnLFxuICAnQXJyb3dEb3duJzogJ2Rvd24nXG59O1xuXG4vKipcbiAqIENhbGwgdGhlIGNhbGxiYWNrIGhhbmRsZXIgb2YgYW4gZXZlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldnRcbiAqL1xuZnVuY3Rpb24gY2FsbChjYWxsYmFjayA9IG5vb3AsIGV2dCkge1xuICBpZiAoY2FsbGJhY2suX3BkKSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgY2FsbGJhY2soZXZ0KTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgZnVuY3Rpb24gdGhhdCBjb3JyZXNwb25kcyB0byBhIGtleWJvYXJkIGtleS5cbiAqXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2dFxuICovXG5mdW5jdGlvbiBrZXlkb3duRXZlbnRIYW5kbGVyKGV2dCkge1xuICBsZXQga2V5ID0ga2V5TWFwW2V2dC5jb2RlXTtcbiAgbGV0IGNhbGxiYWNrID0ga2V5ZG93bkNhbGxiYWNrc1trZXldO1xuICBwcmVzc2VkS2V5c1trZXldID0gdHJ1ZTtcbiAgY2FsbChjYWxsYmFjaywgZXZ0KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHJlbGVhc2VkIGtleSB0byBub3QgYmVpbmcgcHJlc3NlZC5cbiAqXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2dFxuICovXG5mdW5jdGlvbiBrZXl1cEV2ZW50SGFuZGxlcihldnQpIHtcbiAgbGV0IGtleSA9IGtleU1hcFtldnQuY29kZV07XG4gIGxldCBjYWxsYmFjayA9IGtleXVwQ2FsbGJhY2tzW2tleV07XG4gIHByZXNzZWRLZXlzW2tleV0gPSBmYWxzZTtcbiAgY2FsbChjYWxsYmFjaywgZXZ0KTtcbn1cblxuLyoqXG4gKiBSZXNldCBwcmVzc2VkIGtleXMuXG4gKi9cbmZ1bmN0aW9uIGJsdXJFdmVudEhhbmRsZXIkMSgpIHtcbiAgcHJlc3NlZEtleXMgPSB7fTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGtleWJvYXJkIGV2ZW50IGxpc3RlbmVycy4gVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdXNpbmcgb3RoZXIga2V5Ym9hcmQgZnVuY3Rpb25zLlxuICogQGZ1bmN0aW9uIGluaXRLZXlzXG4gKi9cbmZ1bmN0aW9uIGluaXRLZXlzKCkge1xuICBsZXQgaTtcblxuICAvLyBhbHBoYSBrZXlzXG4gIC8vIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQzMDk1NzcyLzIxMjQyNTRcbiAgZm9yIChpID0gMDsgaSA8IDI2OyBpKyspIHtcbiAgICAvLyByb2xsdXBqcyBjb25zaWRlcnMgdGhpcyBhIHNpZGUtZWZmZWN0IChmb3Igbm93KSwgc28gd2UnbGwgZG8gaXQgaW4gdGhlXG4gICAgLy8gaW5pdEtleXMgZnVuY3Rpb25cbiAgICBrZXlNYXBbaSArIDY1XSA9IGtleU1hcFsnS2V5JyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDY1KV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyA5Nyk7XG4gIH1cblxuICAvLyBudW1lcmljIGtleXNcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICBrZXlNYXBbNDgraV0gPSBrZXlNYXBbJ0RpZ2l0JytpXSA9ICcnK2k7XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd25FdmVudEhhbmRsZXIpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXl1cEV2ZW50SGFuZGxlcik7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgYmx1ckV2ZW50SGFuZGxlciQxKTtcbn1cblxuLyoqXG4gKiBCaW5kIGEgc2V0IG9mIGtleXMgdGhhdCB3aWxsIGNhbGwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhleSBhcmUgcHJlc3NlZC4gVGFrZXMgYSBzaW5nbGUga2V5IG9yIGFuIGFycmF5IG9mIGtleXMuIElzIHBhc3NlZCB0aGUgb3JpZ2luYWwgS2V5Ym9hcmRFdmVudCBhcyBhIHBhcmFtZXRlci5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdCBhY3Rpb24gd2lsbCBiZSBwcmV2ZW50ZWQgZm9yIGFueSBib3VuZCBrZXkuIFRvIG5vdCBkbyB0aGlzLCBwYXNzIHRoZSBgcHJldmVudERlZmF1bHRgIG9wdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgaW5pdEtleXMsIGJpbmRLZXlzIH0gZnJvbSAna29udHJhJztcbiAqXG4gKiBpbml0S2V5cygpO1xuICpcbiAqIGJpbmRLZXlzKCdwJywgZnVuY3Rpb24oZSkge1xuICogICAvLyBwYXVzZSB0aGUgZ2FtZVxuICogfSwgJ2tleXVwJyk7XG4gKiBiaW5kS2V5cyhbJ2VudGVyJywgJ3NwYWNlJ10sIGZ1bmN0aW9uKGUpIHtcbiAqICAgLy8gZmlyZSBndW5cbiAqIH0pO1xuICogYGBgXG4gKiBAZnVuY3Rpb24gYmluZEtleXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0ga2V5cyAtIEtleSBvciBrZXlzIHRvIGJpbmQuXG4gKiBAcGFyYW0geyhldnQ6IEtleWJvYXJkRXZlbnQpID0+IHZvaWR9IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBrZXkgaXMgcHJlc3NlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBCaW5kIG9wdGlvbnMuXG4gKiBAcGFyYW0geydrZXlkb3duJ3wna2V5dXAnfSBbb3B0aW9ucy5oYW5kbGVyPWtleWRvd25dIC0gV2hldGhlciB0byBiaW5kIHRvIGtleWRvd24gb3Iga2V5dXAgZXZlbnRzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5wcmV2ZW50RGVmYXVsdD10cnVlXSAtIENhbGwgYGV2ZW50LiBwcmV2ZW50RGVmYXVsdCgpYCB3aGVuIHRoZSBrZXkgaXMgYWN0aXZhdGVkLlxuICovXG5mdW5jdGlvbiBiaW5kS2V5cyhrZXlzLCBjYWxsYmFjaywge1xuICBoYW5kbGVyID0gJ2tleWRvd24nLFxuICBwcmV2ZW50RGVmYXVsdCA9IHRydWVcbn0gPSB7fSkge1xuICBjb25zdCBjYWxsYmFja3MgPSBoYW5kbGVyID09ICdrZXlkb3duJyA/IGtleWRvd25DYWxsYmFja3MgOiBrZXl1cENhbGxiYWNrcztcbiAgLy8gcGQgPSBwcmV2ZW50RGVmYXVsdFxuICBjYWxsYmFjay5fcGQgPSBwcmV2ZW50RGVmYXVsdDtcbiAgLy8gc21hbGxlciB0aGFuIGRvaW5nIGBBcnJheS5pc0FycmF5KGtleXMpID8ga2V5cyA6IFtrZXlzXWBcbiAgW10uY29uY2F0KGtleXMpLm1hcChrZXkgPT4gY2FsbGJhY2tzW2tleV0gPSBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgYSBib3VuZCBzZXQgb2Yga2V5cy4gVGFrZXMgYSBzaW5nbGUga2V5IG9yIGFuIGFycmF5IG9mIGtleXMuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IHVuYmluZEtleXMgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIHVuYmluZEtleXMoJ2xlZnQnKTtcbiAqIHVuYmluZEtleXMoWydlbnRlcicsICdzcGFjZSddKTtcbiAqIGBgYFxuICogQGZ1bmN0aW9uIHVuYmluZEtleXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0ga2V5cyAtIEtleSBvciBrZXlzIHRvIHVuYmluZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBVbmJpbmQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7J2tleWRvd24nfCdrZXl1cCd9IFtvcHRpb25zLmhhbmRsZXI9a2V5ZG93bl0gLSBXaGV0aGVyIHRvIHVuYmluZCBmcm9tIGtleWRvd24gb3Iga2V5dXAgZXZlbnRzLlxuICovXG5mdW5jdGlvbiB1bmJpbmRLZXlzKGtleXMsIHtcbiAgaGFuZGxlciA9ICdrZXlkb3duJ1xufSA9IHt9KSB7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGhhbmRsZXIgPT0gJ2tleWRvd24nID8ga2V5ZG93bkNhbGxiYWNrcyA6IGtleXVwQ2FsbGJhY2tzO1xuICAvLyAwIGlzIHRoZSBzbWFsbGVzdCBmYWxzeSB2YWx1ZVxuICBbXS5jb25jYXQoa2V5cykubWFwKGtleSA9PiBjYWxsYmFja3Nba2V5XSA9IDApO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEga2V5IGlzIGN1cnJlbnRseSBwcmVzc2VkLiBVc2UgZHVyaW5nIGFuIGB1cGRhdGUoKWAgZnVuY3Rpb24gdG8gcGVyZm9ybSBhY3Rpb25zIGVhY2ggZnJhbWUuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IFNwcml0ZSwgaW5pdEtleXMsIGtleVByZXNzZWQgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIGluaXRLZXlzKCk7XG4gKlxuICogbGV0IHNwcml0ZSA9IFNwcml0ZSh7XG4gKiAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gKiAgICAgaWYgKGtleVByZXNzZWQoJ2xlZnQnKSl7XG4gKiAgICAgICAvLyBsZWZ0IGFycm93IHByZXNzZWRcbiAqICAgICB9XG4gKiAgICAgZWxzZSBpZiAoa2V5UHJlc3NlZCgncmlnaHQnKSkge1xuICogICAgICAgLy8gcmlnaHQgYXJyb3cgcHJlc3NlZFxuICogICAgIH1cbiAqXG4gKiAgICAgaWYgKGtleVByZXNzZWQoJ3VwJykpIHtcbiAqICAgICAgIC8vIHVwIGFycm93IHByZXNzZWRcbiAqICAgICB9XG4gKiAgICAgZWxzZSBpZiAoa2V5UHJlc3NlZCgnZG93bicpKSB7XG4gKiAgICAgICAvLyBkb3duIGFycm93IHByZXNzZWRcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKiBAZnVuY3Rpb24ga2V5UHJlc3NlZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBLZXkgdG8gY2hlY2sgZm9yIHByZXNzZWQgc3RhdGUuXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUga2V5IGlzIHByZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBrZXlQcmVzc2VkKGtleSkge1xuICByZXR1cm4gISFwcmVzc2VkS2V5c1trZXldO1xufVxuXG4vKipcbiAqIEEgcGx1Z2luIHN5c3RlbSBiYXNlZCBvbiB0aGUgW2ludGVyY2VwdG9yIHBhdHRlcm5dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVyY2VwdG9yX3BhdHRlcm4pLCBkZXNpZ25lZCB0byBzaGFyZSByZXVzYWJsZSBjb2RlIHN1Y2ggYXMgbW9yZSBhZHZhbmNlIGNvbGxpc2lvbiBkZXRlY3Rpb24gb3IgYSAyRCBwaHlzaWNzIGVuZ2luZS5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgcmVnaXN0ZXJQbHVnaW4sIFNwcml0ZSB9IGZyb20gJ2tvbnRyYSc7XG4gKiBpbXBvcnQgbG9nZ2luZ1BsdWdpbiBmcm9tICdwYXRoL3RvL3BsdWdpbi9jb2RlLmpzJ1xuICpcbiAqIC8vIHJlZ2lzdGVyIGEgcGx1Z2luIHRoYXQgYWRkcyBsb2dnaW5nIHRvIGFsbCBTcHJpdGVzXG4gKiByZWdpc3RlclBsdWdpbihTcHJpdGUsIGxvZ2dpbmdQbHVnaW4pO1xuICogYGBgXG4gKiBAc2VjdGlvbk5hbWUgUGx1Z2luXG4gKi9cblxuLyoqXG4gKiBAZG9jcyBkb2NzL2FwaV9kb2NzL3BsdWdpbi5qc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSBrb250cmEgb2JqZWN0IG1ldGhvZCBuYW1lIGZyb20gdGhlIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZSAtIEJlZm9yZS9BZnRlciBmdW5jdGlvbiBuYW1lXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0TWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgbGV0IG1ldGhvZFRpdGxlID0gbWV0aG9kTmFtZS5zdWJzdHIoIG1ldGhvZE5hbWUuc2VhcmNoKC9bQS1aXS8pICk7XG4gIHJldHVybiBtZXRob2RUaXRsZVswXS50b0xvd2VyQ2FzZSgpICsgbWV0aG9kVGl0bGUuc3Vic3RyKDEpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvci5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uW119IGludGVyY2VwdG9ycyAtIEJlZm9yZS9BZnRlciBpbnRlcmNlcHRvciBsaXN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIEludGVyY2VwdG9yIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUludGVyY2VwdG9yKGludGVyY2VwdG9ycywgZm4pIHtcbiAgbGV0IGluZGV4ID0gaW50ZXJjZXB0b3JzLmluZGV4T2YoZm4pO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgaW50ZXJjZXB0b3JzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhIHBsdWdpbiB0byBydW4gYSBzZXQgb2YgZnVuY3Rpb25zIGJlZm9yZSBvciBhZnRlciB0aGUgS29udHJhIG9iamVjdCBmdW5jdGlvbnMuXG4gKiBAZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ga29udHJhT2JqIC0gS29udHJhIG9iamVjdCB0byBhdHRhY2ggdGhlIHBsdWdpbiB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5PYmogLSBQbHVnaW4gb2JqZWN0IHdpdGggYmVmb3JlIGFuZCBhZnRlciBpbnRlcmNlcHQgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiByZWdpc3RlclBsdWdpbihrb250cmFPYmosIHBsdWdpbk9iaikge1xuICBsZXQgb2JqZWN0UHJvdG8gPSBrb250cmFPYmoucHJvdG90eXBlO1xuXG4gIGlmICghb2JqZWN0UHJvdG8pIHJldHVybjtcblxuICAvLyBjcmVhdGUgaW50ZXJjZXB0b3IgbGlzdCBhbmQgZnVuY3Rpb25zXG4gIGlmICghb2JqZWN0UHJvdG8uX2luYykge1xuICAgIG9iamVjdFByb3RvLl9pbmMgPSB7fTtcbiAgICBvYmplY3RQcm90by5fYkluYyA9IGZ1bmN0aW9uIGJlZm9yZVBsdWdpbnMoY29udGV4dCwgbWV0aG9kLCAuLi5hcmdzKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5jW21ldGhvZF0uYmVmb3JlLnJlZHVjZSgoYWNjLCBmbikgPT4ge1xuICAgICAgICBsZXQgbmV3QXJncyA9IGZuKGNvbnRleHQsIC4uLmFjYyk7XG4gICAgICAgIHJldHVybiBuZXdBcmdzID8gbmV3QXJncyA6IGFjYztcbiAgICAgIH0sIGFyZ3MpO1xuICAgIH07XG4gICAgb2JqZWN0UHJvdG8uX2FJbmMgPSBmdW5jdGlvbiBhZnRlclBsdWdpbnMoY29udGV4dCwgbWV0aG9kLCByZXN1bHQsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbmNbbWV0aG9kXS5hZnRlci5yZWR1Y2UoKGFjYywgZm4pID0+IHtcbiAgICAgICAgbGV0IG5ld1Jlc3VsdCA9IGZuKGNvbnRleHQsIGFjYywgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiBuZXdSZXN1bHQgPyBuZXdSZXN1bHQgOiBhY2M7XG4gICAgICB9LCByZXN1bHQpO1xuICAgIH07XG4gIH1cblxuICAvLyBhZGQgcGx1Z2luIHRvIGludGVyY2VwdG9yc1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwbHVnaW5PYmopLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgbGV0IG1ldGhvZCA9IGdldE1ldGhvZChtZXRob2ROYW1lKTtcblxuICAgIGlmICghb2JqZWN0UHJvdG9bbWV0aG9kXSkgcmV0dXJuO1xuXG4gICAgLy8gb3ZlcnJpZGUgb3JpZ2luYWwgbWV0aG9kXG4gICAgaWYgKCFvYmplY3RQcm90b1snX28nICsgbWV0aG9kXSkge1xuICAgICAgb2JqZWN0UHJvdG9bJ19vJyArIG1ldGhvZF0gPSBvYmplY3RQcm90b1ttZXRob2RdO1xuXG4gICAgICBvYmplY3RQcm90b1ttZXRob2RdID0gZnVuY3Rpb24gaW50ZXJjZXB0ZWRGbiguLi5hcmdzKSB7XG5cbiAgICAgICAgLy8gY2FsbCBiZWZvcmUgaW50ZXJjZXB0b3JzXG4gICAgICAgIGxldCBhbHRlcmVkQXJncyA9IHRoaXMuX2JJbmModGhpcywgbWV0aG9kLCAuLi5hcmdzKTtcblxuICAgICAgICBsZXQgcmVzdWx0ID0gb2JqZWN0UHJvdG9bJ19vJyArIG1ldGhvZF0uY2FsbCh0aGlzLCAuLi5hbHRlcmVkQXJncyk7XG5cbiAgICAgICAgLy8gY2FsbCBhZnRlciBpbnRlcmNlcHRvcnNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FJbmModGhpcywgbWV0aG9kLCByZXN1bHQsIC4uLmFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgaW50ZXJjZXB0b3JzIGZvciB0aGUgbWV0aG9kXG4gICAgaWYgKCFvYmplY3RQcm90by5faW5jW21ldGhvZF0pIHtcbiAgICAgIG9iamVjdFByb3RvLl9pbmNbbWV0aG9kXSA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgYWZ0ZXI6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChtZXRob2ROYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpKSB7XG4gICAgICBvYmplY3RQcm90by5faW5jW21ldGhvZF0uYmVmb3JlLnB1c2gocGx1Z2luT2JqW21ldGhvZE5hbWVdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0aG9kTmFtZS5zdGFydHNXaXRoKCdhZnRlcicpKSB7XG4gICAgICBvYmplY3RQcm90by5faW5jW21ldGhvZF0uYWZ0ZXIucHVzaChwbHVnaW5PYmpbbWV0aG9kTmFtZV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVW5yZWdpc3RlciBhIHBsdWdpbiBmcm9tIGEgS29udHJhIG9iamVjdC5cbiAqIEBmdW5jdGlvbiB1bnJlZ2lzdGVyUGx1Z2luXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtvbnRyYU9iaiAtIEtvbnRyYSBvYmplY3QgdG8gZGV0YWNoIHBsdWdpbiBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbk9iaiAtIFRoZSBwbHVnaW4gb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBkdXJpbmcgcmVnaXN0cmF0aW9uLlxuICovXG5mdW5jdGlvbiB1bnJlZ2lzdGVyUGx1Z2luKGtvbnRyYU9iaiwgcGx1Z2luT2JqKSB7XG4gIGxldCBvYmplY3RQcm90byA9IGtvbnRyYU9iai5wcm90b3R5cGU7XG5cbiAgaWYgKCFvYmplY3RQcm90byB8fCAhb2JqZWN0UHJvdG8uX2luYykgcmV0dXJuO1xuXG4gIC8vIHJlbW92ZSBwbHVnaW4gZnJvbSBpbnRlcmNlcHRvcnNcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGx1Z2luT2JqKS5mb3JFYWNoKG1ldGhvZE5hbWUgPT4ge1xuICAgIGxldCBtZXRob2QgPSBnZXRNZXRob2QobWV0aG9kTmFtZSk7XG5cbiAgICBpZiAobWV0aG9kTmFtZS5zdGFydHNXaXRoKCdiZWZvcmUnKSkge1xuICAgICAgcmVtb3ZlSW50ZXJjZXB0b3Iob2JqZWN0UHJvdG8uX2luY1ttZXRob2RdLmJlZm9yZSwgcGx1Z2luT2JqW21ldGhvZE5hbWVdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0aG9kTmFtZS5zdGFydHNXaXRoKCdhZnRlcicpKSB7XG4gICAgICByZW1vdmVJbnRlcmNlcHRvcihvYmplY3RQcm90by5faW5jW21ldGhvZF0uYWZ0ZXIsIHBsdWdpbk9ialttZXRob2ROYW1lXSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTYWZlbHkgZXh0ZW5kIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGEgS29udHJhIG9iamVjdC4gQW55IHByb3BlcnRpZXMgdGhhdCBhbHJlYWR5IGV4aXN0IG9uIHRoZSBLb250cmEgb2JqZWN0IHdpbGwgbm90IGJlIGFkZGVkLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBleHRlbmRPYmplY3QsIFZlY3RvciB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogLy8gYWRkIGEgc3VidHJhY3QgZnVuY3Rpb24gdG8gYWxsIFZlY3RvcnNcbiAqIGV4dGVuZE9iamVjdChWZWN0b3IsIHtcbiAqICAgc3VidHJhY3QodmVjKSB7XG4gKiAgICAgcmV0dXJuIFZlY3Rvcih0aGlzLnggLSB2ZWMueCwgdGhpcy55IC0gdmVjLnkpO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICogQGZ1bmN0aW9uIGV4dGVuZE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrb250cmFPYmogLSBLb250cmEgb2JqZWN0IHRvIGV4dGVuZFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBQcm9wZXJ0aWVzIHRvIGFkZC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kT2JqZWN0KGtvbnRyYU9iaiwgcHJvcGVydGllcykge1xuICBsZXQgb2JqZWN0UHJvdG8gPSBrb250cmFPYmoucHJvdG90eXBlO1xuXG4gIGlmICghb2JqZWN0UHJvdG8pIHJldHVybjtcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKS5mb3JFYWNoKHByb3AgPT4ge1xuICAgIGlmICghb2JqZWN0UHJvdG9bcHJvcF0pIHtcbiAgICAgIG9iamVjdFByb3RvW3Byb3BdID0gcHJvcGVydGllc1twcm9wXTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEEgZmFzdCBhbmQgbWVtb3J5IGVmZmljaWVudCBbb2JqZWN0IHBvb2xdKGh0dHBzOi8vZ2FtZXByb2dyYW1taW5ncGF0dGVybnMuY29tL29iamVjdC1wb29sLmh0bWwpIGZvciBzcHJpdGUgcmV1c2UuIFBlcmZlY3QgZm9yIHBhcnRpY2xlIHN5c3RlbXMgb3IgU0hVTVBzLiBUaGUgcG9vbCBzdGFydHMgb3V0IHdpdGgganVzdCBvbmUgb2JqZWN0LCBidXQgd2lsbCBncm93IGluIHNpemUgdG8gYWNjb21tb2RhdGUgYXMgbWFueSBvYmplY3RzIGFzIGFyZSBuZWVkZWQuXG4gKlxuICogPGNhbnZhcyB3aWR0aD1cIjYwMFwiIGhlaWdodD1cIjIwMFwiIGlkPVwicG9vbC1leGFtcGxlXCI+PC9jYW52YXM+XG4gKiA8c2NyaXB0IHNyYz1cImFzc2V0cy9qcy9wb29sLmpzXCI+PC9zY3JpcHQ+XG4gKiBAY2xhc3MgUG9vbFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gUHJvcGVydGllcyBvZiB0aGUgcG9vbC5cbiAqIEBwYXJhbSB7KCkgPT4ge3VwZGF0ZTogKGR0PzogbnVtYmVyKSA9PiB2b2lkLCByZW5kZXI6IEZ1bmN0aW9uLCBpbml0OiAocHJvcGVydGllcz86IG9iamVjdCkgPT4gdm9pZCwgaXNBbGl2ZTogKCkgPT4gYm9vbGVhbn19IHByb3BlcnRpZXMuY3JlYXRlIC0gRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbmV3IG9iamVjdCB0byBiZSBhZGRlZCB0byB0aGUgcG9vbCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGFsaXZlIG9iamVjdHMuXG4gKiBAcGFyYW0ge051bWJlcn0gW3Byb3BlcnRpZXMubWF4U2l6ZT0xMDI0XSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBvYmplY3RzIGFsbG93ZWQgaW4gdGhlIHBvb2wuIFRoZSBwb29sIHdpbGwgbmV2ZXIgZ3JvdyBiZXlvbmQgdGhpcyBzaXplLlxuICovXG5jbGFzcyBQb29sIHtcbiAgLyoqXG4gICAqIEBkb2NzIGRvY3MvYXBpX2RvY3MvcG9vbC5qc1xuICAgKi9cblxuICBjb25zdHJ1Y3Rvcih7Y3JlYXRlLCBtYXhTaXplID0gMTAyNH0gPSB7fSkge1xuXG4gICAgLy8gY2hlY2sgZm9yIHRoZSBjb3JyZWN0IHN0cnVjdHVyZSBvZiB0aGUgb2JqZWN0cyBhZGRlZCB0byBwb29scyBzbyB3ZSBrbm93IHRoYXQgdGhlXG4gICAgLy8gcmVzdCBvZiB0aGUgcG9vbCBjb2RlIHdpbGwgd29yayB3aXRob3V0IGVycm9yc1xuICAgIC8vIEBpZmRlZiBERUJVR1xuICAgIGxldCBvYmo7XG4gICAgaWYgKCFjcmVhdGUgfHxcbiAgICAgICAgKCAhKCBvYmogPSBjcmVhdGUoKSApIHx8XG4gICAgICAgICAgISggb2JqLnVwZGF0ZSAmJiBvYmouaW5pdCAmJlxuICAgICAgICAgICAgIG9iai5pc0FsaXZlICYmIG9iai5yZW5kZXIpXG4gICAgICAgKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ011c3QgcHJvdmlkZSBjcmVhdGUoKSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGluaXQoKSwgdXBkYXRlKCksIHJlbmRlcigpLCBhbmQgaXNBbGl2ZSgpIGZ1bmN0aW9ucycpO1xuICAgIH1cbiAgICAvLyBAZW5kaWZcblxuICAgIC8vIGMgPSBjcmVhdGVcbiAgICB0aGlzLl9jID0gY3JlYXRlO1xuXG4gICAgLyoqXG4gICAgICogQWxsIG9iamVjdHMgY3VycmVudGx5IGluIHRoZSBwb29sLCBib3RoIGFsaXZlIGFuZCBub3QgYWxpdmUuXG4gICAgICogQG1lbWJlcm9mIFBvb2xcbiAgICAgKiBAcHJvcGVydHkge09iamVjdFtdfSBvYmplY3RzXG4gICAgICovXG4gICAgdGhpcy5vYmplY3RzID0gW2NyZWF0ZSgpXTsgLy8gc3RhcnQgdGhlIHBvb2wgd2l0aCBhbiBvYmplY3RcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgYWxpdmUgb2JqZWN0cy5cbiAgICAgKiBAbWVtYmVyb2YgUG9vbFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzaXplXG4gICAgICovXG4gICAgdGhpcy5zaXplID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBvYmplY3RzIGFsbG93ZWQgaW4gdGhlIHBvb2wuIFRoZSBwb29sIHdpbGwgbmV2ZXIgZ3JvdyBiZXlvbmQgdGhpcyBzaXplLlxuICAgICAqIEBtZW1iZXJvZiBQb29sXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1heFNpemVcbiAgICAgKi9cbiAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbmQgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBwb29sLiBUaGUgcHJvcGVydGllcyBwYXJhbWV0ZXIgd2lsbCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIG9iamVjdHMgYGluaXQoKWAgZnVuY3Rpb24uIElmIHlvdSdyZSB1c2luZyBhIFtTcHJpdGVdKGFwaS9zcHJpdGUpLCB5b3Ugc2hvdWxkIGFsc28gcGFzcyB0aGUgYHR0bGAgcHJvcGVydHkgdG8gZGVzaWduYXRlIGhvdyBtYW55IGZyYW1lcyB5b3Ugd2FudCB0aGUgb2JqZWN0IHRvIGJlIGFsaXZlIGZvci5cbiAgICpcbiAgICogSWYgeW91IHdhbnQgdG8gY29udHJvbCB3aGVuIHRoZSBzcHJpdGUgaXMgcmVhZHkgZm9yIHJldXNlLCBwYXNzIGBJbmZpbml0eWAgZm9yIGB0dGxgLiBZb3UnbGwgbmVlZCB0byBzZXQgdGhlIHNwcml0ZXMgYHR0bGAgdG8gYDBgIHdoZW4geW91J3JlIHJlYWR5IGZvciB0aGUgc3ByaXRlIHRvIGJlIHJldXNlZC5cbiAgICpcbiAgICogYGBganNcbiAgICogLy8gZXhjbHVkZS10YWJsaXN0XG4gICAqIGxldCBzcHJpdGUgPSBwb29sLmdldCh7XG4gICAqICAgLy8gdGhlIG9iamVjdCB3aWxsIGdldCB0aGVzZSBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICogICB4OiAxMDAsXG4gICAqICAgeTogMjAwLFxuICAgKiAgIHdpZHRoOiAyMCxcbiAgICogICBoZWlnaHQ6IDQwLFxuICAgKiAgIGNvbG9yOiAncmVkJyxcbiAgICpcbiAgICogICAvLyBwYXNzIEluZmluaXR5IGZvciB0dGwgdG8gcHJldmVudCB0aGUgb2JqZWN0IGZyb20gYmVpbmcgcmV1c2VkXG4gICAqICAgLy8gdW50aWwgeW91IHNldCBpdCBiYWNrIHRvIDBcbiAgICogICB0dGw6IEluZmluaXR5XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQG1lbWJlcm9mIFBvb2xcbiAgICogQGZ1bmN0aW9uIGdldFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIC0gUHJvcGVydGllcyB0byBwYXNzIHRvIHRoZSBvYmplY3RzIGBpbml0KClgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3bHkgaW5pdGlhbGl6ZWQgb2JqZWN0LlxuICAgKi9cbiAgZ2V0KHByb3BlcnRpZXMgPSB7fSkge1xuICAgIC8vIHRoZSBwb29sIGlzIG91dCBvZiBvYmplY3RzIGlmIHRoZSBmaXJzdCBvYmplY3QgaXMgaW4gdXNlIGFuZCBpdCBjYW4ndCBncm93XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5vYmplY3RzLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGRvdWJsZSB0aGUgc2l6ZSBvZiB0aGUgYXJyYXkgYnkgYWRkaW5nIHR3aWNlIGFzIG1hbnkgbmV3IG9iamVjdHMgdG8gdGhlIGVuZFxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplICYmIHRoaXMub2JqZWN0cy5sZW5ndGggPCB0aGlzLm1heFNpemU7IGkrKykge1xuICAgICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKHRoaXMuX2MoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYXZlIG9mZiBmaXJzdCBvYmplY3QgaW4gcG9vbCB0byByZWFzc2lnbiB0byBsYXN0IG9iamVjdCBhZnRlciB1bnNoaWZ0XG4gICAgbGV0IG9iaiA9IHRoaXMub2JqZWN0c1t0aGlzLnNpemVdO1xuICAgIHRoaXMuc2l6ZSsrO1xuICAgIG9iai5pbml0KHByb3BlcnRpZXMpO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgYWxpdmUgb2JqZWN0cy4gVXNlZnVsIGlmIHlvdSBuZWVkIHRvIGRvIHNwZWNpYWwgcHJvY2Vzc2luZyBvbiBhbGwgYWxpdmUgb2JqZWN0cyBvdXRzaWRlIG9mIHRoZSBwb29sLCBzdWNoIGFzIHRvIGFkZCBhbGwgYWxpdmUgb2JqZWN0cyB0byBhIFtRdWFkdHJlZV0oYXBpL3F1YWR0cmVlKS5cbiAgICogQG1lbWJlcm9mIFBvb2xcbiAgICogQGZ1bmN0aW9uIGdldEFsaXZlT2JqZWN0c1xuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0W119IEFuIEFycmF5IG9mIGFsbCBhbGl2ZSBvYmplY3RzLlxuICAgKi9cbiAgZ2V0QWxpdmVPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdHMuc2xpY2UoMCwgdGhpcy5zaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgb2JqZWN0IHBvb2wuIFJlbW92ZXMgYWxsIG9iamVjdHMgZnJvbSB0aGUgcG9vbCBhbmQgcmVzZXRzIGl0cyBbc2l6ZV0oYXBpL3Bvb2wjc2l6ZSkgdG8gMS5cbiAgICogQG1lbWJlcm9mIFBvb2xcbiAgICogQGZ1bmN0aW9uIGNsZWFyXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLnNpemUgPSB0aGlzLm9iamVjdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLm9iamVjdHMucHVzaCh0aGlzLl9jKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbGwgYWxpdmUgb2JqZWN0cyBpbiB0aGUgcG9vbCBieSBjYWxsaW5nIHRoZSBvYmplY3RzIGB1cGRhdGUoKWAgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gYWxzbyBtYW5hZ2VzIHdoZW4gZWFjaCBvYmplY3Qgc2hvdWxkIGJlIHJlY3ljbGVkLCBzbyBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSBkbyBub3QgY2FsbCB0aGUgb2JqZWN0cyBgdXBkYXRlKClgIGZ1bmN0aW9uIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICogQG1lbWJlcm9mIFBvb2xcbiAgICogQGZ1bmN0aW9uIHVwZGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R0XSAtIFRpbWUgc2luY2UgbGFzdCB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGUoZHQpIHtcbiAgICBsZXQgb2JqO1xuICAgIGxldCBkb1NvcnQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zaXplOyBpLS07ICkge1xuICAgICAgb2JqID0gdGhpcy5vYmplY3RzW2ldO1xuXG4gICAgICBvYmoudXBkYXRlKGR0KTtcblxuICAgICAgaWYgKCFvYmouaXNBbGl2ZSgpKSB7XG4gICAgICAgIGRvU29ydCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzb3J0IGFsbCBkZWFkIGVsZW1lbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHBvb2xcbiAgICBpZiAoZG9Tb3J0KSB7XG4gICAgICB0aGlzLm9iamVjdHMuc29ydCgoYSwgYikgPT4gYi5pc0FsaXZlKCkgLSBhLmlzQWxpdmUoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhbGwgYWxpdmUgb2JqZWN0cyBpbiB0aGUgcG9vbCBieSBjYWxsaW5nIHRoZSBvYmplY3RzIGByZW5kZXIoKWAgZnVuY3Rpb24uXG4gICAqIEBtZW1iZXJvZiBQb29sXG4gICAqIEBmdW5jdGlvbiByZW5kZXJcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zaXplOyBpLS07ICkge1xuICAgICAgdGhpcy5vYmplY3RzW2ldLnJlbmRlcigpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmYWN0b3J5JDcoKSB7XG4gIHJldHVybiBuZXcgUG9vbCguLi5hcmd1bWVudHMpO1xufVxuZmFjdG9yeSQ3LnByb3RvdHlwZSA9IFBvb2wucHJvdG90eXBlO1xuZmFjdG9yeSQ3LmNsYXNzID0gUG9vbDtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hpY2ggc3Vibm9kZXMgdGhlIG9iamVjdCBpbnRlcnNlY3RzIHdpdGhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gT2JqZWN0IHRvIGNoZWNrLlxuICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmRzIC0gQm91bmRzIG9mIHRoZSBxdWFkdHJlZS5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyW119IExpc3Qgb2YgYWxsIHN1Ym5vZGVzIG9iamVjdCBpbnRlcnNlY3RzLlxuICovXG5mdW5jdGlvbiBnZXRJbmRpY2VzKG9iamVjdCwgYm91bmRzKSB7XG4gIGxldCBpbmRpY2VzID0gW107XG5cbiAgbGV0IHZlcnRpY2FsTWlkcG9pbnQgPSBib3VuZHMueCArIGJvdW5kcy53aWR0aCAvIDI7XG4gIGxldCBob3Jpem9udGFsTWlkcG9pbnQgPSBib3VuZHMueSArIGJvdW5kcy5oZWlnaHQgLyAyO1xuXG4gIGxldCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGdldFdvcmxkUmVjdChvYmplY3QpO1xuXG4gIC8vIHNhdmUgb2ZmIHF1YWRyYW50IGNoZWNrcyBmb3IgcmV1c2VcbiAgbGV0IGludGVyc2VjdHNUb3BRdWFkcmFudHMgPSBvYmplY3QueSA8IGhvcml6b250YWxNaWRwb2ludDtcbiAgbGV0IGludGVyc2VjdHNCb3R0b21RdWFkcmFudHMgPSBvYmplY3QueSArIG9iamVjdC5oZWlnaHQgPj0gaG9yaXpvbnRhbE1pZHBvaW50O1xuXG4gIC8vIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggdGhlIGxlZnQgcXVhZHJhbnRzXG4gIGlmIChvYmplY3QueCA8IHZlcnRpY2FsTWlkcG9pbnQpIHtcbiAgICBpZiAoaW50ZXJzZWN0c1RvcFF1YWRyYW50cykgeyAgLy8gdG9wIGxlZnRcbiAgICAgIGluZGljZXMucHVzaCgwKTtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJzZWN0c0JvdHRvbVF1YWRyYW50cykgeyAgLy8gYm90dG9tIGxlZnRcbiAgICAgIGluZGljZXMucHVzaCgyKTtcbiAgICB9XG4gIH1cblxuICAvLyBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIHRoZSByaWdodCBxdWFkcmFudHNcbiAgaWYgKG9iamVjdC54ICsgb2JqZWN0LndpZHRoID49IHZlcnRpY2FsTWlkcG9pbnQpIHtcbiAgICBpZiAoaW50ZXJzZWN0c1RvcFF1YWRyYW50cykgeyAgLy8gdG9wIHJpZ2h0XG4gICAgICBpbmRpY2VzLnB1c2goMSk7XG4gICAgfVxuXG4gICAgaWYgKGludGVyc2VjdHNCb3R0b21RdWFkcmFudHMpIHsgIC8vIGJvdHRvbSByaWdodFxuICAgICAgaW5kaWNlcy5wdXNoKDMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRpY2VzO1xufVxuXG4vKlxuVGhlIHF1YWR0cmVlIGFjdHMgbGlrZSBhbiBvYmplY3QgcG9vbCBpbiB0aGF0IGl0IHdpbGwgY3JlYXRlIHN1Ym5vZGVzIGFzIG9iamVjdHMgYXJlIG5lZWRlZCBidXQgaXQgd29uJ3QgY2xlYW4gdXAgdGhlIHN1Ym5vZGVzIHdoZW4gaXQgY29sbGFwc2VzIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbi5cblxuVGhlIHF1YWRyYW50IGluZGljZXMgYXJlIG51bWJlcmVkIGFzIGZvbGxvd3MgKGZvbGxvd2luZyBhIHotb3JkZXIgY3VydmUpOlxuICAgICB8XG4gIDAgIHwgIDFcbiAtLS0tKy0tLS1cbiAgMiAgfCAgM1xuICAgICB8XG4qL1xuXG5cbi8qKlxuICogQSAyRCBbc3BhdGlhbCBwYXJ0aXRpb25pbmddKGh0dHBzOi8vZ2FtZXByb2dyYW1taW5ncGF0dGVybnMuY29tL3NwYXRpYWwtcGFydGl0aW9uLmh0bWwpIGRhdGEgc3RydWN0dXJlLiBVc2UgaXQgdG8gcXVpY2tseSBncm91cCBvYmplY3RzIGJ5IHRoZWlyIHBvc2l0aW9uIGZvciBmYXN0ZXIgYWNjZXNzIGFuZCBjb2xsaXNpb24gY2hlY2tpbmcuXG4gKlxuICogPGNhbnZhcyB3aWR0aD1cIjYwMFwiIGhlaWdodD1cIjIwMFwiIGlkPVwicXVhZHRyZWUtZXhhbXBsZVwiPjwvY2FudmFzPlxuICogPHNjcmlwdCBzcmM9XCJhc3NldHMvanMvcXVhZHRyZWUuanNcIj48L3NjcmlwdD5cbiAqIEBjbGFzcyBRdWFkdHJlZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gLSBQcm9wZXJ0aWVzIG9mIHRoZSBxdWFkdHJlZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvcGVydGllcy5tYXhEZXB0aD0zXSAtIE1heGltdW0gbm9kZSBkZXB0aCBvZiB0aGUgcXVhZHRyZWUuXG4gKiBAcGFyYW0ge051bWJlcn0gW3Byb3BlcnRpZXMubWF4T2JqZWN0cz0yNV0gLSBNYXhpbXVtIG51bWJlciBvZiBvYmplY3RzIGEgbm9kZSBjYW4gaGF2ZSBiZWZvcmUgc3BsaXR0aW5nLlxuICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXIsIHdpZHRoOiBOdW1iZXIsIGhlaWdodDogTnVtYmVyfX0gW3Byb3BlcnRpZXMuYm91bmRzXSAtIFRoZSAyRCBzcGFjZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkgdGhlIHF1YWR0cmVlIG9jY3VwaWVzLiBEZWZhdWx0cyB0byB0aGUgZW50aXJlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0LlxuICovXG5jbGFzcyBRdWFkdHJlZSB7XG4gIC8qKlxuICAgKiBAZG9jcyBkb2NzL2FwaV9kb2NzL3F1YWR0cmVlLmpzXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKHttYXhEZXB0aCA9IDMsIG1heE9iamVjdHMgPSAyNSwgYm91bmRzfSA9IHt9KSB7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIG5vZGUgZGVwdGggb2YgdGhlIHF1YWR0cmVlLlxuICAgICAqIEBtZW1iZXJvZiBRdWFkdHJlZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXhEZXB0aFxuICAgICAqL1xuICAgIHRoaXMubWF4RGVwdGggPSBtYXhEZXB0aDtcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIG9iamVjdHMgYSBub2RlIGNhbiBoYXZlIGJlZm9yZSBzcGxpdHRpbmcuXG4gICAgICogQG1lbWJlcm9mIFF1YWR0cmVlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1heE9iamVjdHNcbiAgICAgKi9cbiAgICB0aGlzLm1heE9iamVjdHMgPSBtYXhPYmplY3RzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIDJEIHNwYWNlICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB0aGUgcXVhZHRyZWUgb2NjdXBpZXMuXG4gICAgICogQG1lbWJlcm9mIFF1YWR0cmVlXG4gICAgICogQHByb3BlcnR5IHt7eDogTnVtYmVyLCB5OiBOdW1iZXIsIHdpZHRoOiBOdW1iZXIsIGhlaWdodDogTnVtYmVyfX0gYm91bmRzXG4gICAgICovXG4gICAgbGV0IGNhbnZhcyA9IGdldENhbnZhcygpO1xuICAgIHRoaXMuYm91bmRzID0gYm91bmRzIHx8IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgIH07XG5cbiAgICAvLyBzaW5jZSB3ZSB3b24ndCBjbGVhbiB1cCBhbnkgc3Vibm9kZXMsIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBub2RlcyBhcmVcbiAgICAvLyBjdXJyZW50bHkgdGhlIGxlYWYgbm9kZSBzbyB3ZSBrbm93IHdoaWNoIG5vZGVzIHRvIGFkZCBvYmplY3RzIHRvXG4gICAgLy8gYiA9IGJyYW5jaCwgZCA9IGRlcHRoLCBvID0gb2JqZWN0cywgcyA9IHN1Ym5vZGVzLCBwID0gcGFyZW50XG4gICAgdGhpcy5fYiA9IGZhbHNlO1xuICAgIHRoaXMuX2QgPSAwO1xuICAgIHRoaXMuX28gPSBbXTtcbiAgICB0aGlzLl9zID0gW107XG4gICAgdGhpcy5fcCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgb2JqZWN0cyBmcm9tIHRoZSBxdWFkdHJlZS4gWW91IHNob3VsZCBjbGVhciB0aGUgcXVhZHRyZWUgZXZlcnkgZnJhbWUgYmVmb3JlIGFkZGluZyBhbGwgb2JqZWN0cyBiYWNrIGludG8gaXQuXG4gICAqIEBtZW1iZXJvZiBRdWFkdHJlZVxuICAgKiBAZnVuY3Rpb24gY2xlYXJcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3MubWFwKGZ1bmN0aW9uKHN1Ym5vZGUpIHtcbiAgICAgIHN1Ym5vZGUuY2xlYXIoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2IgPSBmYWxzZTtcbiAgICB0aGlzLl9vLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGFycmF5IG9mIGFsbCBvYmplY3RzIHRoYXQgYmVsb25nIHRvIHRoZSBzYW1lIG5vZGUgYXMgdGhlIHBhc3NlZCBpbiBvYmplY3QuXG4gICAqXG4gICAqICoqTm90ZToqKiBpZiB0aGUgcGFzc2VkIGluIG9iamVjdCBpcyBhbHNvIHBhcnQgb2YgdGhlIHF1YWR0cmVlLCBpdCB3aWxsIG5vdCBiZSByZXR1cm5lZCBpbiB0aGUgcmVzdWx0cy5cbiAgICpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgU3ByaXRlLCBRdWFkdHJlZSB9IGZyb20gJ2tvbnRyYSc7XG4gICAqXG4gICAqIGxldCBxdWFkdHJlZSA9IFF1YWR0cmVlKCk7XG4gICAqIGxldCBwbGF5ZXIgPSBTcHJpdGUoe1xuICAgKiAgIC8vIC4uLlxuICAgKiB9KTtcbiAgICogbGV0IGVuZW15MSA9IFNwcml0ZSh7XG4gICAqICAgLy8gLi4uXG4gICAqIH0pO1xuICAgKiBsZXQgZW5lbXkyID0gU3ByaXRlKHtcbiAgICogICAvLyAuLi5cbiAgICogfSk7XG4gICAqXG4gICAqIHF1YWR0cmVlLmFkZChwbGF5ZXIsIGVuZW15MSwgZW5lbXkyKTtcbiAgICogcXVhZHRyZWUuZ2V0KHBsYXllcik7ICAvLz0+IFtlbmVteTFdXG4gICAqIGBgYFxuICAgKiBAbWVtYmVyb2YgUXVhZHRyZWVcbiAgICogQGZ1bmN0aW9uIGdldFxuICAgKlxuICAgKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlciwgd2lkdGg6IE51bWJlciwgaGVpZ2h0OiBOdW1iZXJ9fSBvYmplY3QgLSBPYmplY3QgdG8gdXNlIGZvciBmaW5kaW5nIG90aGVyIG9iamVjdHMuIFRoZSBvYmplY3QgbXVzdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIGB4YCwgYHlgLCBgd2lkdGhgLCBhbmQgYGhlaWdodGAgc28gdGhhdCBpdHMgcG9zaXRpb24gaW4gdGhlIHF1YWR0cmVlIGNhbiBiZSBjYWxjdWxhdGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0W119IEEgbGlzdCBvZiBvYmplY3RzIGluIHRoZSBzYW1lIG5vZGUgYXMgdGhlIG9iamVjdCwgbm90IGluY2x1ZGluZyB0aGUgb2JqZWN0IGl0c2VsZi5cbiAgICovXG4gIGdldChvYmplY3QpIHtcbiAgICAvLyBzaW5jZSBhbiBvYmplY3QgY2FuIGJlbG9uZyB0byBtdWx0aXBsZSBub2RlcyB3ZSBzaG91bGQgbm90IGFkZCBpdCBtdWx0aXBsZSB0aW1lc1xuICAgIGxldCBvYmplY3RzID0gbmV3IFNldCgpO1xuXG4gICAgLy8gdHJhdmVyc2UgdGhlIHRyZWUgdW50aWwgd2UgZ2V0IHRvIGEgbGVhZiBub2RlXG4gICAgd2hpbGUgKHRoaXMuX3MubGVuZ3RoICYmIHRoaXMuX2IpIHtcbiAgICAgIGdldEluZGljZXMob2JqZWN0LCB0aGlzLmJvdW5kcykubWFwKGluZGV4ID0+IHtcbiAgICAgICAgdGhpcy5fc1tpbmRleF0uZ2V0KG9iamVjdCkubWFwKG9iaiA9PiBvYmplY3RzLmFkZChvYmopKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShvYmplY3RzKTtcbiAgICB9XG5cbiAgICAvLyBkb24ndCBhZGQgdGhlIG9iamVjdCB0byB0aGUgcmV0dXJuIGxpc3RcbiAgICByZXR1cm4gdGhpcy5fby5maWx0ZXIob2JqID0+IG9iaiAhPT0gb2JqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb2JqZWN0cyB0byB0aGUgcXVhZHRyZWUgYW5kIGdyb3VwIHRoZW0gYnkgdGhlaXIgcG9zaXRpb24uIENhbiB0YWtlIGEgc2luZ2xlIG9iamVjdCwgYSBsaXN0IG9mIG9iamVjdHMsIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyBRdWFkdHJlZSwgU3ByaXRlLCBQb29sLCBHYW1lTG9vcCB9IGZyb20gJ2tvbnRyYSc7XG4gICAqXG4gICAqIGxldCBxdWFkdHJlZSA9IFF1YWR0cmVlKCk7XG4gICAqIGxldCBidWxsZXRQb29sID0gUG9vbCh7XG4gICAqICAgY3JlYXRlOiBTcHJpdGVcbiAgICogfSk7XG4gICAqXG4gICAqIGxldCBwbGF5ZXIgPSBTcHJpdGUoe1xuICAgKiAgIC8vIC4uLlxuICAgKiB9KTtcbiAgICogbGV0IGVuZW15ID0gU3ByaXRlKHtcbiAgICogICAvLyAuLi5cbiAgICogfSk7XG4gICAqXG4gICAqIC8vIGNyZWF0ZSBzb21lIGJ1bGxldHNcbiAgICogZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgKiAgIGJ1bGxldFBvb2wuZ2V0KHtcbiAgICogICAgIC8vIC4uLlxuICAgKiAgIH0pO1xuICAgKiB9XG4gICAqXG4gICAqIGxldCBsb29wID0gR2FtZUxvb3Aoe1xuICAgKiAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAqICAgICBxdWFkdHJlZS5jbGVhcigpO1xuICAgKiAgICAgcXVhZHRyZWUuYWRkKHBsYXllciwgZW5lbXksIGJ1bGxldFBvb2wuZ2V0QWxpdmVPYmplY3RzKCkpO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBAbWVtYmVyb2YgUXVhZHRyZWVcbiAgICogQGZ1bmN0aW9uIGFkZFxuICAgKlxuICAgKiBAcGFyYW0gey4uLk9iamVjdFtdfSBvYmplY3RzIC0gT2JqZWN0cyB0byBhZGQgdG8gdGhlIHF1YWR0cmVlLlxuICAgKi9cbiAgYWRkKC4uLm9iamVjdHMpIHtcbiAgICBvYmplY3RzLm1hcChvYmplY3QgPT4ge1xuICAgICAgLy8gYWRkIGEgZ3JvdXAgb2Ygb2JqZWN0cyBzZXBhcmF0ZWx5XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHRoaXMuYWRkLmFwcGx5KHRoaXMsIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY3VycmVudCBub2RlIGhhcyBzdWJub2Rlcywgc28gd2UgbmVlZCB0byBhZGQgdGhpcyBvYmplY3QgaW50byBhIHN1Ym5vZGVcbiAgICAgIGlmICh0aGlzLl9iKSB7XG4gICAgICAgIHRoaXMuX2Eob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGlzIG5vZGUgaXMgYSBsZWFmIG5vZGUgc28gYWRkIHRoZSBvYmplY3QgdG8gaXRcbiAgICAgIHRoaXMuX28ucHVzaChvYmplY3QpO1xuXG4gICAgICAvLyBzcGxpdCB0aGUgbm9kZSBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgb2JqZWN0c1xuICAgICAgaWYgKHRoaXMuX28ubGVuZ3RoID4gdGhpcy5tYXhPYmplY3RzICYmIHRoaXMuX2QgPCB0aGlzLm1heERlcHRoKSB7XG4gICAgICAgIHRoaXMuX3NwKCk7XG5cbiAgICAgICAgLy8gbW92ZSBhbGwgb2JqZWN0cyB0byB0aGVpciBjb3JyZXNwb25kaW5nIHN1Ym5vZGVzXG4gICAgICAgIHRoaXMuX28ubWFwKG9iaiA9PiB0aGlzLl9hKG9iaikpO1xuICAgICAgICB0aGlzLl9vLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIG9iamVjdCB0byBhIHN1Ym5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBPYmplY3QgdG8gYWRkIGludG8gYSBzdWJub2RlXG4gICAqL1xuICBfYShvYmplY3QpIHtcbiAgICAvLyBhZGQgdGhlIG9iamVjdCB0byBhbGwgc3Vibm9kZXMgaXQgaW50ZXJzZWN0c1xuICAgIGdldEluZGljZXMob2JqZWN0LCB0aGlzLmJvdW5kcykubWFwKGluZGV4ID0+IHtcbiAgICAgIHRoaXMuX3NbaW5kZXhdLmFkZChvYmplY3QpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHRoZSBub2RlIGludG8gZm91ciBzdWJub2Rlcy5cbiAgICovXG4gIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2plZC8xNDBieXRlcy93aWtpL0J5dGUtc2F2aW5nLXRlY2huaXF1ZXMjdXNlLXBsYWNlaG9sZGVyLWFyZ3VtZW50cy1pbnN0ZWFkLW9mLXZhclxuICBfc3Aoc3ViV2lkdGgsIHN1YkhlaWdodCwgaSkge1xuICAgIHRoaXMuX2IgPSB0cnVlO1xuXG4gICAgLy8gb25seSBzcGxpdCBpZiB3ZSBoYXZlbid0IHNwbGl0IGJlZm9yZVxuICAgIGlmICh0aGlzLl9zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1YldpZHRoID0gdGhpcy5ib3VuZHMud2lkdGggLyAyIHwgMDtcbiAgICBzdWJIZWlnaHQgPSB0aGlzLmJvdW5kcy5oZWlnaHQgLyAyIHwgMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHRoaXMuX3NbaV0gPSBuZXcgUXVhZHRyZWUoe1xuICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICB4OiB0aGlzLmJvdW5kcy54ICsgKGkgJSAyID09PSAxID8gc3ViV2lkdGggOiAwKSwgIC8vIG5vZGVzIDEgYW5kIDNcbiAgICAgICAgICB5OiB0aGlzLmJvdW5kcy55ICsgKGkgPj0gMiA/IHN1YkhlaWdodCA6IDApLCAgICAgIC8vIG5vZGVzIDIgYW5kIDNcbiAgICAgICAgICB3aWR0aDogc3ViV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzdWJIZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgbWF4RGVwdGg6IHRoaXMubWF4RGVwdGgsXG4gICAgICAgIG1heE9iamVjdHM6IHRoaXMubWF4T2JqZWN0cyxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkID0gZGVwdGgsIHAgPSBwYXJlbnRcbiAgICAgIHRoaXMuX3NbaV0uX2QgPSB0aGlzLl9kKzE7XG4gICAgICAvKiBAaWZkZWYgVklTVUFMX0RFQlVHICovXG4gICAgICB0aGlzLl9zW2ldLl9wID0gdGhpcztcbiAgICAgIC8qIEBlbmRpZiAqL1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3IHRoZSBxdWFkdHJlZS4gVXNlZnVsIGZvciB2aXN1YWwgZGVidWdnaW5nLlxuICAgKi9cbiAgIC8qIEBpZmRlZiBWSVNVQUxfREVCVUcgKipcbiAgIHJlbmRlcigpIHtcbiAgICAgLy8gZG9uJ3QgZHJhdyBlbXB0eSBsZWFmIG5vZGVzLCBhbHdheXMgZHJhdyBicmFuY2ggbm9kZXMgYW5kIHRoZSBmaXJzdCBub2RlXG4gICAgIGlmICh0aGlzLl9vLmxlbmd0aCB8fCB0aGlzLl9kID09PSAwIHx8XG4gICAgICAgICAodGhpcy5fcCAmJiB0aGlzLl9wLl9iKSkge1xuXG4gICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCh0aGlzLmJvdW5kcy54LCB0aGlzLmJvdW5kcy55LCB0aGlzLmJvdW5kcy53aWR0aCwgdGhpcy5ib3VuZHMuaGVpZ2h0KTtcblxuICAgICAgIGlmICh0aGlzLl9zLmxlbmd0aCkge1xuICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgdGhpcy5fc1tpXS5yZW5kZXIoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1cbiAgIH1cbiAgIC8qIEBlbmRpZiAqL1xufVxuXG5mdW5jdGlvbiBmYWN0b3J5JDgoKSB7XG4gIHJldHVybiBuZXcgUXVhZHRyZWUoLi4uYXJndW1lbnRzKTtcbn1cbmZhY3RvcnkkOC5wcm90b3R5cGUgPSBRdWFkdHJlZS5wcm90b3R5cGU7XG5mYWN0b3J5JDguY2xhc3MgPSBRdWFkdHJlZTtcblxuZnVuY3Rpb24gZ2V0QWxsTm9kZXMob2JqZWN0KSB7XG4gIGxldCBub2RlcyA9IFtdO1xuXG4gIGlmIChvYmplY3QuX2RuKSB7XG4gICAgbm9kZXMucHVzaChvYmplY3QuX2RuKTtcbiAgfVxuICBlbHNlIGlmIChvYmplY3QuY2hpbGRyZW4pIHtcbiAgICBvYmplY3QuY2hpbGRyZW4ubWFwKGNoaWxkID0+IHtcbiAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGdldEFsbE5vZGVzKGNoaWxkKSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbm9kZXM7XG59XG5cbi8qKlxuICogQSBzY2VuZSBvYmplY3QgZm9yIG9yZ2FuaXppbmcgYSBncm91cCBvZiBvYmplY3RzIHRoYXQgd2lsbCB1cGRhdGUgYW5kIHJlbmRlciB0b2dldGhlci5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgU2NlbmUsIFNwcml0ZSB9IGZyb20gJ2tvbnRyYSc7XG4gKlxuICogc3ByaXRlID0gU3ByaXRlKHtcbiAqICAgeDogMTAwLFxuICogICB5OiAyMDAsXG4gKiAgIHdpZHRoOiAyMCxcbiAqICAgaGVpZ2h0OiA0MCxcbiAqICAgY29sb3I6ICdyZWQnXG4gKiB9KTtcbiAqXG4gKiBzY2VuZSA9IFNjZW5lKHtcbiAqICAgaWQ6ICdnYW1lJyxcbiAqICAgY2hpbGRyZW46IFtzcHJpdGVdXG4gKiB9KTtcbiAqXG4gKiBzY2VuZS5yZW5kZXIoKTtcbiAqIGBgYFxuICpcbiAqIEBjbGFzcyBTY2VuZVxuICogQGV4dGVuZHMgR2FtZU9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gUHJvcGVydGllcyBvZiB0aGUgc2NlbmUuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydGllcy5pZCAtIFRoZSBpZCBvZiB0aGUgc2NlbmUuXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnRpZXMubmFtZT1wcm9wZXJ0aWVzLmlkXSAtIFRoZSBuYW1lIG9mIHRoZSBzY2VuZS4gVXNlZCBieSBzY3JlZW4gcmVhZGVycyB0byBpZGVudGlmeSBlYWNoIHNjZW5lLiBVc2UgdGhpcyBwcm9wZXJ0eSB0byBnaXZlIHRoZSBzY2VuZSBhIGh1bWFuIGZyaWVuZGx5IG5hbWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwcm9wZXJ0aWVzLmN1bGxPYmplY3RzPXRydWVdIC0gSWYgdGhlIHNjZW5lIHNob3VsZCBub3QgcmVuZGVyIG9iamVjdHMgb3V0c2lkZSB0aGUgY2FtZXJhIGJvdW5kcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9wZXJ0aWVzLmN1bGxGdW5jdGlvbl0gLSBUaGUgZnVuY3Rpb24gdXNlZCB0byBmaWx0ZXIgb2JqZWN0cyB0byByZW5kZXIuIERlZmF1bHRzIHRvIFtoZWxwZXJzLmNvbGxpZGVzXShhcGkvaGVscGVycyNjb2xsaWRlcykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcGVydGllcy5vblNob3ddIC0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIHNob3duLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BlcnRpZXMub25IaWRlXSAtIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBzY2VuZSBpcyBoaWRkZW4uXG4gKi9cbmNsYXNzIFNjZW5lIGV4dGVuZHMgZmFjdG9yeSQyLmNsYXNzIHtcblxuICBpbml0KHtcbiAgICAvKipcbiAgICAgKiBUaGUgaWQgb2YgdGhlIHNjZW5lLlxuICAgICAqIEBtZW1iZXJvZiBTY2VuZVxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBpZFxuICAgICAqL1xuICAgIGlkLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNjZW5lLiBVc2VkIGJ5IHNjcmVlbiByZWFkZXJzIHRvIGlkZW50aWZ5IGVhY2ggc2NlbmUuIFVzZSB0aGlzIHByb3BlcnR5IHRvIGdpdmUgdGhlIHNjZW5lIGEgaHVtYW4gZnJpZW5kbHkgbmFtZS5cbiAgICAgKiBAbWVtYmVyb2YgU2NlbmVcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gbmFtZVxuICAgICAqL1xuICAgICBuYW1lID0gaWQsXG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgY2FtZXJhIHNob3VsZCBjdWxsIG9iamVjdHMgb3V0c2lkZSB0aGUgY2FtZXJhIGJvdW5kcy4gTm90IHJlbmRlcmluZyBvYmplY3RzIHdoaWNoIGNhbid0IGJlIHNlZW4gZ3JlYXRseSBpbXByb3ZlcyB0aGUgcGVyZm9ybWFuY2UuXG4gICAgICogQG1lbWJlcm9mIFNjZW5lXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjdWxsT2JqZWN0c1xuICAgICAqL1xuICAgIGN1bGxPYmplY3RzID0gdHJ1ZSxcblxuICAgICAvKipcbiAgICAgKiBDYW1lcmEgY3VsbGluZyBmdW5jdGlvbiB3aGljaCBwcmV2ZW50cyBvYmplY3RzIG91dHNpZGUgdGhlIGNhbWVyYSBzY3JlZW4gZnJvbSByZW5kZXJpbmcuIElzIHBhc3NlZCBhcyB0aGUgYGZpbHRlckZ1bmN0aW9uYCB0byB0aGUgW3JlbmRlcl0oYXBpL2dhbWVPYmplY3QjcmVuZGVyKSBmdW5jdGlvbi5cbiAgICAgKiBAbWVtYmVyb2YgU2NlbmVcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBjdWxsRnVuY3Rpb25cbiAgICAgKi9cbiAgICBjdWxsRnVuY3Rpb24gPSBjb2xsaWRlcyxcblxuICAgIC4uLnByb3BzXG4gIH0pIHtcbiAgICAvLyBjcmVhdGUgYW4gYWNjZXNzaWJsZSBET00gbm9kZSBmb3Igc2NyZWVuIHJlYWRlcnMgKGRvIHRoaXMgZmlyc3RcbiAgICAvLyBzbyB3ZSBjYW4gbW92ZSBET00gbm9kZXMgaW4gYWRkQ2hpbGQpXG4gICAgLy8gZG4gPSBkb20gbm9kZVxuICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLl9kbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlY3Rpb24nKTtcbiAgICBzZWN0aW9uLnRhYkluZGV4ID0gLTE7XG4gICAgc2VjdGlvbi5zdHlsZSA9IHNyT25seVN0eWxlO1xuICAgIHNlY3Rpb24uaWQgPSBpZDtcbiAgICBzZWN0aW9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIG5hbWUpO1xuXG4gICAgc3VwZXIuaW5pdCh7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBjdWxsT2JqZWN0cyxcbiAgICAgIGN1bGxGdW5jdGlvbixcbiAgICAgIC4uLnByb3BzXG4gICAgfSk7XG5cbiAgICBhZGRUb0RvbShzZWN0aW9uLCB0aGlzLmNvbnRleHQuY2FudmFzKTtcblxuICAgIGxldCBjYW52YXMgPSB0aGlzLmNvbnRleHQuY2FudmFzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbWVyYSBvYmplY3Qgd2hpY2ggaXMgdXNlZCBhcyB0aGUgZm9jYWwgcG9pbnQgZm9yIHRoZSBzY2VuZS4gVGhlIHNjZW5lIHdpbGwgbm90IHJlbmRlciBvYmplY3RzIHRoYXQgYXJlIG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgY2FtZXJhLlxuICAgICAqXG4gICAgICogQWRkaXRpb25hbGx5LCB0aGUgY2FtZXJhIGNhbiBiZSB1c2VkIHRvIFtsb29rQXRdKGFwaS9zY2VuZSNsb29rQXQpIGFuIG9iamVjdCB3aGljaCB3aWxsIGNlbnRlciB0aGUgY2FtZXJhIHRvIHRoYXQgb2JqZWN0LiBUaGlzIGFsbG93cyB5b3UgdG8gem9vbSB0aGUgc2NlbmUgaW4gYW5kIG91dCB3aGlsZSB0aGUgY2FtZXJhIHJlbWFpbnMgY2VudGVyZWQgb24gdGhlIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyb2YgU2NlbmVcbiAgICAgKiBAcHJvcGVydHkge0dhbWVPYmplY3R9IGNhbWVyYVxuICAgICAqL1xuICAgIHRoaXMuY2FtZXJhID0gZmFjdG9yeSQyKHtcbiAgICAgIHg6IGNhbnZhcy53aWR0aCAvIDIsXG4gICAgICB5OiBjYW52YXMuaGVpZ2h0IC8gMixcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICBhbmNob3I6IHsgeDogMC41LCB5OiAwLjUgfVxuICAgIH0pO1xuXG4gICAgLy8gY2FuIGNhbGwgc3VwZXIgaGVyZSBvbmx5IGJ5IHVzaW5nIGxleGljYWwgc2NvcGVcbiAgICB0aGlzLmNhbWVyYS5fcGMgPSAoKSA9PiB7XG4gICAgICBzdXBlci5fcGMuY2FsbCh0aGlzLmNhbWVyYSk7XG5cbiAgICAgIC8vIG9ubHkgc2V0IHRoZSBjYW1lcmFzIHBvc2l0aW9uIGJhc2VkIG9uIHNjYWxlXG4gICAgICAvLyBidXQgbm90IHRoZSB3aWR0aC9oZWlnaHRcbiAgICAgIGxldCBjYW52YXMgPSB0aGlzLmNvbnRleHQuY2FudmFzO1xuICAgICAgdGhpcy5jYW1lcmEuX3d4ID0gdGhpcy5jYW1lcmEueCAqIHRoaXMuc2NhbGVYO1xuICAgICAgdGhpcy5jYW1lcmEuX3d5ID0gdGhpcy5jYW1lcmEueSAqIHRoaXMuc2NhbGVZO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2hvdyB0aGUgc2NlbmUgYW5kIHJlc3VtZSB1cGRhdGUgYW5kIHJlbmRlci4gQ2FsbHMgW29uU2hvd10oYXBpL3NjZW5lI29uU2hvdykgaWYgcGFzc2VkLlxuICAgKiBAbWVtYmVyb2YgU2NlbmVcbiAgICogQGZ1bmN0aW9uIHNob3dcbiAgICovXG4gIHNob3coKSB7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc2NlbmUgaXMgaGlkZGVuLlxuICAgICAqIEBtZW1iZXJvZiBTY2VuZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaGlkZGVuXG4gICAgICovXG4gICAgdGhpcy5oaWRkZW4gPSB0aGlzLl9kbi5oaWRkZW4gPSBmYWxzZTtcblxuICAgIC8vIGZpbmQgZmlyc3QgZm9jdXNhYmxlIGNoaWxkXG4gICAgbGV0IGZvY3VzYWJsZUNoaWxkID0gdGhpcy5jaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLmZvY3VzKTtcbiAgICBpZiAoZm9jdXNhYmxlQ2hpbGQpIHtcbiAgICAgIGZvY3VzYWJsZUNoaWxkLmZvY3VzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fZG4uZm9jdXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLm9uU2hvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIHNjZW5lLiBBIGhpZGRlbiBzY2VuZSB3aWxsIG5vdCB1cGRhdGUgb3IgcmVuZGVyLiBDYWxscyBbb25IaWRlXShhcGkvc2NlbmUjb25IaWRlKSBpZiBwYXNzZWQuXG4gICAqIEBtZW1iZXJvZiBTY2VuZVxuICAgKiBAZnVuY3Rpb24gaGlkZVxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmhpZGRlbiA9IHRoaXMuX2RuLmhpZGRlbiA9IHRydWU7XG4gICAgdGhpcy5vbkhpZGUoKTtcbiAgfVxuXG4gIGFkZENoaWxkKG9iamVjdCwgb3B0aW9ucykge1xuICAgIHN1cGVyLmFkZENoaWxkKG9iamVjdCwgb3B0aW9ucyk7XG5cbiAgICAvLyBtb3ZlIGFsbCBjaGlsZHJlbiB0byBiZSBpbiB0aGUgc2NlbmVzIERPTSBub2RlIHNvIHdlIGNhblxuICAgIC8vIGhpZGUgYW5kIHNob3cgdGhlIERPTSBub2RlIGFuZCB0aHVzIGhpZGUgYW5kIHNob3cgYWxsIHRoZVxuICAgIC8vIGNoaWxkcmVuXG4gICAgZ2V0QWxsTm9kZXMob2JqZWN0KS5tYXAobm9kZSA9PiB7XG4gICAgICB0aGlzLl9kbi5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZUNoaWxkKG9iamVjdCkge1xuICAgIHN1cGVyLnJlbW92ZUNoaWxkKG9iamVjdCk7XG5cbiAgICBnZXRBbGxOb2RlcyhvYmplY3QpLm1hcChub2RlID0+IHtcbiAgICAgIGFkZFRvRG9tKG5vZGUsIHRoaXMuY29udGV4dC5jYW52YXMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSBzY2VuZSBhbmQgY2FsbCBgZGVzdHJveSgpYCBvbiBhbGwgY2hpbGRyZW4uXG4gICAqIEBtZW1iZXJvZiBTY2VuZVxuICAgKiBAZnVuY3Rpb24gZGVzdHJveVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9kbi5yZW1vdmUoKTtcbiAgICB0aGlzLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC5kZXN0cm95ICYmIGNoaWxkLmRlc3Ryb3koKSk7XG4gIH1cblxuICB1cGRhdGUoZHQpIHtcbiAgICBpZiAoIXRoaXMuaGlkZGVuKSB7XG4gICAgICBzdXBlci51cGRhdGUoZHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1cyB0aGUgY2FtZXJhIHRvIHRoZSBvYmplY3Qgb3IgeC95IHBvc2l0aW9uLiBBcyB0aGUgc2NlbmUgaXMgc2NhbGVkIHRoZSBmb2NhbCBwb2ludCB3aWxsIGtlZXAgdG8gdGhlIHBvc2l0aW9uLlxuICAgKiBAbWVtYmVyb2YgU2NlbmVcbiAgICogQGZ1bmN0aW9uIGxvb2tBdFxuICAgKlxuICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IG9iamVjdCAtIE9iamVjdCB3aXRoIHgveSBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgbG9va0F0KG9iamVjdCkge1xuXG4gICAgLy8gZG9uJ3QgY2FsbCBnZXRXb3JsZFJlY3Qgc28gd2UgY2FuIGlnbm9yZSB0aGUgb2JqZWN0cyBhbmNob3JcbiAgICBvYmplY3QgPSBvYmplY3Qud29ybGQgfHwgb2JqZWN0O1xuICAgIGxldCB4ID0gb2JqZWN0Lng7XG4gICAgbGV0IHkgPSBvYmplY3QueTtcblxuICAgIGlmIChvYmplY3Quc2NhbGVYKSB7XG4gICAgICB4IC89IG9iamVjdC5zY2FsZVg7XG4gICAgICB5IC89IG9iamVjdC5zY2FsZVk7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEueCA9IHg7XG4gICAgdGhpcy5jYW1lcmEueSA9IHk7XG4gICAgdGhpcy5fcGMoKTtcbiAgfVxuXG4gIF9wYygpIHtcbiAgICBzdXBlci5fcGMoKTtcblxuICAgIC8vIHRoaXMgY2FuIGJlIGNhbGxlZCBiZWZvcmUgdGhlIGNhbWVyYSBpcyBpbml0aWFsaXplZCBzbyB3ZVxuICAgIC8vIG5lZWQgdG8gZ3VhcmQgaXRcbiAgICB0aGlzLmNhbWVyYSAmJiB0aGlzLmNhbWVyYS5fcGMoKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLmNhbWVyYTtcblxuICAgIHRoaXMuc3ggPSB4ICogdGhpcy5zY2FsZVggLSB3aWR0aCAvIDI7XG4gICAgdGhpcy5zeSA9IHkgKiB0aGlzLnNjYWxlWSAtIGhlaWdodCAvIDI7XG5cbiAgICBpZiAoIXRoaXMuaGlkZGVuKSB7XG4gICAgICBzdXBlci5yZW5kZXIoY2hpbGQgPT4gdGhpcy5jdWxsT2JqZWN0cyA/IHRoaXMuY3VsbEZ1bmN0aW9uKGNoaWxkLCB0aGlzLmNhbWVyYSkgOiB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIHNob3duLiBPdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIGhhdmUgdGhlIHNjZW5lIGRvIHNvbWV0aGluZyB3aGVuIHNob3duLlxuICAgKiBAbWVtYmVyb2YgU2NlbmVcbiAgICogQGZ1bmN0aW9uIG9uU2hvd1xuICAgKi9cbiAgb25TaG93KCkge31cblxuICAvKipcbiAgICogRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIGhpZGRlbi4gT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBoYXZlIHRoZSBzY2VuZSBkbyBzb21ldGhpbmcgd2hlbiBoaWRkZW4uXG4gICAqIEBtZW1iZXJvZiBTY2VuZVxuICAgKiBAZnVuY3Rpb24gb25IaWRlXG4gICAqL1xuICBvbkhpZGUoKSB7fVxufVxuXG5mdW5jdGlvbiBmYWN0b3J5JDkoKSB7XG4gIHJldHVybiBuZXcgU2NlbmUoLi4uYXJndW1lbnRzKTtcbn1cbmZhY3RvcnkkOS5wcm90b3R5cGUgPSBTY2VuZS5wcm90b3R5cGU7XG5mYWN0b3J5JDkuY2xhc3MgPSBTY2VuZTtcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBvZiBjb25zZWN1dGl2ZSBmcmFtZXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBmcmFtZXMgLSBTdGFydCBhbmQgZW5kIGZyYW1lLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ8TnVtYmVyW119IExpc3Qgb2YgZnJhbWVzLlxuICovXG5mdW5jdGlvbiBwYXJzZUZyYW1lcyhjb25zZWN1dGl2ZUZyYW1lcykge1xuICAvLyByZXR1cm4gYSBzaW5nbGUgbnVtYmVyIGZyYW1lXG4gIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2plZC8xNDBieXRlcy93aWtpL0J5dGUtc2F2aW5nLXRlY2huaXF1ZXMjY29lcmNpb24tdG8tdGVzdC1mb3ItdHlwZXNcbiAgaWYgKCtjb25zZWN1dGl2ZUZyYW1lcyA9PT0gY29uc2VjdXRpdmVGcmFtZXMpIHtcbiAgICByZXR1cm4gY29uc2VjdXRpdmVGcmFtZXM7XG4gIH1cblxuICBsZXQgc2VxdWVuY2UgPSBbXTtcbiAgbGV0IGZyYW1lcyA9IGNvbnNlY3V0aXZlRnJhbWVzLnNwbGl0KCcuLicpO1xuXG4gIC8vIGNvZXJjZSBzdHJpbmcgdG8gbnVtYmVyXG4gIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2plZC8xNDBieXRlcy93aWtpL0J5dGUtc2F2aW5nLXRlY2huaXF1ZXMjY29lcmNpb24tdG8tdGVzdC1mb3ItdHlwZXNcbiAgbGV0IHN0YXJ0ID0gK2ZyYW1lc1swXTtcbiAgbGV0IGVuZCA9ICtmcmFtZXNbMV07XG4gIGxldCBpID0gc3RhcnQ7XG5cbiAgLy8gYXNjZW5kaW5nIGZyYW1lIG9yZGVyXG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIGZvciAoOyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICBzZXF1ZW5jZS5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICAvLyBkZXNjZW5kaW5nIG9yZGVyXG4gIGVsc2Uge1xuICAgIGZvciAoOyBpID49IGVuZDsgaS0tKSB7XG4gICAgICBzZXF1ZW5jZS5wdXNoKGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXF1ZW5jZTtcbn1cblxuLyoqXG4gKiBBIHNwcml0ZSBzaGVldCB0byBhbmltYXRlIGEgc2VxdWVuY2Ugb2YgaW1hZ2VzLiBVc2VkIHRvIGNyZWF0ZSBbYW5pbWF0aW9uIHNwcml0ZXNdKGFwaS9zcHJpdGUjYW5pbWF0aW9uLXNwcml0ZSkuXG4gKlxuICogPGZpZ3VyZT5cbiAqICAgPGEgaHJlZj1cImFzc2V0cy9pbWdzL2NoYXJhY3Rlcl93YWxrX3NoZWV0LnBuZ1wiPlxuICogICAgIDxpbWcgc3JjPVwiYXNzZXRzL2ltZ3MvY2hhcmFjdGVyX3dhbGtfc2hlZXQucG5nXCIgd2lkdGg9XCIyNjZcIiBoZWlnaHQ9XCI1MTJcIiBhbHQ9XCIxMSBmcmFtZXMgb2YgYSB3YWxraW5nIHBpbGwtbGlrZSBhbGllbiB3ZWFyaW5nIGEgc3BhY2UgaGVsbWV0LlwiPlxuICogICA8L2E+XG4gKiAgIDxmaWdjYXB0aW9uPlNwcml0ZSBzaGVldCBpbWFnZSBjb3VydGVzeSBvZiA8YSBocmVmPVwiaHR0cHM6Ly9rZW5uZXkubmwvYXNzZXRzXCI+S2VubmV5PC9hPi48L2ZpZ2NhcHRpb24+XG4gKiA8L2ZpZ3VyZT5cbiAqXG4gKiBUeXBpY2FsbHkgeW91IGNyZWF0ZSBhIHNwcml0ZSBzaGVldCBqdXN0IHRvIGNyZWF0ZSBhbmltYXRpb25zIGFuZCB0aGVuIHVzZSB0aGUgYW5pbWF0aW9ucyBmb3IgeW91ciBzcHJpdGUuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IFNwcml0ZSwgU3ByaXRlU2hlZXQgfSBmcm9tICdrb250cmEnO1xuICpcbiAqIGxldCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICogaW1hZ2Uuc3JjID0gJ2Fzc2V0cy9pbWdzL2NoYXJhY3Rlcl93YWxrX3NoZWV0LnBuZyc7XG4gKiBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAqICAgbGV0IHNwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXQoe1xuICogICAgIGltYWdlOiBpbWFnZSxcbiAqICAgICBmcmFtZVdpZHRoOiA3MixcbiAqICAgICBmcmFtZUhlaWdodDogOTcsXG4gKiAgICAgYW5pbWF0aW9uczoge1xuICogICAgICAgLy8gY3JlYXRlIGEgbmFtZWQgYW5pbWF0aW9uOiB3YWxrXG4gKiAgICAgICB3YWxrOiB7XG4gKiAgICAgICAgIGZyYW1lczogJzAuLjknLCAgLy8gZnJhbWVzIDAgdGhyb3VnaCA5XG4gKiAgICAgICAgIGZyYW1lUmF0ZTogMzBcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqICAgbGV0IHNwcml0ZSA9IFNwcml0ZSh7XG4gKiAgICAgeDogMjAwLFxuICogICAgIHk6IDEwMCxcbiAqXG4gKiAgICAgLy8gdXNlIHRoZSBzcHJpdGUgc2hlZXQgYW5pbWF0aW9ucyBmb3IgdGhlIHNwcml0ZVxuICogICAgIGFuaW1hdGlvbnM6IHNwcml0ZVNoZWV0LmFuaW1hdGlvbnNcbiAqICAgfSk7XG4gKiB9O1xuICogYGBgXG4gKiBAY2xhc3MgU3ByaXRlU2hlZXRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIFByb3BlcnRpZXMgb2YgdGhlIHNwcml0ZSBzaGVldC5cbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gcHJvcGVydGllcy5pbWFnZSAtIFRoZSBzcHJpdGUgc2hlZXQgaW1hZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5mcmFtZVdpZHRoIC0gVGhlIHdpZHRoIG9mIGEgc2luZ2xlIGZyYW1lLlxuICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMuZnJhbWVIZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIGEgc2luZ2xlIGZyYW1lLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wZXJ0aWVzLmZyYW1lTWFyZ2luPTBdIC0gVGhlIGFtb3VudCBvZiB3aGl0ZXNwYWNlIGJldHdlZW4gZWFjaCBmcmFtZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcy5hbmltYXRpb25zXSAtIEFuaW1hdGlvbnMgdG8gY3JlYXRlIGZyb20gdGhlIHNwcml0ZSBzaGVldCB1c2luZyBbQW5pbWF0aW9uXShhcGkvYW5pbWF0aW9uKS4gUGFzc2VkIGRpcmVjdGx5IGludG8gdGhlIHNwcml0ZSBzaGVldHMgW2NyZWF0ZUFuaW1hdGlvbnMoKV0oYXBpL3Nwcml0ZVNoZWV0I2NyZWF0ZUFuaW1hdGlvbnMpIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBTcHJpdGVTaGVldCB7XG4gIGNvbnN0cnVjdG9yKHtpbWFnZSwgZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQsIGZyYW1lTWFyZ2luLCBhbmltYXRpb25zfSA9IHt9KSB7XG4gICAgLy8gQGlmZGVmIERFQlVHXG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYW4gSW1hZ2UgZm9yIHRoZSBTcHJpdGVTaGVldCcpO1xuICAgIH1cbiAgICAvLyBAZW5kaWZcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBvZiBuYW1lZCBbQW5pbWF0aW9uXShhcGkvYW5pbWF0aW9uKSBvYmplY3RzLiBUeXBpY2FsbHkgeW91IHBhc3MgdGhpcyBvYmplY3QgaW50byBbU3ByaXRlXShhcGkvc3ByaXRlKSB0byBjcmVhdGUgYW4gW2FuaW1hdGlvbiBzcHJpdGVzXShhcGkvc3ByaXRlU2hlZXQjYW5pbWF0aW9uLXNwcml0ZSkuXG4gICAgICogQG1lbWJlcm9mIFNwcml0ZVNoZWV0XG4gICAgICogQHByb3BlcnR5IHt7W25hbWU6IHN0cmluZ10gOiBBbmltYXRpb259fSBhbmltYXRpb25zXG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25zID0ge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3ByaXRlIHNoZWV0IGltYWdlLlxuICAgICAqIEBtZW1iZXJvZiBTcHJpdGVTaGVldFxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gaW1hZ2VcbiAgICAgKi9cbiAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdGhhdCBkZWZpbmVzIHByb3BlcnRpZXMgb2YgYSBzaW5nbGUgZnJhbWUgaW4gdGhlIHNwcml0ZSBzaGVldC4gSXQgaGFzIHByb3BlcnRpZXMgb2YgYHdpZHRoYCwgYGhlaWdodGAsIGFuZCBgbWFyZ2luYC5cbiAgICAgKlxuICAgICAqIGB3aWR0aGAgYW5kIGBoZWlnaHRgIGFyZSB0aGUgd2lkdGggb2YgYSBzaW5nbGUgZnJhbWUsIHdoaWxlIGBtYXJnaW5gIGRlZmluZXMgdGhlIGFtb3VudCBvZiB3aGl0ZXNwYWNlIGJldHdlZW4gZWFjaCBmcmFtZS5cbiAgICAgKiBAbWVtYmVyb2YgU3ByaXRlU2hlZXRcbiAgICAgKiBAcHJvcGVydHkge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgbWFyZ2luOiBudW1iZXJ9fSBmcmFtZVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWUgPSB7XG4gICAgICB3aWR0aDogZnJhbWVXaWR0aCxcbiAgICAgIGhlaWdodDogZnJhbWVIZWlnaHQsXG4gICAgICBtYXJnaW46IGZyYW1lTWFyZ2luXG4gICAgfTtcblxuICAgIC8vIGYgPSBmcmFtZXNQZXJSb3dcbiAgICB0aGlzLl9mID0gaW1hZ2Uud2lkdGggLyBmcmFtZVdpZHRoIHwgMDtcblxuICAgIHRoaXMuY3JlYXRlQW5pbWF0aW9ucyhhbmltYXRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgbmFtZWQgYW5pbWF0aW9ucyBmcm9tIHRoZSBzcHJpdGUgc2hlZXQuIENhbGxlZCBmcm9tIHRoZSBjb25zdHJ1Y3RvciBpZiB0aGUgYGFuaW1hdGlvbnNgIGFyZ3VtZW50IGlzIHBhc3NlZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBwb3B1bGF0ZXMgdGhlIHNwcml0ZSBzaGVldHMgYGFuaW1hdGlvbnNgIHByb3BlcnR5IHdpdGggW0FuaW1hdGlvbl0oYXBpL2FuaW1hdGlvbikgb2JqZWN0cy4gRWFjaCBhbmltYXRpb24gaXMgYWNjZXNzaWJsZSBieSBpdHMgbmFtZS5cbiAgICpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHsgU3ByaXRlLCBTcHJpdGVTaGVldCB9IGZyb20gJ2tvbnRyYSc7XG4gICAqXG4gICAqIGxldCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgKiBpbWFnZS5zcmMgPSAnYXNzZXRzL2ltZ3MvY2hhcmFjdGVyX3dhbGtfc2hlZXQucG5nJztcbiAgICogaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAqXG4gICAqICAgbGV0IHNwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXQoe1xuICAgKiAgICAgaW1hZ2U6IGltYWdlLFxuICAgKiAgICAgZnJhbWVXaWR0aDogNzIsXG4gICAqICAgICBmcmFtZUhlaWdodDogOTcsXG4gICAqXG4gICAqICAgICAvLyB0aGlzIHdpbGwgYWxzbyBjYWxsIGNyZWF0ZUFuaW1hdGlvbnMoKVxuICAgKiAgICAgYW5pbWF0aW9uczoge1xuICAgKiAgICAgICAvLyBjcmVhdGUgMSBhbmltYXRpb246IGlkbGVcbiAgICogICAgICAgaWRsZToge1xuICAgKiAgICAgICAgIC8vIGEgc2luZ2xlIGZyYW1lXG4gICAqICAgICAgICAgZnJhbWVzOiAxXG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogICBzcHJpdGVTaGVldC5jcmVhdGVBbmltYXRpb25zKHtcbiAgICogICAgIC8vIGNyZWF0ZSA0IGFuaW1hdGlvbnM6IGp1bXAsIHdhbGssIG1vb25XYWxrLCBhdHRhY2tcbiAgICogICAgIGp1bXA6IHtcbiAgICogICAgICAgLy8gc2VxdWVuY2Ugb2YgZnJhbWVzIChjYW4gYmUgbm9uLWNvbnNlY3V0aXZlKVxuICAgKiAgICAgICBmcmFtZXM6IFsxLCAxMCwgMV0sXG4gICAqICAgICAgIGZyYW1lUmF0ZTogMTAsXG4gICAqICAgICAgIGxvb3A6IGZhbHNlLFxuICAgKiAgICAgfSxcbiAgICogICAgIHdhbGs6IHtcbiAgICogICAgICAgLy8gYXNjZW5kaW5nIGNvbnNlY3V0aXZlIGZyYW1lIGFuaW1hdGlvbiAoZnJhbWVzIDItNiwgaW5jbHVzaXZlKVxuICAgKiAgICAgICBmcmFtZXM6ICcyLi42JyxcbiAgICogICAgICAgZnJhbWVSYXRlOiAyMFxuICAgKiAgICAgfSxcbiAgICogICAgIG1vb25XYWxrOiB7XG4gICAqICAgICAgIC8vIGRlc2NlbmRpbmcgY29uc2VjdXRpdmUgZnJhbWUgYW5pbWF0aW9uIChmcmFtZXMgNi0yLCBpbmNsdXNpdmUpXG4gICAqICAgICAgIGZyYW1lczogJzYuLjInLFxuICAgKiAgICAgICBmcmFtZVJhdGU6IDIwXG4gICAqICAgICB9LFxuICAgKiAgICAgYXR0YWNrOiB7XG4gICAqICAgICAgIC8vIHlvdSBjYW4gYWxzbyBtaXggYW5kIG1hdGNoLCBpbiB0aGlzIGNhc2UgZnJhbWVzIFs4LDksMTAsMTMsMTAsOSw4XVxuICAgKiAgICAgICBmcmFtZXM6IFsnOC4uMTAnLCAxMywgJzEwLi44J10sXG4gICAqICAgICAgIGZyYW1lUmF0ZTogMTAsXG4gICAqICAgICAgIGxvb3A6IGZhbHNlLFxuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKiB9O1xuICAgKiBgYGBcbiAgICogQG1lbWJlcm9mIFNwcml0ZVNoZWV0XG4gICAqIEBmdW5jdGlvbiBjcmVhdGVBbmltYXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhbmltYXRpb25zIC0gT2JqZWN0IG9mIG5hbWVkIGFuaW1hdGlvbnMgdG8gY3JlYXRlIGZyb20gdGhlIHNwcml0ZSBzaGVldC5cbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfE51bWJlcltdfFN0cmluZ1tdfSBhbmltYXRpb25zLjxuYW1lPi5mcmFtZXMgLSBUaGUgc2VxdWVuY2Ugb2YgZnJhbWVzIHRvIHVzZSBmcm9tIHRoZSBzcHJpdGUgc2hlZXQuIEl0IGNhbiBlaXRoZXIgYmUgYSBzaW5nbGUgZnJhbWUgKGAxYCksIGEgc2VxdWVuY2Ugb2YgZnJhbWVzIChgWzEsMiwzLDRdYCksIG9yIGEgY29uc2VjdXRpdmUgZnJhbWUgbm90YXRpb24gKGAnMS4uNCdgKS4gU3ByaXRlIHNoZWV0IGZyYW1lcyBhcmUgYDBgIGluZGV4ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb25zLjxuYW1lPi5mcmFtZVJhdGUgLSBUaGUgbnVtYmVyIGZyYW1lcyB0byBkaXNwbGF5IHBlciBzZWNvbmQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FuaW1hdGlvbnMuPG5hbWU+Lmxvb3A9dHJ1ZV0gLSBJZiB0aGUgYW5pbWF0aW9uIHNob3VsZCBsb29wIGJhY2sgdG8gdGhlIGJlZ2lubmluZyBvbmNlIGNvbXBsZXRlZC5cbiAgICovXG4gIGNyZWF0ZUFuaW1hdGlvbnMoYW5pbWF0aW9ucykge1xuICAgIGxldCBzZXF1ZW5jZSwgbmFtZTtcblxuICAgIGZvciAobmFtZSBpbiBhbmltYXRpb25zKSB7XG4gICAgICBsZXQgeyBmcmFtZXMsIGZyYW1lUmF0ZSwgbG9vcCB9ID0gYW5pbWF0aW9uc1tuYW1lXTtcblxuICAgICAgLy8gYXJyYXkgdGhhdCBob2xkcyB0aGUgb3JkZXIgb2YgdGhlIGFuaW1hdGlvblxuICAgICAgc2VxdWVuY2UgPSBbXTtcblxuICAgICAgLy8gQGlmZGVmIERFQlVHXG4gICAgICBpZiAoZnJhbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0FuaW1hdGlvbiAnICsgbmFtZSArICcgbXVzdCBwcm92aWRlIGEgZnJhbWVzIHByb3BlcnR5Jyk7XG4gICAgICB9XG4gICAgICAvLyBAZW5kaWZcblxuICAgICAgLy8gYWRkIG5ldyBmcmFtZXMgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXlcbiAgICAgIFtdLmNvbmNhdChmcmFtZXMpLm1hcChmcmFtZSA9PiB7XG4gICAgICAgIHNlcXVlbmNlID0gc2VxdWVuY2UuY29uY2F0KHBhcnNlRnJhbWVzKGZyYW1lKSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5hbmltYXRpb25zW25hbWVdID0gZmFjdG9yeSh7XG4gICAgICAgIHNwcml0ZVNoZWV0OiB0aGlzLFxuICAgICAgICBmcmFtZXM6IHNlcXVlbmNlLFxuICAgICAgICBmcmFtZVJhdGUsXG4gICAgICAgIGxvb3BcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmYWN0b3J5JGEoKSB7XG4gIHJldHVybiBuZXcgU3ByaXRlU2hlZXQoLi4uYXJndW1lbnRzKTtcbn1cbmZhY3RvcnkkYS5wcm90b3R5cGUgPSBTcHJpdGVTaGVldC5wcm90b3R5cGU7XG5mYWN0b3J5JGEuY2xhc3MgPSBTcHJpdGVTaGVldDtcblxuLyoqXG4gKiBBIHRpbGUgZW5naW5lIGZvciBtYW5hZ2luZyBhbmQgZHJhd2luZyB0aWxlc2V0cy5cbiAqXG4gKiA8ZmlndXJlPlxuICogICA8YSBocmVmPVwiYXNzZXRzL2ltZ3MvbWFwUGFja190aWxlc2hlZXQucG5nXCI+XG4gKiAgICAgPGltZyBzcmM9XCJhc3NldHMvaW1ncy9tYXBQYWNrX3RpbGVzaGVldC5wbmdcIiB3aWR0aD1cIjEwODhcIiBoZWlnaHQ9XCI3NjhcIiBhbHQ9XCJUaWxlc2V0IHRvIGNyZWF0ZSBhbiBvdmVyd29ybGQgbWFwIGluIHZhcmlvdXMgc2Vhc29ucy5cIj5cbiAqICAgPC9hPlxuICogICA8ZmlnY2FwdGlvbj5UaWxlc2V0IGltYWdlIGNvdXJ0ZXN5IG9mIDxhIGhyZWY9XCJodHRwczovL2tlbm5leS5ubC9hc3NldHNcIj5LZW5uZXk8L2E+LjwvZmlnY2FwdGlvbj5cbiAqIDwvZmlndXJlPlxuICogQGNsYXNzIFRpbGVFbmdpbmVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIFByb3BlcnRpZXMgb2YgdGhlIHRpbGUgZW5naW5lLlxuICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMud2lkdGggLSBXaWR0aCBvZiB0aGUgdGlsZSBtYXAgKGluIG51bWJlciBvZiB0aWxlcykuXG4gKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy5oZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHRpbGUgbWFwIChpbiBudW1iZXIgb2YgdGlsZXMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHByb3BlcnRpZXMudGlsZXdpZHRoIC0gV2lkdGggb2YgYSBzaW5nbGUgdGlsZSAoaW4gcGl4ZWxzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wZXJ0aWVzLnRpbGVoZWlnaHQgLSBIZWlnaHQgb2YgYSBzaW5nbGUgdGlsZSAoaW4gcGl4ZWxzKS5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbcHJvcGVydGllcy5jb250ZXh0XSAtIFRoZSBjb250ZXh0IHRoZSB0aWxlIGVuZ2luZSBzaG91bGQgZHJhdyB0by4gRGVmYXVsdHMgdG8gW2NvcmUuZ2V0Q29udGV4dCgpXShhcGkvY29yZSNnZXRDb250ZXh0KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IHByb3BlcnRpZXMudGlsZXNldHMgLSBBcnJheSBvZiB0aWxlc2V0IG9iamVjdHMuXG4gKiBAcGFyYW0ge051bWJlcn0gcHJvcGVydGllcy50aWxlc2V0Ti5maXJzdGdpZCAtIEZpcnN0IHRpbGUgaW5kZXggb2YgdGhlIHRpbGVzZXQuIFRoZSBmaXJzdCB0aWxlc2V0IHdpbGwgaGF2ZSBhIGZpcnN0Z2lkIG9mIDEgYXMgMCByZXByZXNlbnRzIGFuIGVtcHR5IHRpbGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xIVE1MSW1hZ2VFbGVtZW50fSBwcm9wZXJ0aWVzLnRpbGVzZXROLmltYWdlIC0gUmVsYXRpdmUgcGF0aCB0byB0aGUgSFRNTEltYWdlRWxlbWVudCBvciBhbiBIVE1MSW1hZ2VFbGVtZW50LiBJZiBwYXNzaW5nIGEgcmVsYXRpdmUgcGF0aCwgdGhlIGltYWdlIGZpbGUgbXVzdCBoYXZlIGJlZW4gW2xvYWRlZF0oYXBpL2Fzc2V0cyNsb2FkKSBmaXJzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvcGVydGllcy50aWxlc2V0Ti5tYXJnaW49MF0gLSBUaGUgYW1vdW50IG9mIHdoaXRlc3BhY2UgYmV0d2VlbiBlYWNoIHRpbGUgKGluIHBpeGVscykuXG4gKiBAcGFyYW0ge051bWJlcn0gW3Byb3BlcnRpZXMudGlsZXNldE4udGlsZXdpZHRoXSAtIFdpZHRoIG9mIHRoZSB0aWxlc2V0IChpbiBwaXhlbHMpLiBEZWZhdWx0cyB0byBwcm9wZXJ0aWVzLnRpbGV3aWR0aC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvcGVydGllcy50aWxlc2V0Ti50aWxlaGVpZ2h0XSAtIEhlaWdodCBvZiB0aGUgdGlsZXNldCAoaW4gcGl4ZWxzKS4gRGVmYXVsdHMgdG8gcHJvcGVydGllcy50aWxlaGVpZ2h0LlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0aWVzLnRpbGVzZXROLnNvdXJjZV0gLSBSZWxhdGl2ZSBwYXRoIHRvIHRoZSBzb3VyY2UgSlNPTiBmaWxlLiBUaGUgc291cmNlIEpTT04gZmlsZSBtdXN0IGhhdmUgYmVlbiBbbG9hZGVkXShhcGkvYXNzZXRzI2xvYWQpIGZpcnN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wZXJ0aWVzLnRpbGVzZXROLmNvbHVtbnNdIC0gTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRpbGVzZXQgaW1hZ2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gcHJvcGVydGllcy5sYXllcnMgLSBBcnJheSBvZiBsYXllciBvYmplY3RzLlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnRpZXMubGF5ZXJOLm5hbWUgLSBVbmlxdWUgbmFtZSBvZiB0aGUgbGF5ZXIuXG4gKiBAcGFyYW0ge051bWJlcltdfSBwcm9wZXJ0aWVzLmxheWVyTi5kYXRhIC0gMUQgYXJyYXkgb2YgdGlsZSBpbmRpY2VzLlxuICogQHBhcmFtIHtCb29sZWFufSBbcHJvcGVydGllcy5sYXllck4udmlzaWJsZT10cnVlXSAtIElmIHRoZSBsYXllciBzaG91bGQgYmUgZHJhd24gb3Igbm90LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9wZXJ0aWVzLmxheWVyTi5vcGFjaXR5PTFdIC0gUGVyY2VudCBvcGFjaXR5IG9mIHRoZSBsYXllci5cbiAqL1xuXG4vKipcbiAqIEBkb2NzIGRvY3MvYXBpX2RvY3MvdGlsZUVuZ2luZS5qc1xuICovXG5cbmZ1bmN0aW9uIFRpbGVFbmdpbmUocHJvcGVydGllcykge1xuICBsZXQge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB0aWxld2lkdGgsXG4gICAgdGlsZWhlaWdodCxcbiAgICBjb250ZXh0ID0gZ2V0Q29udGV4dCgpLFxuICAgIHRpbGVzZXRzLFxuICAgIGxheWVyc1xuICB9ID0gcHJvcGVydGllcztcblxuICBsZXQgbWFwd2lkdGggPSB3aWR0aCAqIHRpbGV3aWR0aDtcbiAgbGV0IG1hcGhlaWdodCA9IGhlaWdodCAqIHRpbGVoZWlnaHQ7XG5cbiAgLy8gY3JlYXRlIGFuIG9mZi1zY3JlZW4gY2FudmFzIGZvciBwcmUtcmVuZGVyaW5nIHRoZSBtYXBcbiAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9yZW5kZXItdnMtcHJlcmVuZGVyXG4gIGxldCBvZmZzY3JlZW5DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgbGV0IG9mZnNjcmVlbkNvbnRleHQgPSBvZmZzY3JlZW5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgb2Zmc2NyZWVuQ2FudmFzLndpZHRoID0gbWFwd2lkdGg7XG4gIG9mZnNjcmVlbkNhbnZhcy5oZWlnaHQgPSBtYXBoZWlnaHQ7XG5cbiAgLy8gbWFwIGxheWVyIG5hbWVzIHRvIGRhdGFcbiAgbGV0IGxheWVyTWFwID0ge307XG4gIGxldCBsYXllckNhbnZhc2VzID0ge307XG5cbiAgLy8gb2JqZWN0cyBhZGRlZCB0byB0aWxlIGVuZ2luZSB0byBzeW5jIHdpdGggdGhlIGNhbWVyYVxuICBsZXQgb2JqZWN0cyA9IFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGlsZSBtYXAgKGluIHRpbGVzKS5cbiAgICogQG1lbWJlcm9mIFRpbGVFbmdpbmVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHdpZHRoXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRpbGUgbWFwIChpbiB0aWxlcykuXG4gICAqIEBtZW1iZXJvZiBUaWxlRW5naW5lXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBoZWlnaHRcbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBhIHRpbGUgKGluIHBpeGVscykuXG4gICAqIEBtZW1iZXJvZiBUaWxlRW5naW5lXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0aWxld2lkdGhcbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBoZWlnaHQgb2YgYSB0aWxlIChpbiBwaXhlbHMpLlxuICAgKiBAbWVtYmVyb2YgVGlsZUVuZ2luZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gdGlsZWhlaWdodFxuICAgKi9cblxuICAvKipcbiAgICogQXJyYXkgb2YgYWxsIGxheWVycyBvZiB0aGUgdGlsZSBlbmdpbmUuXG4gICAqIEBtZW1iZXJvZiBUaWxlRW5naW5lXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0W119IGxheWVyc1xuICAgKi9cblxuICAvKipcbiAgICogQXJyYXkgb2YgYWxsIHRpbGVzZXRzIG9mIHRoZSB0aWxlIGVuZ2luZS5cbiAgICogQG1lbWJlcm9mIFRpbGVFbmdpbmVcbiAgICogQHByb3BlcnR5IHtPYmplY3RbXX0gdGlsZXNldHNcbiAgICovXG5cbiAgbGV0IHRpbGVFbmdpbmUgPSBPYmplY3QuYXNzaWduKHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZXh0IHRoZSB0aWxlIGVuZ2luZSB3aWxsIGRyYXcgdG8uXG4gICAgICogQG1lbWJlcm9mIFRpbGVFbmdpbmVcbiAgICAgKiBAcHJvcGVydHkge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuICAgICAqL1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHRpbGUgbWFwIChpbiBwaXhlbHMpLlxuICAgICAqIEBtZW1iZXJvZiBUaWxlRW5naW5lXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1hcHdpZHRoXG4gICAgICovXG4gICAgbWFwd2lkdGg6IG1hcHdpZHRoLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgdGlsZSBtYXAgKGluIHBpeGVscykuXG4gICAgICogQG1lbWJlcm9mIFRpbGVFbmdpbmVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gbWFwaGVpZ2h0XG4gICAgICovXG4gICAgbWFwaGVpZ2h0OiBtYXBoZWlnaHQsXG4gICAgX3N4OiAwLFxuICAgIF9zeTogMCxcblxuICAgIC8vIGQgPSBkaXJ0eVxuICAgIF9kOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFggY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBtYXAgY2FtZXJhLlxuICAgICAqIEBtZW1iZXJvZiBUaWxlRW5naW5lXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN4XG4gICAgICovXG4gICAgZ2V0IHN4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBZIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgbWFwIGNhbWVyYS5cbiAgICAgKiBAbWVtYmVyb2YgVGlsZUVuZ2luZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzeVxuICAgICAqL1xuICAgIGdldCBzeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zeTtcbiAgICB9LFxuXG4gICAgLy8gd2hlbiBjbGlwcGluZyBhbiBpbWFnZSwgc3ggYW5kIHN5IG11c3Qgd2l0aGluIHRoZSBpbWFnZSByZWdpb24sIG90aGVyd2lzZVxuICAgIC8vIEZpcmVmb3ggYW5kIFNhZmFyaSB3b24ndCBkcmF3IGl0LlxuICAgIC8vIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTMzODAzMi9jYW52YXMtaW5kZXhzaXplZXJyb3ItaW5kZXgtb3Itc2l6ZS1pcy1uZWdhdGl2ZS1vci1ncmVhdGVyLXRoYW4tdGhlLWFsbG93ZWQtYVxuICAgIHNldCBzeCh2YWx1ZSkge1xuICAgICAgdGhpcy5fc3ggPSBjbGFtcCgwLCBtYXB3aWR0aCAtIGdldENhbnZhcygpLndpZHRoLCB2YWx1ZSk7XG4gICAgICBvYmplY3RzLmZvckVhY2gob2JqID0+IG9iai5zeCA9IHRoaXMuX3N4KTtcbiAgICB9LFxuXG4gICAgc2V0IHN5KHZhbHVlKSB7XG4gICAgICB0aGlzLl9zeSA9IGNsYW1wKDAsIG1hcGhlaWdodCAtIGdldENhbnZhcygpLmhlaWdodCwgdmFsdWUpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKG9iaiA9PiBvYmouc3kgPSB0aGlzLl9zeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhbGwgdmlzaWJsZSBsYXllcnMuXG4gICAgICogQG1lbWJlcm9mIFRpbGVFbmdpbmVcbiAgICAgKiBAZnVuY3Rpb24gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgaWYgKHRoaXMuX2QpIHtcbiAgICAgICAgdGhpcy5fZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wKCk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcihvZmZzY3JlZW5DYW52YXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBzcGVjaWZpYyBsYXllciBieSBuYW1lLlxuICAgICAqIEBtZW1iZXJvZiBUaWxlRW5naW5lXG4gICAgICogQGZ1bmN0aW9uIHJlbmRlckxheWVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHJlbmRlci5cbiAgICAgKi9cbiAgICByZW5kZXJMYXllcihuYW1lKSB7XG4gICAgICBsZXQgY2FudmFzID0gbGF5ZXJDYW52YXNlc1tuYW1lXTtcbiAgICAgIGxldCBsYXllciA9IGxheWVyTWFwW25hbWVdO1xuXG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAvLyBjYWNoZSB0aGUgcmVuZGVyZWQgbGF5ZXIgc28gd2UgY2FuIHJlbmRlciBpdCBhZ2FpbiB3aXRob3V0IHJlZHJhd2luZ1xuICAgICAgICAvLyBhbGwgdGlsZXNcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG1hcHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbWFwaGVpZ2h0O1xuXG4gICAgICAgIGxheWVyQ2FudmFzZXNbbmFtZV0gPSBjYW52YXM7XG4gICAgICAgIHRpbGVFbmdpbmUuX3IobGF5ZXIsIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxheWVyLl9kKSB7XG4gICAgICAgIGxheWVyLl9kID0gZmFsc2U7XG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB0aWxlRW5naW5lLl9yKGxheWVyLCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcihjYW52YXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgb2JqZWN0IGNvbGxpZGVzIHdpdGggdGhlIGxheWVyIChzaGFyZXMgYSBnaXJkIGNvb3JkaW5hdGUgd2l0aCBhbnkgcG9zaXRpdmUgdGlsZSBpbmRleCBpbiBsYXllcnMgZGF0YSkuIFRoZSBvYmplY3QgYmVpbmcgY2hlY2tlZCBtdXN0IGhhdmUgdGhlIHByb3BlcnRpZXMgYHhgLCBgeWAsIGB3aWR0aGAsIGFuZCBgaGVpZ2h0YCBzbyB0aGF0IGl0cyBwb3NpdGlvbiBpbiB0aGUgZ3JpZCBjYW4gYmUgY2FsY3VsYXRlZC4gW1Nwcml0ZV0oYXBpL3Nwcml0ZSkgZGVmaW5lcyB0aGVzZSBwcm9wZXJ0aWVzIGZvciB5b3UuXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCB7IFRpbGVFbmdpbmUsIFNwcml0ZSB9IGZyb20gJ2tvbnRyYSc7XG4gICAgICpcbiAgICAgKiBsZXQgdGlsZUVuZ2luZSA9IFRpbGVFbmdpbmUoe1xuICAgICAqICAgdGlsZXdpZHRoOiAzMixcbiAgICAgKiAgIHRpbGVoZWlnaHQ6IDMyLFxuICAgICAqICAgd2lkdGg6IDQsXG4gICAgICogICBoZWlnaHQ6IDQsXG4gICAgICogICB0aWxlc2V0czogW3tcbiAgICAgKiAgICAgLy8gLi4uXG4gICAgICogICB9XSxcbiAgICAgKiAgIGxheWVyczogW3tcbiAgICAgKiAgICAgbmFtZTogJ2NvbGxpc2lvbicsXG4gICAgICogICAgIGRhdGE6IFsgMCwwLDAsMCxcbiAgICAgKiAgICAgICAgICAgICAwLDEsNCwwLFxuICAgICAqICAgICAgICAgICAgIDAsMiw1LDAsXG4gICAgICogICAgICAgICAgICAgMCwwLDAsMCBdXG4gICAgICogICB9XVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogbGV0IHNwcml0ZSA9IFNwcml0ZSh7XG4gICAgICogICB4OiA1MCxcbiAgICAgKiAgIHk6IDIwLFxuICAgICAqICAgd2lkdGg6IDUsXG4gICAgICogICBoZWlnaHQ6IDVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHRpbGVFbmdpbmUubGF5ZXJDb2xsaWRlc1dpdGgoJ2NvbGxpc2lvbicsIHNwcml0ZSk7ICAvLz0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBzcHJpdGUueSA9IDI4O1xuICAgICAqXG4gICAgICogdGlsZUVuZ2luZS5sYXllckNvbGxpZGVzV2l0aCgnY29sbGlzaW9uJywgc3ByaXRlKTsgIC8vPT4gdHJ1ZVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBUaWxlRW5naW5lXG4gICAgICogQGZ1bmN0aW9uIGxheWVyQ29sbGlkZXNXaXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBsYXllciB0byBjaGVjayBmb3IgY29sbGlzaW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBPYmplY3QgdG8gY2hlY2sgY29sbGlzaW9uIGFnYWluc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBvYmplY3QgY29sbGlkZXMgd2l0aCBhIHRpbGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGxheWVyQ29sbGlkZXNXaXRoKG5hbWUsIG9iamVjdCkge1xuICAgICAgbGV0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gZ2V0V29ybGRSZWN0KG9iamVjdCk7XG5cbiAgICAgIGxldCByb3cgPSBnZXRSb3coeSk7XG4gICAgICBsZXQgY29sID0gZ2V0Q29sKHgpO1xuICAgICAgbGV0IGVuZFJvdyA9IGdldFJvdyh5ICsgaGVpZ2h0KTtcbiAgICAgIGxldCBlbmRDb2wgPSBnZXRDb2woeCArIHdpZHRoKTtcblxuICAgICAgbGV0IGxheWVyID0gbGF5ZXJNYXBbbmFtZV07XG5cbiAgICAgIC8vIGNoZWNrIGFsbCB0aWxlc1xuICAgICAgZm9yIChsZXQgciA9IHJvdzsgciA8PSBlbmRSb3c7IHIrKykge1xuICAgICAgICBmb3IgKGxldCBjID0gY29sOyBjIDw9IGVuZENvbDsgYysrKSB7XG4gICAgICAgICAgaWYgKGxheWVyLmRhdGFbYyArIHIgKiB0aGlzLndpZHRoXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgbGF5ZXIgdXNpbmcgZWl0aGVyIHggYW5kIHkgY29vcmRpbmF0ZXMgb3Igcm93IGFuZCBjb2x1bW4gY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCB7IFRpbGVFbmdpbmUgfSBmcm9tICdrb250cmEnO1xuICAgICAqXG4gICAgICogbGV0IHRpbGVFbmdpbmUgPSBUaWxlRW5naW5lKHtcbiAgICAgKiAgIHRpbGV3aWR0aDogMzIsXG4gICAgICogICB0aWxlaGVpZ2h0OiAzMixcbiAgICAgKiAgIHdpZHRoOiA0LFxuICAgICAqICAgaGVpZ2h0OiA0LFxuICAgICAqICAgdGlsZXNldHM6IFt7XG4gICAgICogICAgIC8vIC4uLlxuICAgICAqICAgfV0sXG4gICAgICogICBsYXllcnM6IFt7XG4gICAgICogICAgIG5hbWU6ICdjb2xsaXNpb24nLFxuICAgICAqICAgICBkYXRhOiBbIDAsMCwwLDAsXG4gICAgICogICAgICAgICAgICAgMCwxLDQsMCxcbiAgICAgKiAgICAgICAgICAgICAwLDIsNSwwLFxuICAgICAqICAgICAgICAgICAgIDAsMCwwLDAgXVxuICAgICAqICAgfV1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHRpbGVFbmdpbmUudGlsZUF0TGF5ZXIoJ2NvbGxpc2lvbicsIHt4OiA1MCwgeTogNTB9KTsgIC8vPT4gMVxuICAgICAqIHRpbGVFbmdpbmUudGlsZUF0TGF5ZXIoJ2NvbGxpc2lvbicsIHtyb3c6IDIsIGNvbDogMX0pOyAgLy89PiAyXG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIFRpbGVFbmdpbmVcbiAgICAgKiBAZnVuY3Rpb24gdGlsZUF0TGF5ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIuXG4gICAgICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fHtyb3c6IE51bWJlciwgY29sOiBOdW1iZXJ9fSBwb3NpdGlvbiAtIFBvc2l0aW9uIG9mIHRoZSB0aWxlIGluIGVpdGhlciB7eCwgeX0gb3Ige3JvdywgY29sfSBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB0aWxlIGluZGV4LiBXaWxsIHJldHVybiBgLTFgIGlmIG5vIGxheWVyIGV4aXN0cyBieSB0aGUgcHJvdmlkZWQgbmFtZS5cbiAgICAgKi9cbiAgICB0aWxlQXRMYXllcihuYW1lLCBwb3NpdGlvbikge1xuICAgICAgbGV0IHJvdyA9IHBvc2l0aW9uLnJvdyB8fCBnZXRSb3cocG9zaXRpb24ueSk7XG4gICAgICBsZXQgY29sID0gcG9zaXRpb24uY29sIHx8IGdldENvbChwb3NpdGlvbi54KTtcblxuICAgICAgaWYgKGxheWVyTWFwW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBsYXllck1hcFtuYW1lXS5kYXRhW2NvbCArIHJvdyAqIHRpbGVFbmdpbmUud2lkdGhdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGxheWVyIHVzaW5nIGVpdGhlciB4IGFuZCB5IGNvb3JkaW5hdGVzIG9yIHJvdyBhbmQgY29sdW1uIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgeyBUaWxlRW5naW5lIH0gZnJvbSAna29udHJhJztcbiAgICAgKlxuICAgICAqIGxldCB0aWxlRW5naW5lID0gVGlsZUVuZ2luZSh7XG4gICAgICogICB0aWxld2lkdGg6IDMyLFxuICAgICAqICAgdGlsZWhlaWdodDogMzIsXG4gICAgICogICB3aWR0aDogNCxcbiAgICAgKiAgIGhlaWdodDogNCxcbiAgICAgKiAgIHRpbGVzZXRzOiBbe1xuICAgICAqICAgICAvLyAuLi5cbiAgICAgKiAgIH1dLFxuICAgICAqICAgbGF5ZXJzOiBbe1xuICAgICAqICAgICBuYW1lOiAnY29sbGlzaW9uJyxcbiAgICAgKiAgICAgZGF0YTogWyAwLDAsMCwwLFxuICAgICAqICAgICAgICAgICAgIDAsMSw0LDAsXG4gICAgICogICAgICAgICAgICAgMCwyLDUsMCxcbiAgICAgKiAgICAgICAgICAgICAwLDAsMCwwIF1cbiAgICAgKiAgIH1dXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB0aWxlRW5naW5lLnNldFRpbGVBdExheWVyKCdjb2xsaXNpb24nLCB7cm93OiAyLCBjb2w6IDF9LCAxMCk7XG4gICAgICogdGlsZUVuZ2luZS50aWxlQXRMYXllcignY29sbGlzaW9uJywge3JvdzogMiwgY29sOiAxfSk7ICAvLz0+IDEwXG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIFRpbGVFbmdpbmVcbiAgICAgKiBAZnVuY3Rpb24gc2V0VGlsZUF0TGF5ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIuXG4gICAgICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fHtyb3c6IE51bWJlciwgY29sOiBOdW1iZXJ9fSBwb3NpdGlvbiAtIFBvc2l0aW9uIG9mIHRoZSB0aWxlIGluIGVpdGhlciB7eCwgeX0gb3Ige3JvdywgY29sfSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGlsZSAtIFRpbGUgaW5kZXggdG8gc2V0LlxuICAgICAqL1xuICAgIHNldFRpbGVBdExheWVyKG5hbWUsIHBvc2l0aW9uLCB0aWxlKSB7XG4gICAgICBsZXQgcm93ID0gcG9zaXRpb24ucm93IHx8IGdldFJvdyhwb3NpdGlvbi55KTtcbiAgICAgIGxldCBjb2wgPSBwb3NpdGlvbi5jb2wgfHwgZ2V0Q29sKHBvc2l0aW9uLngpO1xuXG4gICAgICBpZiAobGF5ZXJNYXBbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5fZCA9IHRydWU7XG4gICAgICAgIGxheWVyTWFwW25hbWVdLl9kID0gdHJ1ZTtcbiAgICAgICAgbGF5ZXJNYXBbbmFtZV0uZGF0YVtjb2wgKyByb3cgKiB0aWxlRW5naW5lLndpZHRoXSA9IHRpbGU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICrCoFNldMKgdGhlwqBkYXRhwqBhdMKgdGhlwqBzcGVjaWZpZWTCoGxheWVyLlxuICAgICrCoFxuICAgICrCoGBgYGpzXG4gICAgKsKgaW1wb3J0wqB7wqBUaWxlRW5naW5lwqB9wqBmcm9twqAna29udHJhJztcbiAgICAqXG4gICAgKsKgbGV0wqB0aWxlRW5naW5lwqA9wqBUaWxlRW5naW5lKHtcbiAgICAqwqDCoMKgdGlsZXdpZHRoOsKgMzIsXG4gICAgKsKgwqDCoHRpbGVoZWlnaHQ6wqAzMixcbiAgICAqwqDCoMKgd2lkdGg6wqAyLFxuICAgICrCoMKgwqBoZWlnaHQ6wqAyLFxuICAgICrCoMKgwqB0aWxlc2V0czrCoFt7XG4gICAgKsKgwqDCoMKgwqAvL8KgLi4uXG4gICAgKsKgwqDCoH1dLFxuICAgICrCoMKgwqBsYXllcnM6wqBbe1xuICAgICrCoMKgwqDCoMKgbmFtZTrCoCdjb2xsaXNpb24nLFxuICAgICrCoMKgwqDCoMKgZGF0YTrCoFvCoDAsMSxcbiAgICAqwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqAyLDPCoF1cbiAgICAqwqDCoMKgfV1cbiAgICAqwqB9KTtcbiAgICAqXG4gICAgKsKgdGlsZUVuZ2luZS5zZXRMYXllcignY29sbGlzaW9uJyzCoFvCoDQsNSw2LDddKTtcbiAgICAqwqB0aWxlRW5naW5lLnRpbGVBdExheWVyKCdjb2xsaXNpb24nLMKge3JvdzrCoDAswqBjb2w6wqAwfSk7wqDCoC8vPT7CoDRcbiAgICAqwqB0aWxlRW5naW5lLnRpbGVBdExheWVyKCdjb2xsaXNpb24nLMKge3JvdzrCoDAswqBjb2w6wqAxfSk7wqDCoC8vPT7CoDVcbiAgICAqwqB0aWxlRW5naW5lLnRpbGVBdExheWVyKCdjb2xsaXNpb24nLMKge3JvdzrCoDEswqBjb2w6wqAwfSk7wqDCoC8vPT7CoDZcbiAgICAqwqB0aWxlRW5naW5lLnRpbGVBdExheWVyKCdjb2xsaXNpb24nLMKge3JvdzrCoDEswqBjb2w6wqAxfSk7wqDCoC8vPT7CoDdcbiAgICAqwqBgYGBcbiAgICAqwqBcbiAgICAqwqBAbWVtYmVyb2bCoFRpbGVFbmdpbmVcbiAgICAqwqBAZnVuY3Rpb27CoHNldExheWVyXG4gICAgKsKgXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyLlxuICAgICrCoEBwYXJhbSB7TnVtYmVyW119wqBkYXRhwqAtwqAxRMKgYXJyYXnCoG9mwqB0aWxlwqBpbmRpY2VzLlxuICAgICovXG4gICAgc2V0TGF5ZXIobmFtZSwgZGF0YSkge1xuICAgICAgaWYgKGxheWVyTWFwW25hbWVdKSB7XG4gICAgICAgIHRoaXMuX2QgPSB0cnVlO1xuICAgICAgICBsYXllck1hcFtuYW1lXS5fZCA9IHRydWU7XG4gICAgICAgIGxheWVyTWFwW25hbWVdLmRhdGEgPSBkYXRhO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gb2JqZWN0IHRvIHRoZSB0aWxlIGVuZ2luZS4gVGhlIHRpbGUgZW5naW5lIHdpbGwgc2V0IHRoZSBvYmplY3RzIGNhbWVyYSBwb3NpdGlvbiAoYHN4YCwgYHN5YCkgdG8gYmUgaW4gc3luYyB3aXRoIHRoZSB0aWxlIGVuZ2luZSBjYW1lcmEuIFtTcHJpdGVdKGFwaS9zcHJpdGUpIHVzZXMgdGhpcyBpbmZvcm1hdGlvbiB0byBkcmF3IHRoZSBzcHJpdGUgdG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gb24gdGhlIGNhbnZhcy5cbiAgICAgKiBAbWVtYmVyb2YgVGlsZUVuZ2luZVxuICAgICAqIEBmdW5jdGlvbiBhZGRPYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBPYmplY3QgdG8gYWRkIHRvIHRoZSB0aWxlIGVuZ2luZS5cbiAgICAgKi9cbiAgICBhZGRPYmplY3Qob2JqZWN0KSB7XG4gICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgIG9iamVjdC5zeCA9IHRoaXMuX3N4O1xuICAgICAgb2JqZWN0LnN5ID0gdGhpcy5fc3k7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBvYmplY3QgZnJvbSB0aGUgdGlsZSBlbmdpbmUuXG4gICAgICogQG1lbWJlcm9mIFRpbGVFbmdpbmVcbiAgICAgKiBAZnVuY3Rpb24gcmVtb3ZlT2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gT2JqZWN0IHRvIHJlbW92ZSBmcm9tIHRoZSB0aWxlIGVuZ2luZS5cbiAgICAgKi9cbiAgICByZW1vdmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICBsZXQgaW5kZXggPSBvYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgb2JqZWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBvYmplY3Quc3ggPSBvYmplY3Quc3kgPSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBleHBvc2UgZm9yIHRlc3RpbmdcbiAgICBfcjogcmVuZGVyTGF5ZXIsXG4gICAgX3A6IHByZXJlbmRlcixcblxuICAgIC8vIEBpZmRlZiBERUJVR1xuICAgIGxheWVyQ2FudmFzZXM6IGxheWVyQ2FudmFzZXMsXG4gICAgbGF5ZXJNYXA6IGxheWVyTWFwXG4gICAgLy8gQGVuZGlmXG4gIH0sIHByb3BlcnRpZXMpO1xuXG4gIC8vIHJlc29sdmUgbGlua2VkIGZpbGVzIChzb3VyY2UsIGltYWdlKVxuICB0aWxlRW5naW5lLnRpbGVzZXRzLm1hcCh0aWxlc2V0ID0+IHtcbiAgICAvLyBnZXQgdGhlIHVybCBvZiB0aGUgVGlsZWQgSlNPTiBvYmplY3QgKGluIHRoaXMgY2FzZSwgdGhlIHByb3BlcnRpZXMgb2JqZWN0KVxuICAgIGxldCB1cmwgPSAod2luZG93Ll9fayA/IHdpbmRvdy5fX2suZG0uZ2V0KHByb3BlcnRpZXMpIDogJycpIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuXG4gICAgaWYgKHRpbGVzZXQuc291cmNlKSB7XG4gICAgICAvLyBAaWZkZWYgREVCVUdcbiAgICAgIGlmICghd2luZG93Ll9faykge1xuICAgICAgICB0aHJvdyBFcnJvcihgWW91IG11c3QgdXNlIFwibG9hZFwiIG9yIFwibG9hZERhdGFcIiB0byByZXNvbHZlIHRpbGVzZXQuc291cmNlYCk7XG4gICAgICB9XG4gICAgICAvLyBAZW5kaWZcblxuICAgICAgbGV0IHNvdXJjZSA9IHdpbmRvdy5fX2suZFt3aW5kb3cuX19rLnUodGlsZXNldC5zb3VyY2UsIHVybCldO1xuXG4gICAgICAvLyBAaWZkZWYgREVCVUdcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBZb3UgbXVzdCBsb2FkIHRoZSB0aWxlc2V0IHNvdXJjZSBcIiR7dGlsZXNldC5zb3VyY2V9XCIgYmVmb3JlIGxvYWRpbmcgdGhlIHRpbGVzZXRgKTtcbiAgICAgIH1cbiAgICAgIC8vIEBlbmRpZlxuXG4gICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLm1hcChrZXkgPT4ge1xuICAgICAgICB0aWxlc2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICgnJyt0aWxlc2V0LmltYWdlID09PSB0aWxlc2V0LmltYWdlKSB7XG4gICAgICAvLyBAaWZkZWYgREVCVUdcbiAgICAgIGlmICghd2luZG93Ll9faykge1xuICAgICAgICB0aHJvdyBFcnJvcihgWW91IG11c3QgdXNlIFwibG9hZFwiIG9yIFwibG9hZEltYWdlXCIgdG8gcmVzb2x2ZSB0aWxlc2V0LmltYWdlYCk7XG4gICAgICB9XG4gICAgICAvLyBAZW5kaWZcblxuICAgICAgbGV0IGltYWdlID0gd2luZG93Ll9fay5pW3dpbmRvdy5fX2sudSh0aWxlc2V0LmltYWdlLCB1cmwpXTtcblxuICAgICAgLy8gQGlmZGVmIERFQlVHXG4gICAgICBpZiAoIWltYWdlKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBZb3UgbXVzdCBsb2FkIHRoZSBpbWFnZSBcIiR7dGlsZXNldC5pbWFnZX1cIiBiZWZvcmUgbG9hZGluZyB0aGUgdGlsZXNldGApO1xuICAgICAgfVxuICAgICAgLy8gQGVuZGlmXG5cbiAgICAgIHRpbGVzZXQuaW1hZ2UgPSBpbWFnZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJvdyBmcm9tIHRoZSB5IGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRSb3coeSkge1xuICAgIHJldHVybiB5IC8gdGlsZUVuZ2luZS50aWxlaGVpZ2h0IHwgMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbCBmcm9tIHRoZSB4IGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gWCBjb29yZGluYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRDb2woeCkge1xuICAgIHJldHVybiB4IC8gdGlsZUVuZ2luZS50aWxld2lkdGggfCAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIGxheWVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgLSBMYXllciBkYXRhLlxuICAgKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHQgLSBDb250ZXh0IHRvIGRyYXcgbGF5ZXIgdG8uXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJMYXllcihsYXllciwgY29udGV4dCkge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBsYXllci5vcGFjaXR5O1xuXG4gICAgKGxheWVyLmRhdGEgfHwgW10pLm1hcCgodGlsZSwgaW5kZXgpID0+IHtcblxuICAgICAgLy8gc2tpcCBlbXB0eSB0aWxlcyAoMClcbiAgICAgIGlmICghdGlsZSkgcmV0dXJuO1xuXG4gICAgICAvLyBmaW5kIHRoZSB0aWxlc2V0IHRoZSB0aWxlIGJlbG9uZ3MgdG9cbiAgICAgIC8vIGFzc3VtZSB0aWxlc2V0cyBhcmUgb3JkZXJlZCBieSBmaXJzdGdpZFxuICAgICAgbGV0IHRpbGVzZXQ7XG4gICAgICBmb3IgKGxldCBpID0gdGlsZUVuZ2luZS50aWxlc2V0cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGlsZXNldCA9IHRpbGVFbmdpbmUudGlsZXNldHNbaV07XG5cbiAgICAgICAgaWYgKHRpbGUgLyB0aWxlc2V0LmZpcnN0Z2lkID49IDEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgdGlsZXdpZHRoID0gdGlsZXNldC50aWxld2lkdGggfHwgdGlsZUVuZ2luZS50aWxld2lkdGg7XG4gICAgICBsZXQgdGlsZWhlaWdodCA9IHRpbGVzZXQudGlsZWhlaWdodCB8fCB0aWxlRW5naW5lLnRpbGVoZWlnaHQ7XG4gICAgICBsZXQgbWFyZ2luID0gdGlsZXNldC5tYXJnaW4gfHwgMDtcblxuICAgICAgbGV0IGltYWdlID0gdGlsZXNldC5pbWFnZTtcblxuICAgICAgbGV0IG9mZnNldCA9IHRpbGUgLSB0aWxlc2V0LmZpcnN0Z2lkO1xuICAgICAgbGV0IGNvbHMgPSB0aWxlc2V0LmNvbHVtbnMgfHxcbiAgICAgICAgaW1hZ2Uud2lkdGggLyAodGlsZXdpZHRoICsgbWFyZ2luKSB8IDA7XG5cbiAgICAgIGxldCB4ID0gKGluZGV4ICUgdGlsZUVuZ2luZS53aWR0aCkgKiB0aWxld2lkdGg7XG4gICAgICBsZXQgeSA9IChpbmRleCAvIHRpbGVFbmdpbmUud2lkdGggfCAwKSAqIHRpbGVoZWlnaHQ7XG4gICAgICBsZXQgc3ggPSAob2Zmc2V0ICUgY29scykgKiAodGlsZXdpZHRoICsgbWFyZ2luKTtcbiAgICAgIGxldCBzeSA9IChvZmZzZXQgLyBjb2xzIHwgMCkgKiAodGlsZWhlaWdodCArIG1hcmdpbik7XG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICBpbWFnZSxcbiAgICAgICAgc3gsIHN5LCB0aWxld2lkdGgsIHRpbGVoZWlnaHQsXG4gICAgICAgIHgsIHksIHRpbGV3aWR0aCwgdGlsZWhlaWdodFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZS1yZW5kZXIgdGhlIHRpbGVzIHRvIG1ha2UgZHJhd2luZyBmYXN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcHJlcmVuZGVyKCkge1xuICAgIGlmICh0aWxlRW5naW5lLmxheWVycykge1xuICAgICAgdGlsZUVuZ2luZS5sYXllcnMubWFwKGxheWVyID0+IHtcbiAgICAgICAgbGF5ZXIuX2QgPSBmYWxzZTtcbiAgICAgICAgbGF5ZXJNYXBbbGF5ZXIubmFtZV0gPSBsYXllcjtcblxuICAgICAgICBpZiAobGF5ZXIuZGF0YSAmJiBsYXllci52aXNpYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRpbGVFbmdpbmUuX3IobGF5ZXIsIG9mZnNjcmVlbkNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgdGlsZSBlbmdpbmUgY2FudmFzLlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaWxlIGVuZ2luZSBjYW52YXMgdG8gZHJhdy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlcihjYW52YXMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldENhbnZhcygpO1xuICAgIGNvbnN0IHNXaWR0aCA9IE1hdGgubWluKGNhbnZhcy53aWR0aCwgd2lkdGgpO1xuICAgIGNvbnN0IHNIZWlnaHQgPSBNYXRoLm1pbihjYW52YXMuaGVpZ2h0LCBoZWlnaHQpO1xuXG4gICAgdGlsZUVuZ2luZS5jb250ZXh0LmRyYXdJbWFnZShcbiAgICAgIGNhbnZhcyxcbiAgICAgIHRpbGVFbmdpbmUuc3gsIHRpbGVFbmdpbmUuc3ksIHNXaWR0aCwgc0hlaWdodCxcbiAgICAgIDAsIDAsIHNXaWR0aCwgc0hlaWdodFxuICAgICk7XG4gIH1cblxuICBwcmVyZW5kZXIoKTtcbiAgcmV0dXJuIHRpbGVFbmdpbmU7XG59XG5cbmxldCBrb250cmEgPSB7XG4gIEFuaW1hdGlvbjogZmFjdG9yeSxcblxuICBpbWFnZUFzc2V0cyxcbiAgYXVkaW9Bc3NldHMsXG4gIGRhdGFBc3NldHMsXG4gIHNldEltYWdlUGF0aCxcbiAgc2V0QXVkaW9QYXRoLFxuICBzZXREYXRhUGF0aCxcbiAgbG9hZEltYWdlLFxuICBsb2FkQXVkaW8sXG4gIGxvYWREYXRhLFxuICBsb2FkLFxuXG4gIEJ1dHRvbjogZmFjdG9yeSQ1LFxuXG4gIGluaXQsXG4gIGdldENhbnZhcyxcbiAgZ2V0Q29udGV4dCxcblxuICBvbixcbiAgb2ZmLFxuICBlbWl0LFxuXG4gIEdhbWVMb29wLFxuICBHYW1lT2JqZWN0OiBmYWN0b3J5JDIsXG4gIEdyaWQ6IGZhY3RvcnkkNixcblxuICBkZWdUb1JhZCxcbiAgcmFkVG9EZWcsXG4gIGFuZ2xlVG9UYXJnZXQsXG4gIHJvdGF0ZVBvaW50LFxuICByYW5kSW50LFxuICBzZWVkUmFuZCxcbiAgbGVycCxcbiAgaW52ZXJzZUxlcnAsXG4gIGNsYW1wLFxuICBzZXRTdG9yZUl0ZW0sXG4gIGdldFN0b3JlSXRlbSxcbiAgY29sbGlkZXMsXG4gIGdldFdvcmxkUmVjdCxcblxuICBrZXlNYXAsXG4gIGluaXRLZXlzLFxuICBiaW5kS2V5cyxcbiAgdW5iaW5kS2V5cyxcbiAga2V5UHJlc3NlZCxcblxuICByZWdpc3RlclBsdWdpbixcbiAgdW5yZWdpc3RlclBsdWdpbixcbiAgZXh0ZW5kT2JqZWN0LFxuXG4gIGluaXRQb2ludGVyLFxuICBnZXRQb2ludGVyLFxuICB0cmFjayxcbiAgdW50cmFjayxcbiAgcG9pbnRlck92ZXIsXG4gIG9uUG9pbnRlckRvd24sXG4gIG9uUG9pbnRlclVwLFxuICBwb2ludGVyUHJlc3NlZCxcblxuICBQb29sOiBmYWN0b3J5JDcsXG4gIFF1YWR0cmVlOiBmYWN0b3J5JDgsXG4gIFNjZW5lOiBmYWN0b3J5JDksXG4gIFNwcml0ZTogZmFjdG9yeSQzLFxuICBTcHJpdGVTaGVldDogZmFjdG9yeSRhLFxuXG4gIFRleHQ6IGZhY3RvcnkkNCxcbiAgVGlsZUVuZ2luZSxcbiAgVmVjdG9yOiBmYWN0b3J5JDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGtvbnRyYTtcbmV4cG9ydCB7IGZhY3RvcnkgYXMgQW5pbWF0aW9uLCBmYWN0b3J5JDUgYXMgQnV0dG9uLCBHYW1lTG9vcCwgZmFjdG9yeSQyIGFzIEdhbWVPYmplY3QsIGZhY3RvcnkkNiBhcyBHcmlkLCBmYWN0b3J5JDcgYXMgUG9vbCwgZmFjdG9yeSQ4IGFzIFF1YWR0cmVlLCBmYWN0b3J5JDkgYXMgU2NlbmUsIGZhY3RvcnkkMyBhcyBTcHJpdGUsIGZhY3RvcnkkYSBhcyBTcHJpdGVTaGVldCwgZmFjdG9yeSQ0IGFzIFRleHQsIFRpbGVFbmdpbmUsIGZhY3RvcnkkMSBhcyBWZWN0b3IsIGFuZ2xlVG9UYXJnZXQsIGF1ZGlvQXNzZXRzLCBiaW5kS2V5cywgY2xhbXAsIGNvbGxpZGVzLCBkYXRhQXNzZXRzLCBkZWdUb1JhZCwgZW1pdCwgZXh0ZW5kT2JqZWN0LCBnZXRDYW52YXMsIGdldENvbnRleHQsIGdldFBvaW50ZXIsIGdldFN0b3JlSXRlbSwgZ2V0V29ybGRSZWN0LCBpbWFnZUFzc2V0cywgaW5pdCwgaW5pdEtleXMsIGluaXRQb2ludGVyLCBpbnZlcnNlTGVycCwga2V5TWFwLCBrZXlQcmVzc2VkLCBsZXJwLCBsb2FkLCBsb2FkQXVkaW8sIGxvYWREYXRhLCBsb2FkSW1hZ2UsIG9mZiwgb24sIG9uUG9pbnRlckRvd24sIG9uUG9pbnRlclVwLCBwb2ludGVyT3ZlciwgcG9pbnRlclByZXNzZWQsIHJhZFRvRGVnLCByYW5kSW50LCByZWdpc3RlclBsdWdpbiwgcm90YXRlUG9pbnQsIHNlZWRSYW5kLCBzZXRBdWRpb1BhdGgsIHNldERhdGFQYXRoLCBzZXRJbWFnZVBhdGgsIHNldFN0b3JlSXRlbSwgdHJhY2ssIHVuYmluZEtleXMsIHVucmVnaXN0ZXJQbHVnaW4sIHVudHJhY2sgfTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCB7IGluaXQsIEdhbWVMb29wLCBpbml0S2V5cywga2V5UHJlc3NlZCB9IGZyb20gJ2tvbnRyYSc7XG5pbXBvcnQgRW50aXR5IGZyb20gJy4vRW50aXR5JztcbmltcG9ydCAqIGFzIENvbHlzZXVzIGZyb20gJ2NvbHlzZXVzLmpzJ1xuXG5sZXQgcm9vbTtcbi8vY3JlYXRlIHRoZSBjYW52YXNcbmxldCB7IGNhbnZhcyB9ID0gaW5pdCgpO1xuXG5jb25zdCBjbGllbnQgPSBuZXcgQ29seXNldXMuQ2xpZW50KCd3czovL2xvY2FsaG9zdDoyNTY3Jyk7XG5cblxuLy9Tby4uLiB3ZSB3cmFwIGV2ZXJ5dGhpbmcgd2l0aCB0aGUgZ2FtZSBsb29wIGluIHRoaXMsIEkgZ3Vlc3M/XG5jbGllbnQuam9pbk9yQ3JlYXRlKFwibXlfcm9vbVwiKS50aGVuKHJvb21faW5zdGFuY2UgPT4ge1xuICByb29tID0gcm9vbV9pbnN0YW5jZVxuXG4gIGxldCBlbnRpdGllcyA9IHt9XG5cbiAgLy9BZGQgZW50aXRpZXMgdG8gdGhlIGRlYWxcbiAgcm9vbS5zdGF0ZS5lbnRpdGllcy5vbkFkZCA9IGZ1bmN0aW9uIChlbnQsIGtleSkge1xuICAgIGNvbnN0IGNvbG9ycyA9IFsnYmx1ZScsICdncmVlbicsICdyZWQnLCAnb3JhbmdlJywgJ2JsYWNrJ107XG4gICAgbmV3IEVudGl0eSh7XG4gICAgICB4OiBlbnQueCxcbiAgICAgIHk6IGVudC55LFxuICAgICAgbmFtZTogZW50Lm5hbWUsXG4gICAgICBjb2xvcjogY29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbG9ycy5sZW5ndGgpXSxcbiAgICAgIGhlaWdodDogMjAsXG4gICAgICB3aWR0aDogMjBcbiAgICB9KVxuXG4gICAgLy9UcmFjayBjaGFuZ2VzIHRvIHN0YXRlXG4gICAgZW50Lm9uQ2hhbmdlID0gKGNoYW5nZXMpID0+IHtcbiAgICAgIGxldCBjaG9zZW5FbnQgPSBFbnRpdHkuZW50aXRpZXMuZmluZChlbiA9PiBlbi5uYW1lID09PSBlbnQubmFtZSk7XG4gICAgICBjaGFuZ2VzLmZvckVhY2goY2hhbmdlID0+IHtcbiAgICAgICAgY2hvc2VuRW50W2NoYW5nZS5maWVsZF0gPSBjaGFuZ2UudmFsdWU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8vUmVtb3ZlIGVudGl0aWVzIGZyb20gdGhlIGRlYWxcbiAgcm9vbS5zdGF0ZS5lbnRpdGllcy5vblJlbW92ZSA9IGZ1bmN0aW9uIChlbnQsIGtleSkge1xuICAgIEVudGl0eS5lbnRpdGllcyA9IEVudGl0eS5lbnRpdGllcy5maWx0ZXIoeCA9PiB4Lm5hbWUgIT0gZW50Lm5hbWUpXG4gIH1cblxufSk7XG5cbmluaXRLZXlzKCk7XG5cbmNvbnN0IGhhbmRsZUlucHV0ID0gKCkgPT4ge1xuICBsZXQgZGlyWCA9IGtleVByZXNzZWQoXCJkXCIpIC0ga2V5UHJlc3NlZChcImFcIik7XG4gIGxldCBkaXJZID0ga2V5UHJlc3NlZChcInNcIikgLSBrZXlQcmVzc2VkKFwid1wiKTtcblxuICBpZigoZGlyWCB8fCBkaXJZKSAmJiByb29tKSB7XG4gICAgcm9vbS5zZW5kKFwibW92ZVwiLCB7XG4gICAgICB4OiBkaXJYLFxuICAgICAgeTogZGlyWVxuICAgIH0pO1xuICB9XG59XG5cbmxldCBsb29wID0gR2FtZUxvb3AoeyAgLy8gY3JlYXRlIHRoZSBtYWluIGdhbWUgbG9vcFxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHsgLy8gdXBkYXRlIHRoZSBnYW1lIHN0YXRlXG4gICAgaGFuZGxlSW5wdXQoKTtcbiAgICBFbnRpdHkuZW50aXRpZXMuZm9yRWFjaChlbnQgPT4gZW50LnVwZGF0ZSgpKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7IC8vIHJlbmRlciB0aGUgZ2FtZSBzdGF0ZVxuICAgIEVudGl0eS5lbnRpdGllcy5mb3JFYWNoKGVudCA9PiBlbnQucmVuZGVyKCkpO1xuICB9XG59KTtcblxubG9vcC5zdGFydCgpOyAgICAvLyBzdGFydCB0aGUgZ2FtZVxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9